# What do you mean by IIFE?

IIFE stands for **Immediately Invoked Function Expression**. It's a JavaScript design pattern where a function is defined and executed immediately after its creation. This pattern is commonly used to create a private scope for variables and functions, avoiding pollution of the global namespace.

## Syntax

The basic structure of an IIFE involves:
1. A function expression (named or anonymous)
2. Wrapping in parentheses (to make it an expression)
3. Immediate invocation with parentheses at the end

```javascript
// Classic IIFE syntax
(function() {
  // Code here executes immediately
  console.log('IIFE executed!');
})();

// With arrow function (ES6+)
(() => {
  console.log('Arrow IIFE executed!');
})();
```

## Why Use IIFE?

### **1. Avoiding Global Namespace Pollution**

Before modules (ES6), IIFEs were the primary way to create private scope:

```javascript
// Without IIFE - variables become global
var counter = 0;
function increment() { counter++; }

// With IIFE - creates private scope
(function() {
  var counter = 0; // Private to IIFE scope

  function increment() { // Private function
    counter++;
    console.log('Counter:', counter);
  }

  increment(); // Works
})();

// increment is not accessible here
console.log(counter); // ReferenceError or undefined
```

### **2. Encapsulation**

Creates self-contained code blocks with their own scope:

```javascript
// Multiple IIFEs can coexist without conflicts
(function() {
  var moduleName = 'UserManager';
  function createUser(name) {
    return { name, created: Date.now() };
  }

  // Module pattern
  window.UserManager = {
    create: createUser
  };
})();

(function() {
  var moduleName = 'DataProcessor';
  function process(data) {
    return data.map(item => item.value);
  }

  window.DataProcessor = {
    process: process
  };
})();
```

## Common IIFE Patterns

### **1. Classic IIFE (Parentheses Wrapping)**
```javascript
(function() {
  // Private scope
  var secret = 'hidden';

  function privateFunction() {
    return secret;
  }

  // Expose to global scope if needed
  window.myModule = {
    getSecret: privateFunction
  };
})();
```

### **2. Arrow Function IIFE**
```javascript
// Arrow IIFE
(() => {
  console.log('This runs immediately');
})();

// With parameters
((name, age) => {
  console.log(`${name} is ${age} years old`);
})('Alice', 30);
```

### **3. IIFE with Return Value**
```javascript
// Common module pattern
const Calculator = (function() {
  // Private variables and functions
  let operations = 0;

  function add(a, b) {
    operations++;
    return a + b;
  }

  function getOperationCount() {
    return operations;
  }

  // Public API
  return {
    add: add,
    getCount: getOperationCount
  };
})();

// Usage
console.log(Calculator.add(5, 3)); // 8
console.log(Calculator.getCount()); // 1
console.log(Calculator.operations); // undefined (private)
```

### **4. Named IIFE**
```javascript
// Named for debugging (function shows up in stack traces)
(function initApp() {
  console.log('App initialized');

  function setup() {
    console.log('Setup complete');
  }

  initApp(); // Can call itself recursively if needed
  setup();
})();
```

## Parameters in IIFE

You can pass arguments to IIFEs:

```javascript
// Passing arguments
(function(baseURL, version) {
  const api = {
    baseURL: baseURL,
    version: version,
    get endpoint() {
      return `${baseURL}/v${version}`;
    }
  };

  window.API = api;
})('https://api.example.com', '2');

// Usage
console.log(API.endpoint); // https://api.example.com/v2
```

### **Common Pattern: Dependency Injection**
```javascript
(function($, _, global) {
  // Code using jQuery and Lodash with explicit dependencies
  $('button').click(function() {
    _.each(['a', 'b', 'c'], function(item) {
      console.log(item);
    });
  });
})(jQuery, _, window);
```

## IIFE vs Other Scoping Mechanisms

### **vs Block Scope (ES6)**
```javascript
// ES6 block scope can achieve similar isolation
{
  let privateVar = 'secret';
  function privateFn() { return privateVar; }
}
// privateVar and privateFn not accessible outside

// But IIFE allows execution in same statement
const result = (function() {
  // Complex initialization
  const data = { /* ... */ };
  return data;
})();
```

### **vs Module Pattern**
```javascript
// Modern ES6 modules replaced many IIFE use cases
// module.js
const privateVar = 'secret';

export function publicFunction() {
  return privateVar;
}

// In HTML
// <script type="module" src="module.js"></script>
```

### **vs Closures**
Closures are related but different:
```javascript
// Closure - returns a function that maintains scope
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}

// IIFE - function that executes immediately
(function() {
  let count = 0;
  console.log(++count);
})();
```

## Real-World Use Cases

### **1. jQuery Plugins**
Before modules, jQuery plugins used IIFEs:

```javascript
(function($) {
  $.fn.myPlugin = function(options) {
    // Plugin code here
    return this.each(function() {
      // Initialize each element
    });
  };
})(jQuery);
```

### **2. Initialization Code**
```javascript
// Run initialization once when page loads
(function init() {
  // Setup event listeners
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM ready');
  });

  // Initialize application
  const app = {
    start: function() { /* ... */ },
    stop: function() { /* ... */ }
  };

  app.start();
})();
```

### **3. Avoiding Variable Conflicts**
```javascript
// Multiple scripts in same page
(function() {
  const $ = jQuery.noConflict();
  // Use $ safely without conflicting with other libraries
})();

// Another script
(function() {
  const $ = Zepto;
  // Different $ usage
})();
```

### **4. Performance Optimization**
```javascript
// Heavy computation in IIFE (memoization example)
const fibonacci = (function() {
  const cache = {};

  return function(n) {
    if (n <= 1) return n;
    if (cache[n]) return cache[n];

    cache[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return cache[n];
  };
})();

// fibonacci now has access to cache throughout its lifetime
```

## Debugging IIFEs

### **Named IIFEs Help with Stack Traces**
```javascript
// Anonymous IIFE - hard to debug
(function() {
  throw new Error('Something went wrong');
})(); // Stack: <anonymous>

// Named IIFE - better debugging
(function initApp() {
  throw new Error('Something went wrong');
})(); // Stack: initApp
```

### **Return Values**
```javascript
// IIFEs can return anything
const api = (function() {
  return {
    // Public API
  };
})();

// Including other IIFEs
const config = ((env) => {
  return env === 'production'
    ? { apiUrl: 'https://prod.api.com' }
    : { apiUrl: 'http://localhost:3000' };
})(process.env.NODE_ENV);
```

## Modern JavaScript Context

### **When IIFEs are Still Useful**
✅ **Global scope isolation** (especially for scripts)
✅ **Legacy code compatibility**
✅ **Immediate execution requirements**
✅ **Private scope for performance optimizations**
✅ **Avoiding naming conflicts in non-modular environments**

### **When NOT to Use IIFEs**
❌ **ES6 modules available** - use modules instead
❌ **Simple functions** - no need for immediate execution
❌ **React/Vue/Angular** - framework handles scoping
❌ **Simple variable scoping** - use block scope with `let/const`

### **ES6 Module Alternative**
```javascript
// myModule.js
const privateVar = 'secret';

function privateFunction() {
  return privateVar;
}

export const publicAPI = {
  getValue: privateFunction
};

// main.js
import { publicAPI } from './myModule.js';
console.log(publicAPI.getValue()); // Works with automatic scoping
```

## Browser Compatibility

IIFEs work in all JavaScript engines:
- Internet Explorer 6+
- All modern browsers
- Node.js

## Common Mistakes

### **1. Forgetting Parentheses**
```javascript
// Wrong - function declaration, not expression
function() {
  console.log('This will be a syntax error');
}(); // Error

// Right - wrapped in parentheses
(function() {
  console.log('IIFE works');
})();
```

### **2. Semicolon Issues**
```javascript
const x = 1;
// Forgot semicolon
(function() { console.log('IIFE') })(); // This works anyway

// Better to be explicit
const y = 2;
(function() { console.log('IIFE') })();
```

### **3. Return Value Handling**
```javascript
// Assigning IIFE result
const result = (function() {
  return 42;
})(); // result = 42

// Parentheses can be confusing
const config = function() {
  return { url: 'localhost' };
}(); // Immediately invoked (works but confusing)
```

## Interview Questions

### Q: What is an IIFE and why use it?
**A**: IIFE is Immediately Invoked Function Expression - a function that runs as soon as it's defined. Used for creating private scope and avoiding global namespace pollution.

### Q: Give an example of an IIFE?
**A**: `(function() { console.log('Hi!'); })();` or `(() => { console.log('Hi!'); })();`

### Q: Can IIFEs have parameters?
**A**: Yes, like `((name) => { console.log(`Hello ${name}`); })('Alice');`

### Q: When would you still use IIFEs in modern JavaScript?
**A**: For global scope isolation in script tags, performance optimizations requiring persistent private state, or in environments where ES6 modules aren't available.

### Q: What's the difference between an IIFE and a regular function call?
**A**: IIFE creates a function expression that's immediately executed, creating its own scope. Regular function calls execute predefined functions.

IIFEs were revolutionary for JavaScript scoping but are less necessary with modern ES6 features like modules, `let`/`const`, and block scoping. However, they remain useful in specific scenarios where immediate, isolated execution is needed.
