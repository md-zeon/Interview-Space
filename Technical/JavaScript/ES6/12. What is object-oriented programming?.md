# What is object-oriented programming?

Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects and their interactions, rather than focusing on actions and logic. It provides a structured approach to software development by modeling real-world entities and their relationships through classes and objects.

## Core Concepts of OOP

### 1. **Class**
A blueprint or template for creating objects. It defines the properties and methods that objects of that type will have.

```javascript
class Car {
  constructor(brand, model, year) {
    this.brand = brand;    // Property
    this.model = model;
    this.year = year;
  }

  start() {               // Method
    return `${this.brand} ${this.model} is starting...`;
  }
}
```

### 2. **Object**
An instance of a class - a concrete entity created from the class blueprint.

```javascript
// Creating objects from the Car class
const myCar = new Car('Toyota', 'Camry', 2020);
const yourCar = new Car('Honda', 'Civic', 2021);

console.log(myCar.start());  // "Toyota Camry is starting..."
console.log(yourCar.start()); // "Honda Civic is starting..."
```

### 3. **Encapsulation**
Bundling data (properties) and methods that operate on that data into a single unit (class). It also involves hiding internal implementation details.

```javascript
class BankAccount {
  #balance = 0;  // Private property (ES2022+)

  constructor(owner) {
    this.owner = owner;
  }

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }

  withdraw(amount) {
    if (amount <= this.#balance) {
      this.#balance -= amount;
    }
  }

  getBalance() {
    return this.#balance;  // Controlled access to private data
  }
}

const account = new BankAccount('John');
account.deposit(1000);
console.log(account.getBalance()); // 1000
// console.log(account.#balance); // Error: Private field
```

## Four Pillars of OOP

### 1. **Encapsulation**
- **Definition**: Wrapping data and methods into a single unit and restricting access to some components
- **Benefits**: Data protection, reduced complexity, better maintainability
- **Implementation**: Private/public methods and properties

```javascript
class Person {
  // Private property (convention: underscore prefix in JS)
  _ssn = '';

  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // Public method
  getName() {
    return this.name;
  }

  // Private method (ES2022)
  #validateSSN(ssn) {
    return typeof ssn === 'string' && ssn.length === 9;
  }

  setSSN(ssn) {
    if (this.#validateSSN(ssn)) {
      this._ssn = ssn;
    }
  }
}
```

### 2. **Inheritance**
- **Definition**: Creating new classes from existing classes, inheriting properties and methods
- **Benefits**: Code reusability, hierarchical classification, maintainable code
- **Types**: Single inheritance, multiple inheritance, multilevel inheritance

```javascript
// Parent class (base/super class)
class Vehicle {
  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  start() {
    return `${this.make} ${this.model} is starting`;
  }
}

// Child class (derived/sub class) inherits from Vehicle
class Car extends Vehicle {
  constructor(make, model, doors) {
    super(make, model);  // Call parent constructor
    this.doors = doors;
  }

  // Override parent method
  start() {
    return `${super.start()} with ${this.doors} doors`;
  }

  // New method specific to Car
  drive() {
    return `${this.make} ${this.model} is driving`;
  }
}

const myCar = new Car('Toyota', 'Camry', 4);
console.log(myCar.start());  // "Toyota Camry is starting with 4 doors"
console.log(myCar.drive());  // "Toyota Camry is driving"
```

### 3. **Polymorphism**
- **Definition**: Ability of objects to take on multiple forms - same method name can behave differently
- **Benefits**: Flexibility, interchangeable objects, cleaner code
- **Types**: Compile-time (method overloading), runtime (method overriding)

```javascript
class Animal {
  speak() {
    return 'Animal makes a sound';
  }
}

class Dog extends Animal {
  speak() {  // Method overriding (runtime polymorphism)
    return 'Woof!';
  }
}

class Cat extends Animal {
  speak() {
    return 'Meow!';
  }
}

class Fish extends Animal {
  speak() {
    return '...';  // Fish don't speak (different behavior)
  }
}

// Polymorphic function - works with any Animal
function makeAnimalSpeak(animal) {
  console.log(animal.speak());
}

const animals = [new Dog(), new Cat(), new Fish()];
animals.forEach(makeAnimalSpeak);
// Output:
// Woof!
// Meow!
// ...
```

### 4. **Abstraction**
- **Definition**: Hiding complex implementation details and exposing only essential features
- **Benefits**: Simplified interfaces, reduced complexity, better security
- **Implementation**: Abstract classes, interfaces (not native in JS but can be simulated)

```javascript
// Abstract concept using a base class
class Shape {
  constructor(color) {
    this.color = color;
    if (new.target === Shape) {
      throw new Error('Shape is an abstract class and cannot be instantiated directly');
    }
  }

  // Abstract method (pure virtual method concept)
  area() {
    throw new Error('area() method must be implemented by concrete classes');
  }

  getColor() {
    return this.color;
  }
}

class Circle extends Shape {
  constructor(color, radius) {
    super(color);
    this.radius = radius;
  }

  area() {  // Implementing abstract method
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(color, width, height) {
    super(color);
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

// const shape = new Shape('red'); // Error: Cannot instantiate abstract class
const circle = new Circle('red', 5);
const rectangle = new Rectangle('blue', 4, 6);

console.log(circle.area());     // 78.54
console.log(rectangle.area());  // 24
```

## OOP in JavaScript

### **Prototypal vs Classical OOP**
JavaScript uses **prototypal inheritance** rather than classical class-based inheritance (though ES6 classes provide syntactic sugar).

```javascript
// Classical OOP (ES6 syntax)
class Person {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    return `Hello, I'm ${this.name}`;
  }
}

// Equivalent Prototype-based OOP
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  return `Hello, I'm ${this.name}`;
};

const person1 = new Person('Alice');
console.log(person1.sayHello()); // "Hello, I'm Alice"
```

### **Key JavaScript OOP Features**
- **Constructor Functions**: Functions used to create objects
- **Prototype Chain**: Objects inherit from prototype objects
- **this Keyword**: Refers to current object instance
- **new Keyword**: Creates new object instances
- **instanceof**: Checks if object is instance of a class/function

## Benefits of OOP

### **1. Modularity and Reusability**
```javascript
// Create reusable components
class Logger {
  log(message, level = 'info') {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${level.toUpperCase()}]: ${message}`);
  }
}

// Use throughout application
const logger = new Logger();
logger.log('User logged in');         // [2023-...] [INFO]: User logged in
logger.log('Database error', 'error'); // [2023-...] [ERROR]: Database error
```

### **2. Data Encapsulation**
```javascript
class ShoppingCart {
  #items = [];  // Private data

  addItem(item) {
    this.#items.push(item);
    this.#updateTotal();
  }

  getTotal() {
    return this.#calculateTotal();
  }

  #updateTotal() { /* private method */ }
  #calculateTotal() { /* private method */ return /* total */; }
}
```

### **3. Easier Maintenance**
Organized code structure makes debugging and enhancements simpler:
- Related code grouped together
- Changes isolated to specific classes
- Inheritance reduces code duplication

### **4. Real-World Modeling**
OOP aligns with how we think about the world:
```javascript
class Company {
  constructor(name) {
    this.name = name;
    this.employees = [];
    this.departments = [];
  }

  hire(employee) {
    this.employees.push(employee);
  }

  createDepartment(dept) {
    this.departments.push(dept);
  }
}

class Department {
  constructor(name) {
    this.name = name;
    this.manager = null;
    this.staff = [];
  }

  setManager(employee) {
    this.manager = employee;
  }
}
```

## Common OOP Patterns

### **1. Singleton Pattern**
Ensures only one instance of a class exists:
```javascript
class Database {
  constructor() {
    if (Database.instance) {
      return Database.instance;
    }
    Database.instance = this;
    this.connection = null;
  }

  connect() {
    if (!this.connection) {
      this.connection = 'Connected to database';
    }
    return this.connection;
  }
}

const db1 = new Database();
const db2 = new Database();
console.log(db1 === db2); // true (same instance)
```

### **2. Factory Pattern**
Creates objects without specifying exact classes:
```javascript
class CarFactory {
  createCar(type) {
    switch (type) {
      case 'sedan':
        return new Sedan();
      case 'suv':
        return new SUV();
      case 'truck':
        return new Truck();
      default:
        throw new Error(`Unknown car type: ${type}`);
    }
  }
}

const factory = new CarFactory();
const mySedan = factory.createCar('sedan');
```

### **3. Observer Pattern**
Objects subscribe to events and get notified:
```javascript
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log(`Received update: ${data}`);
  }
}

const subject = new Subject();
const observer1 = new Observer();
subject.subscribe(observer1);
subject.notify('New data available!');
```

## OOP vs Other Paradigms

### **Functional Programming**
- **OOP**: Focuses on objects and state
- **FP**: Focuses on functions and immutable data
- **Hybrid**: Many modern languages support both

### **Procedural Programming**
- **OOP**: Organized around objects
- **Procedural**: Organized around procedures/functions
- **Benefit**: OOP provides better structure for large applications

## When to Use OOP

### ✅ **Good Use Cases**
- Large, complex applications
- Real-world modeling (business logic)
- GUI applications
- Game development
- Libraries and frameworks

### ❌ **Avoid When**
- Small, simple scripts
- Mathematical computations
- Data processing pipelines
- Performance-critical code
- When functional programming fits better

## Interview Questions

### Q: What are the four pillars of OOP?
**A**: Encapsulation, Inheritance, Polymorphism, and Abstraction.

### Q: Explain the difference between class and object.
**A**: Class is a blueprint/template, object is an instance created from that class.

### Q: What is method overriding?
**A**: When a child class provides its own implementation of a method from the parent class.

### Q: Why is encapsulation important?
**A**: It helps protect data from unauthorized access and reduces complexity by hiding implementation details.

### Q: Can JavaScript classes have private members?
**A**: Yes, using `#` prefix (ES2022+) or conventions like `_` prefix (though not truly private).

OOP is a powerful paradigm that helps create maintainable, reusable, and scalable code by organizing software around objects and their interactions.
