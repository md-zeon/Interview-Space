# What is destructuring?

Destructuring is a JavaScript feature introduced in ES6 that allows you to extract values from arrays and objects and assign them to variables in a single, concise statement. It provides a convenient way to unpack values from structured data without writing repetitive code.

## Array Destructuring

### **Basic Array Destructuring**
```javascript
// Traditional way
const colors = ['red', 'green', 'blue'];
const firstColor = colors[0];
const secondColor = colors[1];

// Destructuring way
const [first, second] = colors;
console.log(first);  // 'red'
console.log(second); // 'green'
```

### **Skipping Elements**
```javascript
// Skip elements with empty slots
const [, second, , fourth] = [1, 2, 3, 4, 5];
console.log(second); // 2
console.log(fourth); // 4

// Skip first two elements
const [, , third, fourth] = [1, 2, 3, 4];
console.log(third);  // 3
console.log(fourth); // 4
```

### **Rest Operator in Arrays**
```javascript
// Collect remaining elements
const [first, second, ...rest] = [1, 2, 3, 4, 5];
console.log(first);  // 1
console.log(second); // 2
console.log(rest);   // [3, 4, 5]

// Get first element, rest in array
const [head, ...tail] = [1, 2, 3, 4];
console.log(head); // 1
console.log(tail); // [2, 3, 4]
```

### **Default Values**
```javascript
// Provide defaults for missing elements
const [first = 'default', second = 'second'] = ['actual'];
console.log(first);  // 'actual'
console.log(second); // 'second'
```

## Object Destructuring

### **Basic Object Destructuring**
```javascript
// Traditional way
const user = { name: 'John', age: 30, city: 'NYC' };
const name = user.name;
const age = user.age;

// Destructuring way
const { name, age } = user;
console.log(name); // 'John'
console.log(age);  // 30
```

### **Different Variable Names**
```javascript
// Extract with different variable names
const { name: userName, age: userAge } = user;
console.log(userName); // 'John'
console.log(userAge);  // 30

// Variable name same as property name
const { name, age } = user; // Equivalent to name: name, age: age
```

### **Rest Operator in Objects**
```javascript
// Collect remaining properties
const { name, age, ...others } = { name: 'John', age: 30, city: 'NYC', country: 'USA' };
console.log(name);   // 'John'
console.log(age);    // 30
console.log(others); // { city: 'NYC', country: 'USA' }

// Extract specific, rest in separate object
const { city, ...userInfo } = { name: 'John', age: 30, city: 'NYC' };
console.log(city);    // 'NYC'
console.log(userInfo); // { name: 'John', age: 30 }
```

### **Default Values in Objects**
```javascript
// Default values for missing properties
const { name = 'Anonymous', age = 18, city = 'Unknown' } = { name: 'John', city: 'NYC' };
console.log(name);  // 'John' (provided)
console.log(age);   // 18 (default)
console.log(city);  // 'NYC' (provided)
```

### **Nested Object Destructuring**
```javascript
// Destructure nested objects
const user = {
  name: 'John',
  address: {
    street: '123 Main St',
    city: 'NYC',
    coordinates: {
      lat: 40.7128,
      lng: -74.0060
    }
  }
};

const { address: { street, city, coordinates: { lat, lng } } } = user;
console.log(street); // '123 Main St'
console.log(city);   // 'NYC'
console.log(lat);    // 40.7128
console.log(lng);    // -74.0060

// With different variable names
const { address: { street: userStreet, city: userCity } } = user;
console.log(userStreet); // '123 Main St'
console.log(userCity);   // 'NYC'
```

## Parameter Destructuring

### **Function Parameters**
```javascript
// Traditional function parameter
function printUser(user) {
  console.log(`Name: ${user.name}, Age: ${user.age}`);
}

// Destructuring parameter
function printUser({ name, age }) {
  console.log(`Name: ${name}, Age: ${age}`);
}

// With defaults
function printUser({ name = 'Anonymous', age = 18 } = {}) {
  console.log(`Name: ${name}, Age: ${age}`);
}

printUser({ name: 'John', age: 30 }); // Name: John, Age: 30
printUser();                          // Name: Anonymous, Age: 18
```

### **Array Parameters**
```javascript
function processArray([first, second, ...rest]) {
  console.log('First:', first);
  console.log('Second:', second);
  console.log('Rest:', rest);
}

processArray([1, 2, 3, 4, 5]);
// First: 1
// Second: 2
// Rest: [3, 4, 5]
```

## Advanced Patterns

### **Swapping Variables**
```javascript
// Swap two variables using array destructuring
let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b); // 2, 1

// Traditional swap needed temporary variable
// let temp = a; a = b; b = temp;
```

### **Multiple Return Values**
```javascript
// Functions can return multiple values using arrays
function getMinMax(arr) {
  return [Math.min(...arr), Math.max(...arr)];
}

const [min, max] = getMinMax([3, 1, 7, 2, 9]);
console.log(min, max); // 1, 9

// Using objects for named returns
function analyzeNumbers(numbers) {
  return {
    sum: numbers.reduce((a, b) => a + b, 0),
    avg: numbers.reduce((a, b) => a + b, 0) / numbers.length,
    min: Math.min(...numbers),
    max: Math.max(...numbers)
  };
}

const { sum, avg, min, max } = analyzeNumbers([1, 2, 3, 4, 5]);
console.log(sum, avg); // 15, 3
```

### **Dynamic Property Names**
```javascript
// Combine with computed property names
const propName = 'firstName';
const { [propName]: extractedValue } = { firstName: 'John' };
console.log(extractedValue); // 'John'

// Useful for API responses
const key = 'data';
const { [key]: apiData } = { data: [1, 2, 3], error: null };
console.log(apiData); // [1, 2, 3]
```

### **Mixed Destructuring**
```javascript
// Array containing objects
const users = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 },
  { name: 'Bob', age: 35 }
];

// Get first user, and extract their details
const [{ name: firstUserName, age: firstUserAge }, ...otherUsers] = users;
console.log(firstUserName, firstUserAge); // John, 30
console.log(otherUsers); // [{ name: 'Jane', age: 25 }, { name: 'Bob', age: 35 }]

// Complex nested example
const complex = {
  data: [1, 2, { nested: { value: 'found' } }],
  meta: { total: 100, page: 1 }
};

const {
  data: [first, second, { nested: { value } }],
  meta: { total, page }
} = complex;

console.log(first, second, value, total, page); // 1, 2, 'found', 100, 1
```

## Practical Use Cases

### **React Props Destructuring**
```javascript
// Component props
function UserCard({ user, onEdit, onDelete, theme = 'light' }) {
  const { name, email, avatar } = user;

  return (
    <div className={`card ${theme}`}>
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
      <button onClick={onEdit}>Edit</button>
      <button onClick={onDelete}>Delete</button>
    </div>
  );
}

// Usage
<UserCard
  user={{ name: 'John', email: 'john@example.com', avatar: '...' }}
  onEdit={() => console.log('Edit')}
  onDelete={() => console.log('Delete')}
/>
```

### **API Response Handling**
```javascript
// Destructure API responses
const response = {
  data: { user: { id: 123, name: 'John', email: 'john@example.com' } },
  status: 'success',
  message: 'User found'
};

const {
  data: { user },
  status,
  message: msg
} = response;

// Deep destructuring
const { data: { user: { name, email, id } } } = response;
console.log(name, email, id); // John, john@example.com, 123
```

### **Configuration Objects**
```javascript
// Default configuration with overrides
function configureApp(options = {}) {
  const {
    port = 3000,
    host = 'localhost',
    debug = false,
    database: {
      host: dbHost = 'localhost',
      port: dbPort = 5432,
      name: dbName = 'myapp'
    } = {}
  } = options;

  return { port, host, debug, database: { host: dbHost, port: dbPort, name: dbName } };
}

const config = configureApp({
  port: 8080,
  database: { name: 'production' }
});
console.log(config.port);        // 8080
console.log(config.database.name); // 'production'
```

### **Event Handling**
```javascript
// Destructure event objects
function handleClick(event) {
  const { target, clientX, clientY, currentTarget } = event;
  console.log(`Clicked ${target.tagName} at (${clientX}, ${clientY})`);

  // More complex events
  if (target.matches('button')) {
    const { dataset: { action } } = event;
    performAction(action);
  }
}

// Form event
function handleSubmit(event) {
  event.preventDefault();
  const { target: form } = event;
  const formData = new FormData(form);

  // Convert to object
  const data = Object.fromEntries(formData);
  submitForm(data);
}
```

## Comparison with Traditional Access

### **Before Destructuring**
```javascript
// Accessing nested properties manually
function processUser(user) {
  const name = user.name;
  const email = user.contact.email;
  const firstFriend = user.friends[0].name;

  return { name, email, firstFriend };
}
```

### **With Destructuring**
```javascript
// Cleaner and more readable
function processUser(user) {
  const {
    name,
    contact: { email },
    friends: [firstFriend] = []
  } = user;

  return { name, email, firstFriend: firstFriend?.name };
}
```

## Error Handling

### **Safe Destructuring**
```javascript
// Provide defaults for potentially undefined objects
const config = {};
const { db = {} } = config;
const { host = 'localhost', port = 5432 } = db;

// Or use logical OR
const { db: { host, port } } = config || { db: {} };

// Safe deep destructuring
const safeUser = config.user || {};
const { name = 'Guest', email } = safeUser;
```

## Performance Considerations

### **Destructuring Arrays**
```javascript
// Destructuring creates new variables (no performance difference from manual assignment)
const arr = [1, 2, 3, 4, 5];
const [a, b, c] = arr;        // Same performance as:
const a = arr[0], b = arr[1], c = arr[2];
```

### **Object Destructuring**
```javascript
// Property access is optimized by the engine
const obj = { a: 1, b: 2, c: 3 };
const { a, b, c } = obj;       // Same performance as:
const a = obj.a, b = obj.b, c = obj.c;
```

## Browser Support

Destructuring is supported in modern browsers:
- Chrome 49+ (full support arrays, 58+ objects)
- Firefox 41+ (arrays), 45+ (objects)
- Safari 8+ (partial), 10.1+ (full)
- Edge 16+ (partial), 79+ (full)

For older browsers, use Babel transpilation or provide fallback code.

## Interview Questions

### Q: What is destructuring in JavaScript?
**A**: Destructuring allows extracting values from arrays and objects using array/object literal syntax, assigning them to variables in a single statement.

### Q: What's the difference between array and object destructuring?
**A**: Array destructuring uses position (index-based), object destructuring uses property names. Array order matters, object keys can be in any order.

### Q: Can you destructure function parameters?
**A**: Yes, function parameters can use destructuring syntax to extract properties directly in the parameter declaration.

### Q: What's the default parameter in destructuring?
**A**: When destructuring, you can use `=` to provide default values if the extracted value is `undefined`.

### Q: Can destructuring create new variables?
**A**: No, destructuring assigns to existing or new variables. If a variable doesn't exist, it will be created in the appropriate scope.

Destructuring makes code more readable, eliminates repetitive property access, and provides a powerful way to extract and work with structured data in JavaScript.
