# What is template literal in ES6?

Template literals, introduced in ES6, revolutionize string handling in JavaScript by providing a more powerful and flexible way to work with strings. They use backticks (`` ` ``) instead of quotes and offer string interpolation, multiline strings, and advanced formatting capabilities.

## Syntax and Basic Usage

### **Traditional String Concatenation (ES5)**
```javascript
// Old way - string concatenation
var name = "John";
var age = 30;
var message = "Hello, my name is " + name + " and I am " + age + " years old.";

// Multi-line strings - ugly and error-prone
var html = "<div>\n" +
           "  <h1>Title</h1>\n" +
           "  <p>Content</p>\n" +
           "</div>";
```

### **Template Literals (ES6)**
```javascript
// New way - template literals
const name = "John";
const age = 30;
const message = `Hello, my name is ${name} and I am ${age} years old.`;

// Multi-line strings - clean and readable
const html = `<div>
  <h1>Title</h1>
  <p>Content</p>
</div>`;
```

## Key Features

### **1. String Interpolation**
Embed expressions inside strings using `${expression}`.

```javascript
const user = {
  name: "Alice",
  age: 25,
  occupation: "developer"
};

const greeting = `Hello ${user.name}! You are ${user.age} years old and work as a ${user.occupation}.`;
// "Hello Alice! You are 25 years old and work as a developer."
```

### **2. Expression Evaluation**
Any valid JavaScript expression works inside `${}`.

```javascript
const a = 10;
const b = 5;

console.log(`Sum: ${a + b}`);        // "Sum: 15"
console.log(`Math: ${Math.max(a, b)}`);  // "Math: 10"
console.log(`Random: ${Math.random()}`); // Random number
console.log(`Length: ${"hello".length}`); // "Length: 5"

// Conditional expressions
const status = true;
console.log(`System is ${status ? 'online' : 'offline'}`);

const score = 85;
console.log(`Grade: ${score >= 90 ? 'A' : score >= 80 ? 'B' : 'C'}`);
```

### **3. Multi-line Strings**
No need for explicit line breaks or concatenation.

```javascript
// Template literal preserves whitespace
const poem = `Roses are red,
Violets are blue,
JavaScript is great,
And so are you!`;

console.log(poem);
// Output:
// Roses are red,
// Violets are blue,
// JavaScript is great,
// And so are you!

// Useful for HTML templates
const card = `
<div class="card">
  <h2>Product Title</h2>
  <p>Description here</p>
  <button>Buy Now</button>
</div>
`;
```

### **4. Nested Templates**
Template literals can contain other template literals.

```javascript
const items = ['Apple', 'Banana', 'Cherry'];
const listHtml = `
<ul>
  ${items.map(item => `<li>${item}</li>`).join('\n  ')}
</ul>
`;

console.log(listHtml);
// Output:
// <ul>
//   <li>Apple</li>
//   <li>Banana</li>
//   <li>Cherry</li>
// </ul>
```

## Advanced Features

### **Tagged Templates**
Custom functions that process template literals providing advanced formatting control.

```javascript
// Basic tagged template
function highlight(strings, ...values) {
  return strings.reduce((result, string, i) => {
    return result + string + (values[i] ? `<mark>${values[i]}</mark>` : '');
  }, '');
}

const name = "Alice";
const age = 30;
const result = highlight`Hello ${name}, you are ${age} years old!`;
console.log(result); // "Hello <mark>Alice</mark>, you are <mark>30</mark> years old!"
```

### **Raw Strings (Raw Property)**
Access unprocessed string content, including escaped characters.

```javascript
function showRaw(strings) {
  return strings.raw[0];
}

const rawString = showRaw`Line 1\nLine 2\tTabbed`;
console.log(rawString); // "Line 1\\nLine 2\\tTabbed" (preserves actual backslash)

// Useful for regular expressions
const regex = String.raw`(\w+)\s(\w+)`;
console.log(regex); // "(\\w+)\\s(\\w+)" - proper regex pattern
```

### **Template Literal with Functions**
```javascript
// Currency formatter
function currency(amount, currency = 'USD') {
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency
  });

  return formatter.format(amount);
}

const price = 99.99;
console.log(`Total: ${currency(price)}`);        // "Total: $99.99"
console.log(`Total: ${currency(price, 'EUR')}`); // "Total: â‚¬99.99"

// Date formatter
function formatDate(date) {
  return new Intl.DateTimeFormat('en-US').format(date);
}

const today = new Date();
console.log(`Today is ${formatDate(today)}`);
```

## Comparisons and Conversions

### **Template Literals vs String Concatenation**
```javascript
// Concatenation - hard to read
let fullName = firstName + " " + lastName;

// Interpolation - clean and readable
let fullName = `${firstName} ${lastName}`;
```

### **Template Literals vs String Methods**
```javascript
// Before ES6
const message = "Hello ".concat(name, ", you scored ", score, " points!");

// With template literals
const message = `Hello ${name}, you scored ${score} points!`;
```

## Escaping and Special Characters

### **Escaping Backticks**
```javascript
// To include literal backtick in template literal
const code = `Use \`template literals\` for string interpolation`;

// Or use quotes inside backticks
const quote = `He said "Hello World"`;
const singleQuote = `It's a beautiful day`;
```

### **Escaping Dollars**
```javascript
// To include literal $ in template literal
const price = `The item costs $${amount}`;
```

## Performance Considerations

### **Template Literals vs Concatenation**
```javascript
// For simple concatenations, + is faster
const name = 'John';
const result = 'Hello ' + name; // Slightly faster

// For complex expressions, template literals are comparable
const result = `Hello ${name}`; // Same performance

// Template literals are better for readability when expressions are involved
const result = `Hello ${user.name}, your score is ${calculateScore(user)}`;
```

## Common Use Cases

### **1. Dynamic SQL Query Building**
```javascript
function buildQuery(table, conditions) {
  return `SELECT * FROM ${table} WHERE ${conditions.join(' AND ')}`;
}

const query = buildQuery('users', ['age > 18', 'status = "active"']);
console.log(query); // "SELECT * FROM users WHERE age > 18 AND status = "active""
```

### **2. HTML Template Generation**
```javascript
function createUserCard(user) {
  return `
    <div class="user-card">
      <img src="${user.avatar}" alt="Avatar">
      <h3>${user.name}</h3>
      <p>${user.bio || 'No bio available'}</p>
      <div class="stats">
        <span>Posts: ${user.postsCount}</span>
        <span>Followers: ${user.followersCount}</span>
      </div>
    </div>
  `;
}
```

### **3. CSS-in-JS**
```javascript
const theme = {
  primary: '#007bff',
  secondary: '#6c757d',
  fontSize: '16px'
};

const styles = `
  .button-primary {
    background-color: ${theme.primary};
    color: white;
    font-size: ${theme.fontSize};
  }

  .button-secondary {
    background-color: ${theme.secondary};
    color: white;
  }
`;
```

### **4. Error Messages and Logging**
```javascript
function validateInput(input, rules) {
  for (const rule of rules) {
    if (!rule.validate(input)) {
      throw new Error(`Validation failed: ${rule.message}`);
    }
  }
}

// Better error with template literals
function validateInput(input, rules) {
  for (const rule of rules) {
    if (!rule.validate(input)) {
      throw new Error(`${rule.message} (received: ${typeof input} "${input}")`);
    }
  }
}
```

### **5. File Path Construction**
```javascript
const basePath = '/api/v1';
const resource = 'users';
const id = '123';

const apiUrl = `${basePath}/${resource}/${id}/profile`;
// "/api/v1/users/123/profile"
```

## Tagged Templates Advanced Examples

### **SQL Injection Prevention**
```javascript
function sql(strings, ...values) {
  // In a real implementation, you'd use a proper SQL builder
  return strings.reduce((query, string, i) => {
    return query + string + (values[i] !== undefined ? '?' : '');
  }, '');
}

const userId = 123;
const query = sql`SELECT * FROM users WHERE id = ${userId}`;
// Parameters would be handled separately to prevent injection
```

### **Internationalization (i18n)**
```javascript
function t(strings, ...values) {
  // Simple translation function
  const translations = {
    'Hello ${0}, you have ${1} messages': 'Hola ${0}, tienes ${1} mensajes'
  };

  let key = strings.reduce((result, string, i) => {
    return result + string + (values[i] !== undefined ? `\${${i}}` : '');
  }, '');

  return (translations[key] || key).replace(/\$\{(\d+)\}/g, (match, index) => values[index]);
}

const name = 'Maria';
const count = 5;
console.log(t`Hello ${name}, you have ${count} messages`);
// In Spanish locale: "Hola Maria, tienes 5 mensajes"
```

### **React-like JSX Simulation**
```javascript
function html(strings, ...values) {
  return strings.reduce((result, string, i) => {
    return result + string + (values[i] || '');
  }, '');
}

const user = { name: 'John', age: 30 };
const element = html`
  <div class="user">
    <h1>${user.name}</h1>
    <p>Age: ${user.age}</p>
  </div>
`;
```

## Browser Support and Transpilation

Template literals are supported in modern browsers:
- Chrome 41+
- Firefox 34+
- Safari 9+
- Edge 12+

For older browsers, use Babel or similar transpilors:
```javascript
// Babel transforms template literals to concatenation
"Hello ${name}" // becomes "Hello ".concat(name)
```

## Interview Questions

### Q: What's the difference between template literals and regular strings?
**A**: Template literals use backticks, allow interpolation with ${}, and support multiline strings. Regular strings use single/double quotes and don't support these features.

### Q: Can you nest template literals?
**A**: Yes, template literals can be nested inside each other using ${}.

### Q: What's a tagged template?
**A**: A tagged template is a function that processes a template literal, allowing custom string processing.

### Q: Why use template literals instead of concatenation?
**A**: Better readability, easier multiline strings, direct expression evaluation, and cleaner code.

### Q: Can template literals be used for SQL queries?
**A**: They can, but be careful with SQL injection. Use parameterized queries or builders instead.

Template literals significantly improve string handling in JavaScript, making code more readable, maintainable, and powerful.
