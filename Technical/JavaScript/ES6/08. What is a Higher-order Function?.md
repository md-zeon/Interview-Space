# What is a Higher-order Function?

A **higher-order function** is a function that either takes one or more functions as arguments, or returns a function as its result. This concept is fundamental to functional programming and is widely used in JavaScript, especially with array methods and asynchronous operations.

## Definition

**Higher-Order Function (HOF)**: A function that operates on other functions, either by taking them as arguments or by returning them.

- Takes functions as parameters (callbacks)
- Returns a function as output
- Can do both

## Examples of Built-in Higher-Order Functions

### Array Methods

#### `map()` - Transforms each element
```javascript
// Takes a function as argument, applies it to each element
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6, 8]
```

#### `filter()` - Filters elements based on condition
```javascript
// Takes a predicate function as argument
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]
```

#### `reduce()` - Reduces array to single value
```javascript
// Takes a reducer function and initial value
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum); // 10
```

#### `forEach()` - Executes function for each element
```javascript
// Takes a function to execute for each element
const fruits = ['apple', 'banana', 'cherry'];
fruits.forEach(fruit => console.log(fruit));
// Output: apple, banana, cherry
```

#### `find()` - Returns first element that matches
```javascript
// Takes a predicate function
const users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
  { id: 3, name: 'Bob' }
];

const user = users.find(user => user.id === 2);
console.log(user); // { id: 2, name: 'Jane' }
```

### Event Handling Functions

```javascript
// setTimeout, setInterval, addEventListener all take callbacks
document.addEventListener('click', () => {
  console.log('Button clicked!');
});

setTimeout(() => {
  console.log('Executed after 1 second');
}, 1000);
```

## Functions That Return Functions

### Factory Functions
```javascript
function createMultiplier(x) {
  return function(y) {
    return x * y;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

### Currying
```javascript
function curryAdd(x) {
  return function(y) {
    return x + y;
  };
}

const add5 = curryAdd(5);
console.log(add5(3)); // 8
console.log(add5(10)); // 15
```

### Closures for Data Hiding
```javascript
function createCounter() {
  let count = 0;

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());   // 2
```

## Custom Higher-Order Functions

### Creating Your Own HOFs

#### Example 1: Simple Logger
```javascript
function withLogging(fn) {
  return function(...args) {
    console.log(`Calling ${fn.name} with arguments:`, args);
    const result = fn(...args);
    console.log(`Result: ${result}`);
    return result;
  };
}

function add(a, b) {
  return a + b;
}

const loggedAdd = withLogging(add);
loggedAdd(3, 4);
// Output:
// Calling add with arguments: [3, 4]
// Result: 7
```

#### Example 2: Memoization
```javascript
function memoize(fn) {
  const cache = {};

  return function(...args) {
    const key = JSON.stringify(args);

    if (cache[key]) {
      console.log('Returning cached result');
      return cache[key];
    }

    const result = fn(...args);
    cache[key] = result;
    return result;
  };
}

function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

const memoizedFib = memoize(fibonacci);
console.log(memoizedFib(10)); // Calculates and caches
console.log(memoizedFib(10)); // Returns cached result
```

#### Example 3: Validation Wrapper
```javascript
function validateInput(validator, fn) {
  return function(input) {
    if (!validator(input)) {
      throw new Error('Invalid input');
    }
    return fn(input);
  };
}

function isPositiveNumber(num) {
  return typeof num === 'number' && num > 0;
}

function square(num) {
  return num * num;
}

const validatedSquare = validateInput(isPositiveNumber, square);

console.log(validatedSquare(5));  // 25
// validatedSquare(-3); // Throws Error: Invalid input
```

## Real-World Applications

### Asynchronous Programming
```javascript
// Promises with higher-order functions
function fetchData(url) {
  return fetch(url)
    .then(response => response.json())
    .then(data => data);  // .then() takes callbacks
}

// Async/await with HOFs
async function processUsers(users) {
  const processedUsers = users.map(async user => {
    const profile = await fetchUserProfile(user.id);
    return { ...user, profile };
  });

  return Promise.all(processedUsers);
}
```

### React/Redux
```javascript
// connect() is HOF that returns HOF
const connect = (mapStateToProps, mapDispatchToProps) => {
  return (Component) => {
    return (props) => {
      // Returns wrapped component
    };
  };
};

// Usage
const ConnectedComponent = connect(mapStateToProps)(MyComponent);
```

### Array Utilities
```javascript
// Custom array utilities using HOFs
function pipe(...fns) {
  return function(initialValue) {
    return fns.reduce((value, fn) => fn(value), initialValue);
  };
}

const processData = pipe(
  data => data.filter(item => item.active),
  data => data.map(item => ({ ...item, processed: true })),
  data => data.sort((a, b) => a.timestamp - b.timestamp)
);

const result = processData(rawData);
```

## Benefits of Higher-Order Functions

### 1. **Code Reusability**
```javascript
// Reusable validation function
function validateAndExecute(validator, action, errorHandler) {
  return function(value) {
    if (validator(value)) {
      return action(value);
    } else {
      return errorHandler(value);
    }
  };
}

// Use it for different validations
const validateEmailAndSend = validateAndExecute(
  isValidEmail,
  sendConfirmationEmail,
  logInvalidEmail
);
```

### 2. **Modularity**
```javascript
// Break down complex operations
const pipeline = [
  parseData,
  validateData,
  transformData,
  saveData
].reduce((composed, fn) => value => fn(composed(value)), x => x);

pipeline(data); // Data flows through all functions
```

### 3. **Composition**
```javascript
function compose(...fns) {
  return function(initialValue) {
    return fns.reduceRight((value, fn) => fn(value), initialValue);
  };
}

const formatMessage = compose(
  addSignature,
  capitalize,
  addPrefix('Hello: ')
);

formatMessage('world'); // "Hello: WORLD - Best regards"
```

### 4. **Abstraction of Patterns**
```javascript
// Abstract common async patterns
function withRetry(fn, maxRetries = 3) {
  return async function(...args) {
    let lastError;

    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn(...args);
      } catch (error) {
        lastError = error;
        await delay(1000 * (i + 1)); // Exponential backoff
      }
    }

    throw lastError;
  };
}

const reliableApiCall = withRetry(apiCall);
```

## When to Use Higher-Order Functions

### ✅ Good Use Cases
- When you need to abstract repeated logic
- When creating utilities that can be composed
- When you want to separate concerns (validation, logging, etc.)
- When working with asynchronous code
- When creating functional pipelines

### ❌ Avoid When
- The logic is too simple and would add complexity
- Performance is critical and function calls are expensive
- The abstraction makes code harder to understand
- You need mutable state that HOFs might complicate

## Interview Tips

### Common Questions:
1. **What's the difference between `.map()` and `.forEach()`?**
   - `.map()` returns a new array, `.forEach()` returns `undefined`

2. **Can you create a custom HOF?**
   - Show examples like memoization, currying, validation wrappers

3. **Why are HOFs important in functional programming?**
   - They enable composition, immutability, and declarative code

4. **How do HOFs relate to callbacks?**
   - Callbacks are often used as arguments to HOFs

Higher-order functions are powerful tools that enable functional programming paradigms in JavaScript, making code more modular, reusable, and easier to test.
