# What is a Prototype chain?

In JavaScript, the prototype chain is a mechanism that allows objects to inherit properties and methods from other objects. Every object in JavaScript has an internal link (called `[[Prototype]]`) to another object, which itself may have a link to another object, and so on. This creates a "chain" of objects that JavaScript traverses when looking up properties or methods.

## How It Works

### **Prototype Property**
Every function (including constructor functions) has a `prototype` property that points to a prototype object. When you create an instance using `new`, that instance's internal `[[Prototype]]` points to the constructor's prototype.

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

const alice = new Person('Alice');
console.log(alice.greet()); // 'Hello, I'm Alice'
```

### **Chain Lookup**
When you access a property on an object, JavaScript:
1. First checks the object itself
2. If not found, follows the `[[Prototype]]` link to check the prototype
3. Continues up the chain until it finds the property or reaches `null`

```javascript
const alice = new Person('Alice');

// Checking the chain:
alice.hasOwnProperty('name'); // true (from alice object)
alice.greet(); // 'Hello, I'm Alice' (from Person.prototype)
alice.toString(); // '[object Object]' (from Object.prototype)
alice.constructor; // Person (from Person.prototype)
```

### **Visualizing the Chain**
```
alice (instance)
  ↓ [[Prototype]]
Person.prototype
  ↓ [[Prototype]]
Object.prototype
  ↓ [[Prototype]]
null
```

## Prototype Chain Methods

### **`Object.getPrototypeOf(obj)`**
Returns the prototype of an object (modern way, ES5+).

```javascript
Object.getPrototypeOf(alice) === Person.prototype; // true
```

### **`obj.__proto__`**
Older way to access prototype (deprecated, but still used).

```javascript
alice.__proto__ === Person.prototype; // true
```

### **`obj.hasOwnProperty(prop)`**
Checks if a property belongs directly to the object (not inherited).

```javascript
alice.hasOwnProperty('name'); // true
alice.hasOwnProperty('greet'); // false (inherited from prototype)
```

### **`obj.isPrototypeOf(chain)`**
Returns true if the object exists in the chain.

```javascript
Person.prototype.isPrototypeOf(alice); // true
Object.prototype.isPrototypeOf(alice); // true
```

## Setting Prototypes

### **Object.setPrototypeOf(obj, proto)**
Sets the prototype of an object.

```javascript
const animal = { type: 'animal' };
const cat = { name: 'Whiskers' };

Object.setPrototypeOf(cat, animal);
console.log(cat.type); // 'animal'
```

### **Object.create(proto)**
Creates a new object with the specified prototype.

```javascript
const animal = { type: 'animal', describe: function() { return this.type; } };
const dog = Object.create(animal);
dog.name = 'Buddy';

console.log(dog.describe()); // 'animal'
console.log(dog.name); // 'Buddy'
```

## Prototype Chain in ES6 Classes

ES6 classes use prototypes under the hood:

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hello, I'm ${this.name}`;
  }
}

// Equivalent to:
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};
```

## Shadowing
If a property exists at multiple levels in the chain, the one closest to the object is used:

```javascript
const proto = { value: 10 };
const obj = Object.create(proto);
obj.value = 20;

console.log(obj.value); // 20 (own property shadows prototype property)
delete obj.value;
console.log(obj.value); // 10 (now uses prototype property)
```

## Performance Considerations
- Long prototype chains can have performance implications
- Use breakpoints wisely; very deep chains (10+ levels) may cause lookup slowdowns
- Direct property access is faster than prototype lookup

## Common Pitfalls

### **Constructor Confusion**
```javascript
function Animal(name) {
  this.name = name;
}

const animal1 = new Animal('Dog');
const animal2 = Animal('Cat'); // Without new, global object gets name: 'Cat'
```

### **Prototype Pollution**
Modifying shared prototypes can affect all instances:

```javascript
Array.prototype.customMethod = function() { /* ... */ }; // Adds to all arrays

[1,2,3].customMethod(); // Works
// Better: Use subclass or composition
```

## Inheritance Patterns

### **Constructor Inheritance**
```javascript
function Animal(name) {
  this.name = name;
}

function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // Fix constructor
```

### **Class Inheritance**
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name);
    this.breed = breed;
  }
}
```

Understanding the prototype chain is crucial for JavaScript inheritance, method delegation, and efficient object-oriented programming.
