# Explain Call by value vs call by reference

In programming, when we pass arguments to functions, there are two main ways the language can handle the passing of data: **call by value** and **call by reference**. Understanding this difference is crucial for understanding how languages like JavaScript, C++, etc. work.

## Call by Value

**Call by value** means that when you pass a variable to a function, a copy of the **actual value** is made and passed to the function. The function operates on this copy, so any changes made to the parameter inside the function do **not affect** the original variable outside the function.

### How it works:
1. A copy of the variable's value is created
2. The copy is passed to the function
3. Function modifies the copy, not the original
4. Original value remains unchanged

### Example in JavaScript (with primitives):
```javascript
// Primitives like numbers, strings, booleans are passed by value
function changeValue(x) {
  x = 20;  // This only changes the local copy
  console.log('Inside function:', x); // 20
}

let value = 10;
console.log('Before:', value); // 10
changeValue(value);
console.log('After:', value); // 10 (unchanged)
```

### Visual representation:
```
Original variable: value = 10

Function call: changeValue(value)
  ↓
 Creates copy: x = 10

 Inside function: x = 20 (copy changed)
  ↓
 Returns, copy discarded

Original variable: value = 10 (unchanged)
```

## Call by Reference

**Call by reference** means that when you pass a variable to a function, a reference (memory address) to the **actual variable** is passed, not a copy. This means the function operates on the original variable, so changes made inside the function **do affect** the original variable outside.

### How it works:
1. Reference (memory address) to the variable is passed
2. Function modifies the original variable directly
3. Original value is changed

### Example in JavaScript (with objects):
```javascript
// Objects are passed by reference
function changeObject(obj) {
  obj.name = 'Modified'; // Changes the original object
  console.log('Inside function:', obj.name); // 'Modified'
}

let person = { name: 'Original' };
console.log('Before:', person.name); // 'Original'
changeObject(person);
console.log('After:', person.name); // 'Modified' (changed!)
```

### Visual representation:
```
Original object: person → { name: 'Original' } (memory address: 0x123)
                              ↓
Function call: changeObject(person)
  Reference passed: obj → 0x123 (same memory)

Inside function: obj.name = 'Modified' (changes original)
                              ↓
Original object: person → { name: 'Modified' } (still 0x123)
```

## Key Differences Table

| Aspect | Call by Value | Call by Reference |
|--------|---------------|-------------------|
| **What is passed** | Copy of the value | Reference to the variable |
| **Memory used** | More memory (creates copy) | Less memory (shares reference) |
| **Side effects** | No side effects | Can cause side effects |
| **Performance** | Slower for large data | Faster for large data |
| **Modification** | Original variable unchanged | Original variable modified |
| **JavaScript primitives** | Yes (numbers, strings, booleans) | No |
| **JavaScript objects** | No | Yes (objects, arrays, functions) |

## JavaScript Specific Behavior

JavaScript uses **call by value** for primitives and **call by sharing** (a special case of call by reference) for objects.

### Call by Sharing (JavaScript Objects)
- Reference to the object is passed by value
- Function can modify the object's properties
- Cannot reassign the entire object reference

```javascript
function modifyArray(arr) {
  arr.push(4);        // ✅ Modifies original array
  console.log(arr);   // [1, 2, 3, 4]

  arr = [10, 20, 30]; // ❌ Reassigns local reference only
  console.log(arr);   // [10, 20, 30]
}

let myArray = [1, 2, 3];
modifyArray(myArray);
console.log(myArray);  // [1, 2, 3, 4] (only push operation worked)
```

## Real-world Implications

### Advantages of Call by Value:
- **Predictable**: Functions can't accidentally modify your data
- **Pure functions**: Easier to test and reason about
- **Thread safety**: No shared state issues

### Advantages of Call by Reference:
- **Efficient**: No need to copy large objects
- **Memory friendly**: Better for performance
- **Allows mutation**: Can modify complex data structures in-place

### When to Use Each:
- **Use call by value** for immutability and predictability
- **Use call by reference** for performance with large objects
- **In JavaScript: Pass primitives by value, modify objects carefully**

## Common Interview Questions

### Q: What will this output?
```javascript
function swap(a, b) {
  let temp = a;
  a = b;
  b = temp;
}

let x = 10, y = 20;
swap(x, y);
console.log(x, y); // Output: _________ (call by value)
```

**Answer**: `10 20` (original values unchanged)

### Q: Can you explain this behavior?
```javascript
let obj1 = { value: 1 };
let obj2 = obj1;

obj2.value = 2;
console.log(obj1.value); // Output: _________
```

**Answer**: `2` (both variables reference the same object)

## Best Practices in JavaScript

### For Primitives:
```javascript
function updateScore(currentScore, points) {
  // Returns new value, doesn't mutate
  return currentScore + points;
}

let score = 100;
score = updateScore(score, 50); // Reassign result
```

### For Objects (Immutability):
```javascript
// Bad: Mutates original object
function changeName(person, newName) {
  person.name = newName;
}

// Good: Returns new object (immutable)
function changeName(person, newName) {
  return { ...person, name: newName };
}
```

### For Arrays (Immutability):
```javascript
// Instead of arr.push(item):
const newArray = [...arr, item];

// Instead of arr.splice(index, 1):
const newArray = arr.filter((_, i) => i !== index);
```

Understanding call by value vs call by reference helps you write more predictable, efficient, and maintainable JavaScript code.
