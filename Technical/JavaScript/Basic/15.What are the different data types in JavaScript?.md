# What are the different data types in JavaScript?

## Overview
JavaScript has a flexible type system with primitive data types and objects. Understanding data types is fundamental for writing correct JavaScript code, as variables can change types dynamically and operations behave differently based on the data type of values.

## Classification of Data Types

In JavaScript, data types are broadly categorized into two main groups:

### 1. Primitive Data Types
- **Immutable** - Cannot be changed (modifying a primitive creates a new value)
- **Stored by value** - Variables contain actual values
- **Fixed number** of types

### 2. Complex Data Types (Reference Types)
- **Mutable** - Can be modified
- **Stored by reference** - Variables contain pointers to memory locations
- **Objects, arrays, functions** fall into this category

## Primitive Data Types

### 1. undefined
Represents an uninitialized or missing value.

```javascript
let uninitialized;
console.log(uninitialized); // undefined

function greet(name) {
  if (name === undefined) {
    console.log('Name not provided');
  }
}

greet(); // 'Name not provided'
```

**Key Characteristics:**
- Automatic assignment for uninitialized variables
- Result of accessing non-existent properties
- Return value of functions with no return statement

### 2. null
Represents intentional absence of value.

```javascript
const emptyValue = null;
const result = document.getElementById('nonexistent');
console.log(result); // null (element doesn't exist)
```

**Key Characteristics:**
- Must be explicitly assigned
- Considered an object type in typeof (historical quirk)
- Used to represent "empty" or "not found" values

### 3. boolean
Represents true/false values used for logic.

```javascript
const isLoggedIn = true;
const hasPermission = false;

function canAccess(user) {
  return user.isLoggedIn && user.hasPermission;
}

console.log(canAccess({ isLoggedIn: true, hasPermission: false })); // false
```

**Truthy/Falsy Values:**
- **Truthy**: true, non-empty strings, numbers except 0, objects, arrays, functions
- **Falsy**: false, 0, -0, "", '', null, undefined, NaN

```javascript
if ("hello") console.log("truthy"); // executes
if (0) console.log("never executes"); // falsy
if ([]) console.log("truthy"); // empty array is truthy
```

### 4. number
Represents both integer and floating-point numbers.

```javascript
const integer = 42;
const float = 3.14;
const negative = -10;
const exponential = 1.23e5; // 123000

// Special numeric values
const infinity = Infinity;
const negativeInfinity = -Infinity;
const notANumber = NaN;
```

**Key Characteristics:**
- All numbers are 64-bit floating point (IEEE 754)
- No separate integer type
- Special values: NaN, Infinity, -Infinity

```javascript
console.log(typeof 42); // "number"
console.log(typeof 3.14); // "number"
console.log(1/0); // Infinity
console.log("hello" / 2); // NaN

// Number checking
console.log(isNaN(NaN)); // true
console.log(isFinite(42)); // true
console.log(isFinite(Infinity)); // false
```

### 5. string
Represents text characters.

```javascript
const singleQuoted = 'Hello, World!';
const doubleQuoted = "Hello, World!";
const templateLiteral = `Hello, ${name}!`;

const multiline = `This is a
multiline string
with line breaks.`;

const escaping = "He said \"Hello\"";
```

**Key Characteristics:**
- Immutable (operations create new strings)
- Unicode character set
- Zero-based indexing

```javascript
const text = "Hello";
console.log(text.length); // 5
console.log(text[0]); // "H"
console.log(text.charAt(1)); // "e"
console.log(text.slice(1, 4)); // "ell"
console.log(text.toUpperCase()); // "HELLO"
```

### 6. symbol (ES6)
Unique identifiers that are guaranteed to be unique.

```javascript
const id1 = Symbol('id');
const id2 = Symbol('id');

console.log(id1 === id2); // false - symbols with same description are different

// Global symbol registry
const globalSymbol = Symbol.for('globalId');
const sameSymbol = Symbol.for('globalId');

console.log(globalSymbol === sameSymbol); // true
```

**Key Characteristics:**
- Always unique (even with same description)
- Used as property keys for objects
- Purpose: Prevent property name collisions

```javascript
const user = {
  [Symbol('id')]: 123,  // Symbol property
  name: "John"          // Regular property
};

// Symbol properties are not enumerable in for...in
for (let key in user) {
  console.log(key); // "name" only
}

// To access symbol properties
const idSymbol = Object.getOwnPropertySymbols(user)[0];
console.log(user[idSymbol]); // 123
```

### 7. bigint (ES11)
Represents arbitrary-precision integers.

```javascript
const largeNumber = 123456789012345678901234567890n;
const anotherBigInt = BigInt(123456789);

console.log(typeof largeNumber); // "bigint"

// Operations
const sum = 1n + 2n; // 3n
const multiplied = 3n * 4n; // 12n

// Cannot mix with regular numbers
// 1n + 2; // TypeError
```

**Key Characteristics:**
- Can represent integers beyond Number.MAX_SAFE_INTEGER
- Cannot be mixed directly with regular numbers
- Useful for working with large integer values

## Complex Data Types

### Object
The fundamental collection of properties and methods.

```javascript
const user = {
  name: "John Doe",
  age: 30,
  email: "john@example.com",
  greet: function() {
    console.log(`Hello, I'm ${this.name}`);
  }
};

console.log(user.name); // "John Doe"
user.greet(); // "Hello, I'm John Doe"
```

### Array
Ordered collection of values (objects internally).

```javascript
const numbers = [1, 2, 3, 4, 5];
const mixed = [1, "hello", true, null, {name: "John"}];

console.log(numbers.length); // 5
console.log(numbers[0]); // 1
numbers.push(6); // Add element
numbers.pop(); // Remove element
```

### Function
Callable objects that execute code.

```javascript
function namedFunction(name) {
  return `Hello, ${name}!`;
}

const arrowFunction = (name) => {
  return `Hi, ${name}!`;
};

const anonymousFunction = function(name) {
  return `Hey, ${name}!`;
};

// All functions are objects
console.log(typeof namedFunction); // "function"
namedFunction.description = "A greeting function";
```

## Type Checking

### typeof Operator
Returns a string representing the data type.

```javascript
console.log(typeof undefined); // "undefined"
console.log(typeof null); // "object" (historical quirk)
console.log(typeof false); // "boolean"
console.log(typeof 42); // "number"
console.log(typeof "hello"); // "string"
console.log(typeof Symbol()); // "symbol"
console.log(typeof 42n); // "bigint"
console.log(typeof {}); // "object"
console.log(typeof []); // "object"
console.log(typeof function() {}); // "function"
```

### instanceof Operator
Checks if an object has a constructor in its prototype chain.

```javascript
const arr = [1, 2, 3];
const date = new Date();

console.log(arr instanceof Array); // true
console.log(date instanceof Date); // true
console.log(arr instanceof Object); // true (all objects inherit from Object)

console.log([] instanceof Array); // true
console.log({} instanceof Array); // false
```

### Object.prototype.toString.call()
Most reliable way to check types.

```javascript
function getType(value) {
  return Object.prototype.toString.call(value);
}

console.log(getType([])); // "[object Array]"
console.log(getType({})); // "[object Object]"
console.log(getType(null)); // "[object Null]"
console.log(getType(undefined)); // "[object Undefined]"
console.log(getType(42)); // "[object Number]"
console.log(getType("hello")); // "[object String]"
```

## Type Conversion (Coercion)

### Implicit Type Conversion
JavaScript automatically converts types in certain operations.

```javascript
// String conversion
console.log("5" + 3); // "53" (number → string)
console.log(5 + "3"); // "53" (same result)

// Number conversion
console.log("5" - 3); // 2 (string → number)
console.log("5" * 3); // 15 (string → number)
console.log(5 - "3"); // 2
console.log(null + 5); // 5 (null → 0)
console.log(undefined + 5); // NaN (undefined → NaN)

// Boolean conversion
console.log(!!0); // false
console.log(!!""); // false
console.log(!!null); // false
console.log(!!undefined); // false
console.log(!!NaN); // false
console.log(!![]); // true (array is truthy)
console.log(!!{}); // true
```

### Explicit Type Conversion

```javascript
// To String
const num = 42;
console.log(String(num)); // "42"
console.log(num.toString()); // "42"
console.log(num + ""); // "42"

// To Number
const str = "42";
console.log(Number(str)); // 42
console.log(parseInt(str)); // 42
console.log(parseFloat("3.14")); // 3.14
console.log(+"42"); // 42 (unary plus)

// To Boolean
console.log(Boolean(0)); // false
console.log(Boolean("hello")); // true
console.log(!!0); // false (double negation)
console.log(!!"hello"); // true
```

## Primitives vs Objects

### Primitives
- Passed by value
- Immutable (operations create new values)
- Cannot have properties modified

```javascript
let primitive = "hello";
primitive.toUpperCase(); // "HELLO"

console.log(primitive); // "hello" (original unchanged)
console.log(typeof primitive); // "string"

// Attempting to add properties (silently fails)
primitive.customProperty = "value";
console.log(primitive.customProperty); // undefined
```

### Objects (Reference Types)
- Passed by reference
- Mutable (can be modified directly)
- Can have properties added/removed

```javascript
const obj = { name: "John" };
obj.name = "Jane"; // Direct modification

console.log(obj.name); // "Jane"

// Passing reference (shallow copy)
const copy = obj;
copy.age = 30;

console.log(typeof copy); // "object"
console.log(obj.age); // 30 (both point to same object)
```

## Data Type Methods and Properties

### Number Methods
```javascript
const num = 123.45;

// Basic methods
console.log(num.toFixed(2)); // "123.45"
console.log(num.toPrecision(4)); // "123.5"

// Static properties
console.log(Number.MAX_VALUE); // Largest positive number
console.log(Number.MIN_VALUE); // Smallest positive number
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```

### String Methods
```javascript
const text = "Hello, World!";

// Case conversion
console.log(text.toLowerCase()); // "hello, world!"
console.log(text.toUpperCase()); // "HELLO, WORLD!"

// Searching
console.log(text.indexOf("World")); // 7
console.log(text.includes("World")); // true

// Replacing
console.log(text.replace("World", "Universe")); // "Hello, Universe!"
console.log(text.slice(7, 12)); // "World"
```

### Array Methods
```javascript
const fruits = ["apple", "banana", "orange"];

// Adding/removing
fruits.push("grape"); // ["apple", "banana", "orange", "grape"]
fruits.pop(); // "grape"
fruits.unshift("kiwi"); // ["kiwi", "apple", "banana", "orange"]
fruits.shift(); // "kiwi"

// Searching
console.log(fruits.indexOf("banana")); // 2 (after removing kiwi)
console.log(fruits.includes("orange")); // true

// Transforming
const upperFruits = fruits.map(fruit => fruit.toUpperCase());
console.log(upperFruits); // ["APPLE", "BANANA", "ORANGE"]

// Filtering
const longNames = fruits.filter(fruit => fruit.length > 5);
console.log(longNames); // ["banana", "orange"]
```

## Special Data Type Cases

### Date Objects
```javascript
const now = new Date();
console.log(typeof now); // "object"
console.log(now instanceof Date); // true

console.log(now.getTime()); // Timestamp in milliseconds
console.log(now.toISOString()); // "2023-11-23T16:06:26.000Z"
```

### Regular Expressions
```javascript
const regex = /hello/i;
console.log(typeof regex); // "object"
console.log(regex instanceof RegExp); // true

const text = "Hello, World!";
console.log(regex.test(text)); // true
console.log(text.match(regex)); // ["Hello"]
```

### Map and Set (ES6)
```javascript
// Map: Key-value pairs (keys can be any type)
const map = new Map();
map.set('name', 'John');
map.set(1, 'number key');
map.set({id: 1}, 'object key');

console.log(typeof map); // "object"
console.log(map instanceof Map); // true

// Set: Unique values
const set = new Set([1, 2, 3, 1, 2]);
console.log([...set]); // [1, 2, 3]
```

## ES6+ Data Types

### Typed Arrays (for binary data)
```javascript
const buffer = new ArrayBuffer(8); // 8 bytes
const int32View = new Int32Array(buffer);

int32View[0] = 42;
console.log(int32View[0]); // 42

// Different array types for different data
const uint8Array = new Uint8Array(4);
const float64Array = new Float64Array(2);
```

### WeakMap and WeakSet
```javascript
// Keys are weakly referenced (garbage collectable)
const weakMap = new WeakMap();
const weakSet = new WeakSet();

let keyObj = { id: 1 };
weakMap.set(keyObj, 'value');

keyObj = null; // Can be garbage collected now
```

## Type Safety and Best Practices

### 1. Use Strict Type Checking
```javascript
// Good: Strict equality
if (value === null) { // Checks type and value
  // null specific logic
}

if (value === undefined) {
  // undefined specific logic
}

// Bad: Loose equality
if (value == null) { // Catches both null and undefined
  // May mask type-related bugs
}
```

### 2. Validate Input Types
```javascript
function processUser(user) {
  if (typeof user !== 'object' || user === null) {
    throw new Error('User must be an object');
  }

  if (typeof user.name !== 'string') {
    throw new Error('User name must be a string');
  }

  if (typeof user.age !== 'number') {
    throw new Error('User age must be a number');
  }

  // Process user...
}
```

### 3. Use Type Checking Utilities
```javascript
// Custom type guards
function isString(value) {
  return typeof value === 'string';
}

function isNumber(value) {
  return typeof value === 'number' && isFinite(value);
}

function isArray(value) {
  return Array.isArray(value); // Better than instanceof
}

function isDate(value) {
  return value instanceof Date && !isNaN(value.getTime());
}

// Usage
if (isString(input) && isNumber(count)) {
  // Type-safe operations
}
```

### 4. Handle Type Conversion Explicitly
```javascript
// Good: Explicit conversion
function calculateTotal(price, tax) {
  const numPrice = Number(price) || 0;
  const numTax = Number(tax) || 0;

  return numPrice * (1 + numTax);
}

// Bad: Relying on implicit coercion
function calculateBad(price, tax) {
  return price * (1 + tax); // May give NaN if strings not converted
}
```

## Common Type-Related Bugs

### 1. Comparing Numbers and Strings
```javascript
console.log(5 == "5");  // true (loose equality)
console.log(5 === "5"); // false (strict equality)

// Good practice: Convert explicitly
const numFromString = Number("42"); // 42
const stringFromNum = String(42); // "42"
```

### 2. Null vs Undefined Confusion
```javascript
if (value === null || value === undefined) {
  // Checking both explicitly
}

// Or use loose equality (only for this specific case)
if (value == null) {
  // Catches both null and undefined
}
```

### 3. Array vs Object Confusion
```javascript
const arr = [1, 2, 3];
const obj = {0: 1, 1: 2, 2: 3};

console.log(typeof arr); // "object"
console.log(typeof obj); // "object"

console.log(Array.isArray(arr)); // true
console.log(Array.isArray(obj)); // false

// Don't use typeof for arrays - use Array.isArray()
if (Array.isArray(someArray)) {
  // Handle array
}
```

## Key Takeaway
JavaScript has 7 primitive data types (undefined, null, boolean, number, string, symbol, bigint) and reference types (objects including arrays and functions). Understanding the characteristics of each type, their type coercion behavior, and available methods is crucial for writing reliable JavaScript code. Primitives are immutable and passed by value, while objects are mutable and passed by reference. Use explicit type checking, validation, and be cautious with implicit type conversion to avoid common programming errors.
