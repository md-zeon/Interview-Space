# Explain hoisting in JavaScript

## Overview
Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their containing scope during compilation, before the code actually executes. This allows you to use functions and variables before they are declared in your code.

## How Hoisting Works

### The Compilation Phase
JavaScript code execution happens in two phases:

1. **Creation/Compilation Phase**: Hoisting occurs here
   - Variable declarations are registered with `undefined`
   - Function declarations are fully created and available
   - Function expressions are not hoisted

2. **Execution Phase**: Code runs as written

## Variable Hoisting

### var Hoisting
Variables declared with `var` are hoisted and initialized with `undefined`:

```javascript
console.log(car); // undefined (hoisted)
var car = "BMW";
console.log(car); // "BMW"
```

Equivalent compiled code:
```javascript
var car; // Declaration hoisted, initialized undefined
console.log(car); // undefined
car = "BMW"; // Assignment executed in place
console.log(car); // "BMW"
```

### let and const Hoisting
Variables declared with `let` and `const` are hoisted but NOT initialized:

```javascript
console.log(car); // ReferenceError: Cannot access 'car' before initialization
let car = "BMW";
console.log(car); // "BMW"
```

They exist in a "Temporal Dead Zone" until their declaration line.

## Function Declaration Hoisting

### Complete Hoisting
Function declarations are fully hoisted (both declaration and body):

```javascript
greet(); // "Hello from function declaration!"

function greet() {
  console.log("Hello from function declaration!");
}
```

Equivalent compiled code:
```javascript
function greet() { // Fully hoisted
  console.log("Hello from function declaration!");
}

greet(); // Executes correctly
```

## Function Expression Hoisting

### Partial Hoisting
Function expressions are only hoisted as variable declarations:

```javascript
greet(); // TypeError: greet is not a function

var greet = function() {
  console.log("Hello from function expression!");
};
```

Equivalent compiled code:
```javascript
var greet; // Variable hoisted with undefined

greet(); // greet is undefined, not a function

greet = function() { // Assignment executed in place
  console.log("Hello from function expression!");
};
```

## Complex Hoisting Examples

### Multiple Declarations
```javascript
var a = 1;
function f() {
  console.log(a); // undefined - function scope hoisted
  var a = 2;      // Local a shadows global
  console.log(a); // 2
}
f();
console.log(a); // 1
```

### Function and Variable Name Conflict
```javascript
var demo = "variable";

function demo() {
  return "function";
}

console.log(demo); // "variable" - variable overwrites function
```

### Hoisting with Block Scopes
```javascript
function example() {
  if (true) {
    console.log(type); // undefined
    var type = "var is function-scoped";
    console.log(type); // "var is function-scoped"
  }

  if (true) {
    console.log(model); // ReferenceError
    let model = "let is block-scoped";
    console.log(model); // "let is block-scoped"
  }
}

example();
```

## Hoisting Order

JavaScript follows this prioritization when hoisting:

1. **Function declarations first** (highest priority)
2. **Variable declarations** (`var`, `let`, `const`) after functions
3. **Function declarations > var declarations**
4. **var declarations > let/const declarations** (same name)

### Example with Conflicts
```javascript
var message = "global";

function message() {
  return "function";
}

console.log(typeof message); // "string" - variable overwrites function
```

## Advantages of Hoisting

### Function Declarations in Event Handlers
```javascript
// You can place event handler functions after their events
document.addEventListener('click', handleClick);

function handleClick(event) {
  console.log('Button clicked:', event);
}
```

### Module Pattern
```javascript
var Module = (function() {
  var privateVar = "secret";

  // Public interface returned first
  return {
    getSecret: function() { return privateVar; },
    setSecret: function(value) { privateVar = value; }
  };
})();
```

## Pitfalls and Best Practices

### 1. Avoid var Hoisting Surprises
```javascript
// Problematic code
if (condition) {
  var value = "inside if";
}
console.log(value); // "inside if" - leaked due to hoisting

// Better with let/const
if (condition) {
  const value = "inside if"; // Block scoped
}
// value is not accessible here
```

### 2. Arrow Functions vs Function Declarations
```javascript
// Arrow functions are function expressions
const arrowFunc = () => console.log("arrow");
// arrowFunc is not hoisted - must be called after declaration

// Function declarations are hoisted
function namedFunc() {
  console.log("named");
}
// namedFunc can be called anywhere in scope
```

### 3. Strict Mode Considerations
```javascript
"use strict";

console.log(value); // ReferenceError in strict mode
var value = "test"; // Still hoisted, but undefined is an error
```

## ES6 Class Hoisting

### Classes are not Hoisted
Class declarations are NOT hoisted:

```javascript
const person = new Person(); // ReferenceError: Cannot access 'Person' before initialization

class Person {
  constructor(name) {
    this.name = name;
  }
}
```

Class expressions are also not hoisted:
```javascript
const Animal = class { ... }; // Not hoisted
```

## Hoisting in Different Scopes

### Global Scope Hoisting
```javascript
// Global scope
console.log(globalVar); // undefined
var globalVar = "global";

greeting(); // "Hello!"
function greeting() {
  console.log("Hello!");
}
```

### Function Scope Hoisting
```javascript
function outer() {
  console.log(localVar); // undefined - hoisted to function scope
  var localVar = "local";

  console.log(outerVar); // undefined - function scoped
  var outerVar = "outer";

  if (true) {
    var blockVar = "block"; // Hoisted to function scope
  }

  console.log(blockVar); // "block"
}

outer();
```

### Block Scope (let/const)
```javascript
{
  console.log(blockVar); // ReferenceError
  let blockVar = "block scoped";
}
```

## Real-World Implications

### 1. Debugging Issues
Hoisting can cause unexpected behavior:

```javascript
// Difficult to debug
function processData(data) {
  // Large function with declarations at top
  for (var i = 0; i < data.length; i++) {
    // ...
  }
  // Many lines later...
  var processed = [];
  for (var i = 0; i < data.length; i++) { // i is reused!
    // ...
  }
}

// Better: Declare at use site
function processData(data) {
  for (let i = 0; i < data.length; i++) {
    // First loop
  }

  const processed = [];
  for (let i = 0; i < data.length; i++) { // New binding
    // Second loop
  }
}
```

### 2. IIFE Pattern
Immediately Invoked Function Expressions use hoisting for encapsulation:

```javascript
(function() {
  // Private scope
  var counter = 0;

  window.incrementCounter = function() {
    // Hoisted function can access counter
    return counter++;
  };

  // counter is private, only incrementCounter hoisted to global
})();
```

### 3. Module Systems
Modern module systems avoid global hoisting issues:

```javascript
// CommonJS
var fs = require('fs'); // Synchronous dependency resolution

// ES6 Modules
import { readFile } from 'fs'; // Declaration before use
```

## Performance Considerations

### Hoisting Cost
- Function declarations take more memory than function expressions
- Over-hoisting can slow compilation
- Prefer let/const for predictable behavior

```javascript
// Heavy hoisting impact
function LargeModule() {
  // 100 function declarations
  function fn1() { ... }
  function fn2() { ... }
  // ...
  function fn100() { ... }

  // Module exports
}

// Build tool may hoist many functions
const largeModule = new LargeModule();
```

## Best Practices

### 1. Declare Before Use
```javascript
// Good practice - declare at top
let message, total;

function calculate() {
  total = 0;
  // Later use
}

calculate();
```

### 2. Use let/const by Default
```javascript
// Prefer let/const for block scoping
if (user) {
  let sessionId = generateId(); // Limited scope
} else {
  const sessionId = "anonymous"; // Refuse reassignment
}
```

### 3. Organize Code Logically
```javascript
// Structure code to reduce hoisting dependencies
// 1. Imports/Dependencies
import { util1, util2 } from './utils';

// 2. Types/Constants
const API_URL = 'https://api.example.com';

// 3. Helper Functions
function formatData(data) { ... }

// 4. Main Functions
function main() {
  const data = fetchData();
  const formatted = formatData(data);
  return formatted;
}

// 5. Execution
main();
```

### 4. Avoid Hoisting Reliance
```javascript
// Don't rely on hoisting - declare dependencies explicitly
function Component() {
  const state = useState(); // Must import useState

  return JSX; // Must import React
}

// Instead of expecting global hoisting
// useState(); // Might work if globally available, but unclear
```

## Key Takeaway
Hoisting moves variable and function declarations to the top of their scope during compilation. Function declarations are fully hoisted, `var` is hoisted with `undefined`, while `let`/`const` are hoisted but cause errors if accessed before initialization. Understanding hoisting helps write cleaner, more predictable JavaScript code, especially when migrating from `var` to `let`/`const` for better scoping behavior.
