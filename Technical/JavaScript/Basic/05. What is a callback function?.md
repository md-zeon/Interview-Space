# What is a callback function?

## Overview
A callback function is a function that is passed as an argument to another function and is executed after some operation has been completed. Callbacks are fundamental to JavaScript's asynchronous programming model.

## Basic Definition

### What is a Callback?
- A function passed as an argument to another function
- Executed after the main function finishes its work
- Allows for asynchronous operations

### Simple Example
```javascript
function greet(name) {
  console.log('Hello ' + name);
}

function processUserInput(callback) {
  const name = 'John';
  callback(name); // greet is the callback function
}

processUserInput(greet); // Output: Hello John
```

## Synchronous Callbacks

### Definition
Executed immediately before the main function returns.

### Examples

### Array Methods
```javascript
const numbers = [1, 2, 3, 4, 5];

// forEach
numbers.forEach(function(number) {
  console.log(number * 2);
});

// map
const doubled = numbers.map(function(number) {
  return number * 2;
});

// filter
const evenNumbers = numbers.filter(function(number) {
  return number % 2 === 0;
});
```

### Custom Implementation
```javascript
function calculate(a, b, operation) {
  return operation(a, b);
}

function add(a, b) {
  return a + b;
}

function multiply(a, b) {
  return a * b;
}

console.log(calculate(5, 3, add));      // 8
console.log(calculate(5, 3, multiply)); // 15
```

## Asynchronous Callbacks

### Definition
Executed after some asynchronous operation completes (like API calls, timers, file operations).

### Browser Examples

### Event Handlers
```javascript
const button = document.getElementById('myButton');

button.addEventListener('click', function() {
  console.log('Button was clicked!');
});
```

### Timers
```javascript
setTimeout(function() {
  console.log('This runs after 3 seconds');
}, 3000);
```

### HTTP Requests (Old way)
```javascript
const xhr = new XMLHttpRequest();

xhr.open('GET', 'https://api.example.com/users');
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
```

## Callback Patterns

### Error-First Callback Pattern
Common in Node.js:

```javascript
function readFile(filePath, callback) {
  // Simulate file reading
  const error = null;
  const data = 'file contents';

  callback(error, data);
}

readFile('example.txt', function(error, data) {
  if (error) {
    console.error('Error:', error);
    return;
  }
  console.log('Data:', data);
});
```

### Success/Error Callbacks
```javascript
function fetchUserData(userId, success, error) {
  // Simulate API call
  setTimeout(() => {
    const user = { id: userId, name: 'John Doe' };
    success(user);
  }, 1000);
}

fetchUserData(123, function(user) {
  console.log('User:', user);
}, function(error) {
  console.error('Error:', error);
});
```

## Callback Hell (Callback Pyramid)

### Problem
Deeply nested callbacks make code hard to read:

```javascript
getData(function(a) {
  getMoreData(a, function(b) {
    getEvenMoreData(b, function(c) {
      getFinalData(c, function(final) {
        console.log(final);
      });
    });
  });
});
```

### Solutions
1. **Named Functions**: Extract to separate functions
2. **Promises**: Chain asynchronous operations
3. **Async/Await**: Write async code synchronously

## Modern JavaScript Alternatives

### Promises
```javascript
function fetchUser(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ id: userId, name: 'John' });
    }, 1000);
  });
}

fetchUser(123).then(user => {
  console.log(user);
}).catch(error => {
  console.error(error);
});
```

### Async/Await
```javascript
async function getUser(userId) {
  try {
    const user = await fetchUser(userId);
    console.log(user);
  } catch (error) {
    console.error(error);
  }
}
```

## Common Use Cases

### 1. Event Handling
```javascript
window.addEventListener('load', function() {
  console.log('Page fully loaded');
});
```

### 2. Array Operations
```javascript
const userIds = [1, 2, 3, 4, 5];

userIds.forEach(id => {
  processUser(id, function(result) {
    console.log(`Processed user ${id}:`, result);
  });
});
```

### 3. Animations
```javascript
function fadeOut(element, callback) {
  let opacity = 1;
  const timer = setInterval(() => {
    opacity -= 0.1;
    element.style.opacity = opacity;
    if (opacity <= 0) {
      clearInterval(timer);
      callback(); // Animation complete
    }
  }, 50);
}

fadeOut(document.getElementById('myElement'), function() {
  console.log('Fade out complete');
});
```

### 4. Higher-Order Functions
```javascript
function repeat(n, action) {
  for (let i = 0; i < n; i++) {
    action(i);
  }
}

repeat(3, function(i) {
  console.log(`Iteration ${i}`);
});
```

## Callback Context (`this`)

### Problem
Lost context when callbacks are executed asynchronously:

```javascript
const obj = {
  name: 'My Object',
  showName: function() {
    console.log(this.name);
  }
};

setTimeout(obj.showName, 1000); // undefined (lost context)
```

### Solutions

#### Using Arrow Functions
```javascript
setTimeout(() => obj.showName(), 1000); // 'My Object'
```

#### Using .bind()
```javascript
setTimeout(obj.showName.bind(obj), 1000); // 'My Object'
```

#### Using .call()/.apply()
```javascript
const boundCallback = obj.showName.bind(obj);
setTimeout(boundCallback, 1000);
```

## Best Practices

### 1. **Handle Errors Properly**
```javascript
function makeRequest(url, callback) {
  fetch(url)
    .then(response => response.json())
    .then(data => callback(null, data))
    .catch(error => callback(error));
}

makeRequest('https://api.example.com/data', function(error, data) {
  if (error) return console.error('Error:', error);
  console.log('Data:', data);
});
```

### 2. **Avoid Deep Nesting**
Prefer promises or async/await for complex asynchronous flows.

### 3. **Consistent Parameter Order**
Use error-first convention:
```javascript
callback(error, result); // Error first, then result
```

### 4. **Avoid Callback Modification**
Don't modify passed callback functions.

### 5. **Use Descriptive Names**
```javascript
// Good
function handleUserResult(error, user) { ... }

// Avoid
function cb(err, u) { ... }
```

## Common Callback-Related Problems

### 1. **Race Conditions**
```javascript
let counter = 0;

function asyncOperation(callback) {
  setTimeout(() => {
    counter++;
    callback(counter);
  }, Math.random() * 1000);
}

asyncOperation(result => console.log(result));
asyncOperation(result => console.log(result)); // Unpredictable order
```

### 2. **Multiple Callbacks**
```javascript
function brokenFunction(callback) {
  callback('first');
  callback('second'); // Called twice - bad
}
```

### 3. **Missing Callbacks**
```javascript
function maybeAsync(callback) {
  if (Math.random() > 0.5) {
    callback('result');
    // Sometimes never calls callback - bad
  }
}
```

## Key Takeaway
Callbacks are fundamental to JavaScript's event-driven, asynchronous nature. While powerful, they can lead to callback hell in complex scenarios. Modern JavaScript provides Promises and async/await to handle asynchronous operations more elegantly, but callbacks remain important in event handling, array methods, and Node.js-style APIs.
