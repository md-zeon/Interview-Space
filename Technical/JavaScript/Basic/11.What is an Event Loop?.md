# What is an Event Loop?

## Overview
The event loop is a crucial mechanism in JavaScript that enables non-blocking operations and asynchronous programming. It's the core component that allows JavaScript to perform multiple operations simultaneously despite being single-threaded. Understanding the event loop is essential for writing efficient, responsive JavaScript applications.

## JavaScript Runtime Architecture

Before diving into the event loop, let's understand the JavaScript runtime:

### Key Components

1. **JavaScript Engine (V8, SpiderMonkey, etc.)**
   - Executes JavaScript code
   - Contains Call Stack and Heap (memory)

2. **Web APIs (Browser environment)**
   - DOM manipulation
   - AJAX calls
   - Timers (`setTimeout`, `setInterval`)
   - Events

3. **Callback Queue (Macrotask Queue)**
   - Stores callback functions from asynchronous operations
   - Follows FIFO (First In, First Out) principle

4. **Job Queue (Microtask Queue)**
   - Stores Promise callbacks and MutationObservers
   - Higher priority than Callback Queue

5. **Event Loop**
   - Monitors Call Stack and Queues
   - Moves tasks from queues to Call Stack when it's empty

## The Call Stack

### What is the Call Stack?
The call stack is a data structure that keeps track of function calls. It uses LIFO (Last In, First Out) principle.

```javascript
function first() {
  console.log('First function');
}

function second() {
  console.log('Second function');
  first(); // First gets added to stack
}

function third() {
  console.log('Third function');
  second(); // Second gets added to stack
}

third(); // Third gets added to stack

// Output: Third function → Second function → First function
// Stack: [third] → [third, second] → [third, second, first]
//        [third, second] → [third] → []
```

### Stack Overflow
```javascript
// This would cause a stack overflow
function recursion() {
  recursion(); // Endless function calls
}

recursion(); // Maximum call stack size exceeded
```

## Understanding Asynchronous JavaScript

### Synchronous vs Asynchronous

```javascript
// Synchronous - blocks execution
function syncFunction() {
  console.log('Start');
  console.log('Processing...'); // Takes 5 seconds
  console.log('End');
}

// Asynchronous - non-blocking
function asyncFunction() {
  console.log('Start');
  setTimeout(() => console.log('Processing...'), 5000); // Non-blocking
  console.log('End'); // Executes immediately
}

asyncFunction();
// Output: Start → End → Processing... (after 5 seconds)
```

## How the Event Loop Works

### The Main Loop
The event loop continuously monitors:

1. **Call Stack**: Is it empty?
2. **Job Queue**: Any microtasks ready?
3. **Callback Queue**: Any macrotasks ready?

### Algorithm
```
1. Check if Call Stack is empty AND no code is currently executing
2. If yes, process all microtasks in Job Queue
3. Then, process one macrotask from Callback Queue
4. Repeat
```

## Execution Order Examples

### Basic Timer Example

```javascript
console.log('Start');

setTimeout(function() {
  console.log('Async callback');
}, 0);

console.log('End');

// Output:
// Start
// End
// Async callback (minimum 0ms later, but queued)
```

### Timer with Different Delays

```javascript
console.log('Start');

setTimeout(() => console.log('Timeout 1 - 0ms'), 0);
setTimeout(() => console.log('Timeout 2 - 100ms'), 100);

console.log('End');

// Output:
// Start
// End
// Timeout 1 - 0ms (executed immediately after stack is empty)
// Timeout 2 - 100ms (executed after 100ms)
```

### Promises and Event Loop

```javascript
console.log('Start');

const promise = new Promise((resolve) => {
  console.log('Promise created');
  resolve('Promise resolved');
});

promise.then((value) => {
  console.log(value);
});

console.log('End');

// Output:
// Start
// Promise created
// End
// Promise resolved
```

### Complex Example with Timers and Promises

```javascript
console.log('Start');

// Macrotask (setTimeout)
setTimeout(() => console.log('Timeout 1'), 0);

// Microtask (Promise)
Promise.resolve().then(() => console.log('Promise 1'));

// Macrotask (setTimeout)
setTimeout(() => console.log('Timeout 2'), 0);

// Microtask (Promise)
Promise.resolve().then(() => console.log('Promise 2'));

console.log('End');

// Output:
// Start
// End          (synchronous code)
// Promise 1    (first microtask)
// Promise 2    (second microtask)
// Timeout 1    (first macrotask)
// Timeout 2    (second macrotask)
```

## Microtasks vs Macrotasks

### Microtasks (Higher Priority)
- Processed after each macrotask or when call stack is empty
- Always cleared before any macrotask
- Examples:
  - Promise callbacks (`.then()`, `.catch()`, `.finally()`)
  - `process.nextTick()` (Node.js)
  - MutationObserver callbacks
  - `Object.observe()` (deprecated)

### Macrotasks (Lower Priority)
- Processed one at a time
- Include: `setTimeout`, `setInterval`, `setImmediate`, I/O operations, UI rendering

### Execution Order:
1. Call Stack (synchronous code) executes
2. When stack is empty, **ALL** microtasks are processed
3. Then, **ONE** macrotask is processed
4. Repeat steps 2-3

## Event Loop with User Interaction

### Browser Context

```javascript
// HTML: <button id="btn">Click me</button>

console.log('Script start');

// Add event listener (gets registered)
document.getElementById('btn').addEventListener('click', function() {
  console.log('Button clicked');
});

setTimeout(() => console.log('Timeout callback'), 0);

Promise.resolve().then(() => console.log('Promise resolved'));

console.log('Script end');

// Initial output:
// Script start → Script end (synchronous)
// Promise resolved (microtask)
// Timeout callback (macrotask)

// When user clicks:
// Button clicked (becomes macrotask and processed)
```

## Visualizing the Event Loop

### Animation Frame Example

```javascript
function animationFrameHandler() {
  console.log('Animation frame');
  requestAnimationFrame(animationFrameHandler);
}

function eventLoopDemo() {
  console.log('Start');

  // Macrotask
  setTimeout(() => console.log('setTimeout callback'), 0);

  // Microtask
  Promise.resolve().then(() => console.log('Promise callback'));

  // Animation frame callback
  requestAnimationFrame(() => console.log('requestAnimationFrame callback'));

  console.log('End');
}

animationFrameHandler();
eventLoopDemo();

// Output:
// Start
// End
// Promise callback (microtask)
// setTimeout callback (macrotask)
// Animation frame callbacks (prioritized based on browser render cycle)
```

## Real-World Applications

### 1. Fetch API with Async/Await

```javascript
async function fetchData() {

  console.log('Start fetch');

  try {
    const response = await fetch('https://api.example.com/data');
    console.log('Response received');

    const data = await response.json();
    console.log('Data processed:', data);

  } catch (error) {
    console.error('Error:', error);
  }

  console.log('Fetch complete');
}
```

### 2. Processing Arrays with setTimeout (Non-blocking)

```javascript
function processArray(array) {
  for (let i = 0; i < array.length; i++) {
    setTimeout(() => {
      console.log(`Processing item ${i}:`, array[i]);
    }, 0); // Non-blocking due to event loop
  }
}

const numbers = [1, 2, 3, 4, 5];
processArray(numbers);

// Output appears non-linear (depends on timing)
// Processing item 0: 1
// Processing item 1: 2
// Processing item 2: 3
// etc.
```

### 3. Progressive Loading

```javascript
function loadImages(imageUrls) {
  imageUrls.forEach((url, index) => {
    setTimeout(() => {
      const img = new Image();
      img.onload = () => console.log(`Image ${index} loaded`);
      img.src = url; // Loading triggers asynchronous behavior
    }, index * 100); // Stagger loading to avoid blocking
  });
}
```

## Node.js Event Loop vs Browser Event Loop

### Browser Event Loop
- **Tick**: Browser rendering cycle (60fps usually)
- **Renders UI** between event loop ticks
- **Additional Queues**: Animation frames, requestIdleCallback

### Node.js Event Loop
- **Phases**: Timers, I/O callbacks, Idle/Prepare, Poll, Check, Close callbacks
- **No GUI rendering** concerns
- **More I/O focused**: File system, network operations

### Key Differences

```javascript
// Browser - impacts rendering
setTimeout(() => console.log('Browser timeout'), 0);
// UI can render before this executes

// Node.js - different phase timing
setTimeout(() => console.log('Node timeout'), 0);
// May execute faster due to no render cycle
```

## Performance Considerations

### 1. Avoid Blocking the Event Loop

```javascript
// Bad: Blocking code
function calculatePrimes(limit) {
  const primes = [];
  for (let i = 2; i <= limit; i++) {
    // Heavy computation blocks event loop
  }
  return primes;
}

// Better: Break into chunks
function calculatePrimesAsync(limit, callback) {
  const primes = [];
  const chunkSize = 1000;
  let current = 2;

  function processChunk() {
    for (let i = 0; i < chunkSize && current <= limit; i++, current++) {
      // Do small chunk of work
    }

    if (current >= limit) {
      callback(primes);
    } else {
      setTimeout(processChunk, 0); // Allow event loop to continue
    }
  }

  processChunk();
}
```

### 2. Microtask Queue Monitoring

```javascript
// Warning: Deep microtask chains can starve macrotasks
let microtaskCount = 0;

Promise.resolve().then(() => {
  microtaskCount++;
  console.log(`Microtask ${microtaskCount}`).then(() => {
    microtaskCount++;
    console.log(`Microtask ${microtaskCount}`);
    // ... deep nesting
  });
});

// Browser may warn about long-running task
```

### 3. Debouncing for Performance

```javascript
function debounce(func, delay) {
  let timeoutId;

  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

const debouncedScroll = debounce(function() {
  console.log('Scroll event processed');
}, 100);

// Only processes when scrolling stops for 100ms
window.addEventListener('scroll', debouncedScroll);
```

## Debugging Event Loop Issues

### Chrome DevTools

1. **Sources Panel**: Click "Async" checkbox to see async stack traces
2. **Performance Tab**: Record execution to see event loop patterns
3. **Console**: Use `console.time()` and `console.timeEnd()` for timing

### Debugging Async Code

```javascript
function traceAsyncOperation() {
  console.trace('Async operation started');

  setTimeout(() => {
    console.trace('Async operation completed');
  }, 1000);
}
```

### Detecting Blocked Event Loop

```javascript
// Monitor for blocking code
let lastTick = performance.now();

function monitorEventLoop() {
  const currentTime = performance.now();
  const timeDiff = currentTime - lastTick;

  if (timeDiff > 16) { // Longer than one frame at 60fps
    console.warn(`Event loop blocked for ${timeDiff}ms`);
  }

  lastTick = currentTime;
  requestAnimationFrame(monitorEventLoop);
}

monitorEventLoop();
```

## Common Misconceptions

### 1. "JavaScript is always asynchronous"

```javascript
// Wrong: Thinking all JS is async
const result = someAsyncOperation(); // Not always async
console.log(result); // May be undefined

// Correct: Async operations return promises or use callbacks
someAsyncOperation().then(result => console.log(result));
```

### 2. "setTimeout sleeps the thread"

```javascript
// Wrong understanding
setTimeout(() => console.log('Executed'), 1000);
// Thought: Execution stops for 1 second

// Reality: Callback is queued after 1 second, but event loop continues
console.log('This executes immediately');
```

### 3. "Microtasks execute immediately"

```javascript
// Incorrect assumption
Promise.resolve().then(() => console.log('Immediate?'));

// Code continues executing synchronously
console.log('Not that immediate'); // Executes before promise callback

// Output: Not that immediate → Immediate?
```

## Best Practices

### 1. Use Promises and Async/Await Effectively

```javascript
// Good: Proper async/await usage
async function fetchUserData(userId) {
  try {
    const user = await api.getUser(userId);
    const posts = await api.getPosts(user.id);

    return { user, posts };
  } catch (error) {
    console.error('Failed to fetch data:', error);
  }
}
```

### 2. Break Long Operations

```javascript
// Split heavy computations to avoid blocking
function processLargeArray(data) {
  const chunks = [];
  const chunkSize = 1000;

  for (let i = 0; i < data.length; i += chunkSize) {
    chunks.push(data.slice(i, i + chunkSize));
  }

  function processChunk(index) {
    if (index >= chunks.length) return;

    // Process one chunk
    chunks[index].forEach(item => doHeavyCalculation(item));

    // Schedule next chunk
    setTimeout(() => processChunk(index + 1), 0);
  }

  processChunk(0);
}
```

### 3. Monitor Performance

```javascript
// Track event loop latency
let latencies = [];

setInterval(() => {
  const start = performance.now();

  setTimeout(() => {
    const latency = performance.now() - start;
    latencies.push(latency);

    // Keep only recent measurements
    if (latencies.length > 100) latencies = latencies.slice(-100);

    const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
    console.log(`Average event loop latency: ${avgLatency.toFixed(1)}ms`);
  }, 0);
}, 1000);
```

## Key Takeaway
The event loop is the mechanism that allows JavaScript to handle asynchronous operations despite being single-threaded. It continuously checks the call stack and processes microtasks (Promises) before macrotasks (setTimeout), enabling responsive applications. Understanding this core concept is crucial for writing non-blocking JavaScript code that efficiently uses system resources.
