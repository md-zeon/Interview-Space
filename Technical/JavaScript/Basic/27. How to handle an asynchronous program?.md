# How to handle an asynchronous program?

## Overview
Asynchronous programming is fundamental to JavaScript, allowing non-blocking operations that don't freeze the user interface. JavaScript handles async operations through callbacks, promises, and async/await syntax. Understanding these patterns is crucial for writing responsive JavaScript applications that can handle I/O operations, network requests, and user interactions effectively.

## What is Asynchronous Programming?

### Synchronous vs Asynchronous
```javascript
// Synchronous - blocks execution
console.log('Start');
const result = calculateHeavyOperation(); // Takes 5 seconds
console.log('Result:', result);
console.log('End');
// User interface frozen for 5 seconds

// Asynchronous - non-blocking
console.log('Start');
calculateAsyncHeavyOperation(result => {
  console.log('Result:', result);
});
console.log('End'); // Executes immediately
// User interface remains responsive
```

## The Problem with Traditional Approach

### Blocking Operations
```javascript
// File reading (synchronous - bad in Node.js)
const fs = require('fs');
const data = fs.readFileSync('large-file.txt'); // Blocks execution
console.log('File loaded'); // Executes after file is read

// User can't interact with app during file reading
```

### Simulated Server Request
```javascript
// Old synchronous AJAX (doesn't exist anymore)
const response = XMLHttpRequest('GET', '/api/users'); // Would block
processUsers(response.data); // Executes after request completes
```

## Callbacks: The Foundation of Async

### Callback Pattern
```javascript
function doSomething(callback) {
  // Simulate async operation
  setTimeout(() => {
    const result = 'Async operation complete';
    callback(result); // Call the callback with result
  }, 1000);
}

// Using the callback
doSomething(result => {
  console.log(result); // "Async operation complete"
});

console.log('This executes first'); // "This executes first"
```

### Error Handling with Callbacks
```javascript
function fetchData(callback) {
  setTimeout(() => {
    if (Math.random() > 0.5) {
      callback(null, 'Data loaded');
    } else {
      callback(new Error('Network error'), null);
    }
  }, 1000);
}

// Node.js style: Error-first callback
fetchData((error, data) => {
  if (error) {
    console.error('Error:', error.message);
    return;
  }
  
  console.log('Success:', data);
});
```

### Multiple Sequential Callbacks (Callback Hell)
```javascript
getUser(userId, (userError, user) => {
  if (userError) return console.error(userError);
  
  getUserPosts(user.id, (postsError, posts) => {
    if (postsError) return console.error(postsError);
    
    getPostComments(posts[0].id, (commentsError, comments) => {
      if (commentsError) return console.error(commentsError);
      
      // Finally process all data
      displayUserContent(user, posts, comments);
    });
  });
});
```

## Promises: Cleaner Asynchronous Code

### What is a Promise?
```javascript
// Promise represents the eventual completion of an async operation
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    if (Math.random() > 0.5) {
      resolve('Success!'); // Operation succeeded
    } else {
      reject(new Error('Failed!')); // Operation failed
    }
  }, 1000);
});

// Promise states:
// - Pending: Initial state
// - Fulfilled: Operation completed successfully
// - Rejected: Operation failed
console.log(myPromise); // Promise {<pending>}
```

### Promise Methods
```javascript
const promise = fetch('/api/data');

promise
  .then(response => response.json()) // Success handler
  .then(data => console.log(data))    // Chain more operations
  .catch(error => console.error(error)) // Error handler
  .finally(() => console.log('Always executes')); // Cleanup
```

### Promise Chaining
```javascript
function getUser(userId) {
  return fetch(`/api/users/${userId}`).then(response => response.json());
}

function getUserPosts(userId) {
  return fetch(`/api/users/${userId}/posts`).then(response => response.json());
}

// Chain promises instead of nesting callbacks
getUser(1)
  .then(user => {
    console.log('User:', user);
    return getUserPosts(user.id);
  })
  .then(posts => {
    console.log('Posts:', posts);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```

### Multiple Promises
```javascript
// Promise.all - All promises must succeed
Promise.all([
  fetchUser(1),
  fetchUserPosts(1),
  fetchUserComments(1)
])
.then(([user, posts, comments]) => {
  console.log('All data loaded');
  displayUserContent(user, posts, comments);
})
.catch(error => {
  console.error('One or more requests failed');
});

// Promise.race - First promise to complete wins
Promise.race([
  fetch('/api/fast-endpoint'),
  fetch('/api/slow-endpoint'),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), 5000)
  )
])
.then(data => console.log('Fastest response:', data))
.catch(error => console.error('Race failed:', error));

// Promise.any (ES2021) - First fulfilled promise wins
Promise.any([
  fetch('/api/endpoint1'),
  fetch('/api/endpoint2'),
  fetch('/api/endpoint3')
])
.then(data => console.log('First success:', data))
.catch(error => console.error('All promises failed'));
```

### Creating Utility Functions
```javascript
function promisify(callbackFunction) {
  return (...args) => {
    return new Promise((resolve, reject) => {
      callbackFunction(...args, (error, result) => {
        if (error) reject(error);
        else resolve(result);
      });
    });
  };
}

// Convert callback-style function to promise
const fs = require('fs');
const readFilePromise = promisify(fs.readFile);

readFilePromise('file.txt', 'utf8')
  .then(content => console.log(content))
  .catch(error => console.error(error));
```

## Async/Await: Syntactic Sugar for Promises

### Async Functions
```javascript
// Mark function as async - returns a Promise
async function loadUserData(userId) {
  try {
    const user = await fetchUser(userId);
    const posts = await fetchUserPosts(userId);
    const comments = await fetchUserComments(userId);
    
    return { user, posts, comments };
  } catch (error) {
    console.error('Failed to load data:', error);
    throw error; // Re-throw so caller can handle
  }
}
```

### Await Keyword
```javascript
// Can only be used inside async functions
async function processData() {
  console.log('Start processing');
  
  const result1 = await asyncOperation1();
  console.log('Operation 1 complete:', result1);
  
  const result2 = await asyncOperation2(result1);
  console.log('Operation 2 complete:', result2);
  
  return result2;
}

// Usage
processData().then(finalResult => {
  console.log('All operations done:', finalResult);
});
```

### Error Handling with Async/Await
```javascript
async function safeFetch(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    if (error.name === 'TypeError') {
      throw new Error('Network error: Unable to connect');
    }
    
    throw error; // Re-throw other errors
  }
}

// Usage
safeFetch('/api/data')
  .then(data => console.log('Data:', data))
  .catch(error => {
    if (error.message.includes('Network error')) {
      showOfflineMessage();
    } else {
      showErrorMessage(error.message);
    }
  });
```

## Handling Concurrent Operations

### Parallel Execution with async/await
```javascript
async function loadAllUserData(userId) {
  // Start all requests simultaneously
  const [userPromise, postsPromise, commentsPromise] = [
    fetchUser(userId),
    fetchUserPosts(userId),
    fetchUserComments(userId)
  ];
  
  // Wait for all to complete (in parallel, not sequentially)
  try {
    const [user, posts, comments] = await Promise.all([
      userPromise, postsPromise, commentsPromise
    ]);
    
    console.log('All data loaded');
    return { user, posts, comments };
  } catch (error) {
    console.error('Failed to load some data:', error);
    throw error;
  }
}
```

### Sequential vs Parallel Execution
```javascript
// Sequential (slower)
async function sequentialLoad(userId) {
  console.time('Sequential');
  
  const user = await fetchUser(userId);        // Wait 1s
  const posts = await fetchUserPosts(userId);  // Wait 1s after first
  const comments = await fetchUserComments(userId); // Wait 1s after second
  
  console.timeEnd('Sequential'); // ~3 seconds
  return { user, posts, comments };
}

// Parallel (faster)
async function parallelLoad(userId) {
  console.time('Parallel');
  
  const [user, posts, comments] = await Promise.all([
    fetchUser(userId),        // All start at once
    fetchUserPosts(userId),   // 1s total instead of 3s
    fetchUserComments(userId)
  ]);
  
  console.timeEnd('Parallel');
  return { user, posts, comments };
}
```

## Advanced Patterns

### Async Iterators and Generators
```javascript
// Async generator
async function* asyncSequence() {
  yield await asyncOperation1();
  yield await asyncOperation2();
  yield await asyncOperation3();
}

// Usage
for await (const value of asyncSequence()) {
  console.log('Received:', value);
}
```

### Timeout Handling
```javascript
function withTimeout(promise, timeoutMs) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Operation timed out')), timeoutMs);
  });
  
  return Promise.race([promise, timeout]);
}

// Usage
withTimeout(fetch('/api/slow-endpoint'), 5000)
  .then(data => console.log('Success:', data))
  .catch(error => {
    if (error.message === 'Operation timed out') {
      showTimeoutMessage();
    } else {
      console.error('Other error:', error);
    }
  });
```

### Retry Logic
```javascript
async function withRetry(operation, maxRetries = 3) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      console.log(`Attempt ${attempt} failed:`, error.message);
      
      if (attempt < maxRetries) {
        // Exponential backoff
        await new Promise(resolve => 
          setTimeout(resolve, Math.pow(2, attempt) * 1000)
        );
      }
    }
  }
  
  throw lastError;
}

// Usage
withRetry(() => fetch('/api/unreliable-endpoint'))
  .then(data => console.log('Success after retry'))
  .catch(error => console.error('All retries failed'));
```

### Cancellation
```javascript
function cancelableFetch(url) {
  const controller = new AbortController();
  const signal = controller.signal;
  
  const promise = fetch(url, { signal })
    .then(response => response.json())
    .catch(error => {
      if (error.name === 'AbortError') {
        console.log('Request was cancelled');
        throw new Error('Cancelled by user');
      }
      throw error;
    });
  
  // Return both promise and cancel function
  return {
    promise,
    cancel: () => controller.abort()
  };
}

// Usage
const request = cancelableFetch('/api/large-data');
// If user navigates away or cancels
setTimeout(() => request.cancel(), 5000);
```

## Real-World Application Patterns

### API Client with Error Handling
```javascript
class ApiClient {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  
  async request(endpoint, options = {}) {
    const url = this.baseUrl + endpoint;
    
    try {
      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data;
      
    } catch (error) {
      if (error.name === 'TypeError') {
        throw new Error('Network error: Please check your connection');
      }
      
      if (error.name === 'AbortError') {
        throw new Error('Request was cancelled');
      }
      
      throw error; // Re-throw other errors
    }
  }
  
  // Convenience methods
  get(endpoint) {
    return this.request(endpoint);
  }
  
  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}

// Usage
const api = new ApiClient('https://jsonplaceholder.typicode.com');

api.get('/users/1')
  .then(user => api.get(`/users/${user.id}/posts`))
  .then(posts => console.log('User posts:', posts))
  .catch(error => console.error('API request failed:', error.message));
```

### Loading States in UI
```javascript
// React-like component logic
class DataLoader {
  constructor(updateUI) {
    this.updateUI = updateUI;
    this.isLoading = false;
    this.data = null;
    this.error = null;
  }
  
  async loadData(endpoint) {
    this.isLoading = true;
    this.error = null;
    this.updateUI({ loading: true, data: null, error: null });
    
    try {
      const data = await fetch(endpoint).then(r => r.json());
      this.data = data;
      this.isLoading = false;
      this.updateUI({ loading: false, data, error: null });
    } catch (error) {
      this.error = error.message;
      this.isLoading = false;
      this.updateUI({ loading: false, data: null, error: error.message });
    }
  }
}

// Usage
const loader = new DataLoader(state => {
  if (state.loading) showSpinner();
  else if (state.error) showError(state.error);
  else displayData(state.data);
});
```

## Performance and Best Practices

### Avoid Async Operations in Loops (Common Mistake)
```javascript
// Bad: Sequential requests (slow)
const users = [1, 2, 3, 4, 5];
async function loadUsersSequentially() {
  const results = [];
  for (const id of users) {
    const user = await fetchUser(id); // Waits for each request
    results.push(user);
  }
  return results; // Takes ~5 seconds
}

// Good: Parallel requests (fast)
async function loadUsersInParallel() {
  const promises = users.map(id => fetchUser(id));
  return await Promise.all(promises); // Takes ~1 second
}
```

### Memory Management
```javascript
// Close resources properly
async function processFile(filePath) {
  let stream;
  try {
    stream = fs.createReadStream(filePath);
    const data = await processStream(stream);
    return data;
  } finally {
    // Always close resources
    if (stream) {
      stream.destroy();
    }
  }
}
```

### Error Boundaries and Recovery
```javascript
class AsyncOperationManager {
  constructor() {
    this.operations = new Map();
  }
  
  async executeOperation(id, operation) {
    if (this.operations.has(id)) {
      return this.operations.get(id); // Return existing promise
    }
    
    const promise = operation()
      .catch(error => {
        this.operations.delete(id); // Clean up on error
        throw error; // Re-throw
      });
    
    this.operations.set(id, promise);
    return promise;
  }
  
  cancelOperation(id) {
    const operation = this.operations.get(id);
    if (operation && operation.abortController) {
      operation.abortController.abort();
    }
    this.operations.delete(id);
  }
}
```

## Debugging Asynchronous Code

### Promise Debugging
```javascript
// Log promise lifecycle
function debugPromise(promise, name = 'Anonymous Promise') {
  console.log(`${name}: Starting...`);
  
  return promise
    .then(result => {
      console.log(`${name}: Success -`, result);
      return result;
    })
    .catch(error => {
      console.error(`${name}: Error -`, error.message);
      throw error;
    });
}

debugPromise(fetch('/api/data'), 'Data fetch')
  .then(data => console.log('Processing result'));
```

### Stack Traces in Async Code
```javascript
// Enable async stack traces in Node.js (if available)
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Promise Rejection:', reason);
  console.error('Promise:', promise);
});

// For browser development, use browser dev tools
// Check "Async" checkbox in Sources panel to show async call stacks
```

### Timing Issues
```javascript
// Log operation timing
async function timedOperation(operation, name) {
  console.time(name);
  try {
    const result = await operation();
    console.timeEnd(name);
    return result;
  } catch (error) {
    console.timeEnd(name);
    throw error;
  }
}

// Usage
timedOperation(() => fetchUser(1), 'User fetch');
```

## Key Takeaway
Handling asynchronous operations in JavaScript involves understanding callbacks, promises, and async/await. Start with callbacks for simple cases, use promises for complex chains, and leverage async/await for readable synchronous-style code. Always handle errors properly, avoid blocking operations, and consider performance implications like parallel vs sequential execution. Modern JavaScript provides powerful tools for managing async operations, enabling responsive applications that can efficiently handle I/O, network requests, and user interactions without blocking the main thread.
