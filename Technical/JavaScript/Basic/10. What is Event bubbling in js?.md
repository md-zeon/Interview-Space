# What is Event bubbling in js?

## Overview
Event bubbling is a phase of event propagation in the DOM where events that occur on an element propagate upward through its ancestor elements in the DOM tree. This allows parent elements to handle events that originated from their child elements.

## Understanding Event Propagation

### The Three Phases of Event Propagation

1. **Capturing Phase (Downward)**: The event travels down from window → document → parent → target
2. **Target Phase**: The event reaches the target element where it was triggered
3. **Bubbling Phase (Upward)**: The event bubbles up from target → parent → document → window

```html
<!DOCTYPE html>
<html> <!-- 1. Capturing -->
  <body> <!-- 2. Capturing -->
    <div id="container"> <!-- 3. Capturing -->
      <button id="myButton">Click Me</button> <!-- 4. Target -->
    </div> <!-- 5. Bubbling -->
  </body> <!-- 6. Bubbling -->
</html> <!-- 7. Bubbling -->
```

### Event Bubbling in Action

```javascript
// HTML structure:
// <div id="grandparent">
//   <div id="parent">
//     <button id="child">Click Me</button>
//   </div>
// </div>

const grandparent = document.getElementById('grandparent');
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Add click event listeners to all elements
grandparent.addEventListener('click', () => console.log('Grandparent clicked'));
parent.addEventListener('click', () => console.log('Parent clicked'));
child.addEventListener('click', () => console.log('Child clicked'));

// Clicking the "child" button will output:
// "Child clicked"      (target phase)
// "Parent clicked"     (bubbling phase)
// "Grandparent clicked"(bubbling phase)
```

## The Event Object

### Event Properties
```javascript
grandparent.addEventListener('click', function(event) {
  console.log('Event triggered on:', event.target); // Element that was clicked
  console.log('Current handler element:', event.currentTarget); // Element with this handler
  console.log('Event type:', event.type); // 'click'
  console.log('Event is bubbling:', event.bubbles); // True for most events
});
```

### Key Properties:
- **`event.target`**: The actual element that was clicked (does not change during propagation)
- **`event.currentTarget`**: The element whose event listener is currently executing
- **`event.type`**: The type of event (e.g., 'click', 'submit')
- **`event.bubbles`**: Whether this event bubbles
- **`event.eventPhase`**: The current phase (1=CAPTURING_PHASE, 2=AT_TARGET, 3=BUBBLING_PHASE)

## Controlling Event Propagation

### Stopping Event Propagation
Use `event.stopPropagation()` to prevent further bubbling:

```javascript
// HTML: <div id="parent"><button id="child">Click</button></div>

// Without stopPropagation
document.getElementById('parent').addEventListener('click', () =>
  console.log('Parent handler'));

document.getElementById('child').addEventListener('click', () =>
  console.log('Child handler'));
// Output when clicking child: "Child handler", "Parent handler"

// With stopPropagation
document.getElementById('child').addEventListener('click', function(event) {
  console.log('Child handler');
  event.stopPropagation(); // Stop bubbling
});
// Output when clicking child: "Child handler" (parent handler doesn't run)
```

### Stopping Immediate Propagation
Use `event.stopImmediatePropagation()` to stop both bubbling and other handlers on the same element:

```javascript
const button = document.getElementById('myButton');

button.addEventListener('click', () => console.log('First handler'));
button.addEventListener('click', (event) => {
  console.log('Second handler');
  event.stopImmediatePropagation(); // Stops all remaining handlers
});
button.addEventListener('click', () => console.log('Third handler'));

// Output: "First handler", "Second handler" (Third handler doesn't run)
```

## Event Capturing (Optional)

### Using Capturing Phase
By default, event listeners are added to the bubbling phase. To use capturing phase, set the third parameter to `true`:

```javascript
document.getElementById('grandparent').addEventListener('click',
  () => console.log('Grandparent (capturing)'), true);

document.getElementById('parent').addEventListener('click',
  () => console.log('Parent (capturing)'), true);

document.getElementById('child').addEventListener('click',
  () => console.log('Child (target)'));

document.getElementById('parent').addEventListener('click',
  () => console.log('Parent (bubbling)')); // Default is bubbling

document.getElementById('grandparent').addEventListener('click',
  () => console.log('Grandparent (bubbling)'));

// Clicking child outputs:
// "Grandparent (capturing)"
// "Parent (capturing)"
// "Child (target)"
// "Parent (bubbling)"
// "Grandparent (bubbling)"
```

## Practical Use Cases

### 1. Event Delegation
Instead of attaching handlers to each child element, attach one handler to the parent and use bubbling:

```javascript
// Instead of this (which becomes inefficient with many buttons):
const buttons = document.querySelectorAll('button');
buttons.forEach(button => {
  button.addEventListener('click', handleClick);
});

// Do this:
document.body.addEventListener('click', function(event) {
  if (event.target.matches('button')) {
    handleClick(event); // Event bubbled up to body
  }
});
```

### 2. Menu Systems
```javascript
const menu = document.querySelector('.dropdown-menu');
const toggle = document.querySelector('.dropdown-toggle');

toggle.addEventListener('click', () => {
  menu.classList.toggle('open');
});

// Close menu when clicking outside (on document)
document.addEventListener('click', (event) => {
  if (!toggle.contains(event.target)) {
    menu.classList.remove('open');
  }
});
```

### 3. Table Row Handling
```javascript
const table = document.querySelector('table');

// Single handler for all table cells
table.addEventListener('click', function(event) {
  if (event.target.tagName === 'TD') {
    const cellValue = event.target.textContent;
    const rowIndex = event.target.parentNode.rowIndex;
    const colIndex = event.target.cellIndex;

    console.log(`Clicked cell: ${cellValue} at (${rowIndex}, ${colIndex})`);
  }
});
```

### 4. Form Validation with Delegation
```javascript
const form = document.getElementById('myForm');

form.addEventListener('blur', function(event) {
  // Event bubbles up from input fields
  if (event.target.tagName === 'INPUT' && event.target.required) {
    validateInput(event.target);
  }
}, true); // Use capturing to catch blur events early
```

### 5. Tab Interface
```javascript
const tabs = document.querySelector('.tabs');
const contents = document.querySelectorAll('.tab-content');

tabs.addEventListener('click', function(event) {
  if (event.target.classList.contains('tab')) {
    // Hide all content
    contents.forEach(content => content.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

    // Show selected content
    const targetContent = document.querySelector(event.target.dataset.target);
    event.target.classList.add('active');
    targetContent.classList.add('active');
  }
});
```

## Event Types and Bubbling Behavior

### Events That Bubble (Most Common)
- `click`, `dblclick`
- `mousedown`, `mouseup`, `mousemove`
- `keydown`, `keyup`, `keypress`
- `change`, `input`, `submit`
- `focus`, `blur`

### Events That Don't Bubble (Focus Events)
- `focus`, `blur` (use `focusin`, `focusout` for bubbling equivalents)
- `mouseenter`, `mouseleave`
- `load`, `unload`
- `scroll`, `resize`

### Custom Events with Bubbling
```javascript
const button = document.querySelector('button');

// Create custom event that bubbles
const customEvent = new Event('myCustomEvent', {
  bubbles: true, // Allow bubbling
  cancelable: true
});

button.addEventListener('click', () => {
  button.dispatchEvent(customEvent);
});

// Parent can listen for the custom event
document.body.addEventListener('myCustomEvent', () => {
  console.log('Custom event bubbled up!');
});
```

## Best Practices

### 1. Use Event Delegation for Performance
```javascript
// Good: One listener on parent
document.getElementById('list').addEventListener('click', function(event) {
  if (event.target.tagName === 'LI') {
    handleListItemClick(event);
  }
});

// Avoid: Multiple listeners (especially for dynamically added elements)
```

### 2. Stop Propagation Only When Necessary
```javascript
// Good: Only stop when you need to
element.addEventListener('click', function(event) {
  doSomething();
  // Don't stop propagation unless you have a specific reason
});

// Bad: Prematurely stopping propagation can break other code
element.addEventListener('click', function(event) {
  doSomething();
  event.stopPropagation(); // Can break event delegation
});
```

### 3. Handle Clearing of Event Listeners
```javascript
// For components that get destroyed
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
    this.element.addEventListener('click', this.handleClick);
  }

  destroy() {
    this.element.removeEventListener('click', this.handleClick);
  }
}
```

### 4. Use Event Capturing Sparingly
```javascript
// Use capturing only when order matters
element.addEventListener('click', callback, true); // Use with care
```

### 5. Consider Event Order with Multiple Elements
```javascript
// If you need siblings to handle events first
siblings.forEach(sibling => {
  sibling.addEventListener('click', handleSibling, false); // Bubbles later
});

parentElement.addEventListener('click', handleParent, false); // Last
```

## Browser Compatibility

### Universal Support
Event bubbling is supported in all modern browsers. For legacy browsers:

```javascript
// Cross-browser event handling
function addEventListener(element, event, callback) {
  if (element.addEventListener) { // Modern browsers
    element.addEventListener(event, callback, false);
  } else if (element.attachEvent) { // IE8 and below
    element.attachEvent('on' + event, callback);
  }
}
```

## Common Mistakes

### 1. Forgetting Event Delegation
```javascript
// Wrong: Adding listeners to dynamically created elements
setInterval(() => {
  const newButton = document.createElement('button');
  newButton.addEventListener('click', handleClick); // Won't work for future elements
  container.appendChild(newButton);
}, 1000);

// Right: Use delegation
container.addEventListener('click', function(event) {
  if (event.target.tagName === 'BUTTON') {
    handleClick(event);
  }
});
```

### 2. Improper Event Object Usage
```javascript
// Wrong: Calling stopPropagation on undefined event
function handleClick() {
  if (condition) {
    event.stopPropagation(); // Error: event is undefined
  }
}

// Right: Properly receive event parameter
function handleClick(event) {
  if (condition) {
    event.stopPropagation();
  }
}
```

### 3. Confusing event.target and event.currentTarget
```javascript
// Wrong understanding
parent.addEventListener('click', function(event) {
  console.log(event.target);  // Child that was clicked
  console.log(this);          // Parent element (same as event.currentTarget)
});
```

## Debugging Event Problems

### Console Debugging
```javascript
element.addEventListener('click', function(event) {
  console.log('Event target:', event.target);
  console.log('Event currentTarget:', event.currentTarget);
  console.log('Event phase:', event.eventPhase);
  console.log('Event bubbles:', event.bubbles);
});
```

### Event Listener Count
```javascript
// Get number of listeners (Chrome DevTools)
console.log(getEventListeners(element));
```

### Visual Event Inspection
Open browser developer tools: Elements tab → Configure → View as Events

## Key Takeaway
Event bubbling is a powerful mechanism that allows events to propagate up the DOM tree, enabling efficient event delegation and flexible event handling. Understanding the three phases of event propagation (capturing, target, bubbling) and proper use of `stopPropagation()` and `stopImmediatePropagation()` is crucial for building responsive and maintainable web applications.
