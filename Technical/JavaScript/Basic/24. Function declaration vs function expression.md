# Function declaration vs function expression

## Overview
JavaScript provides multiple ways to define functions, with the two primary approaches being function declarations and function expressions. These approaches differ significantly in their syntax, hoisting behavior, scope handling, and use cases. Understanding these differences is crucial for writing correct and maintainable JavaScript code.

## Basic Syntax Comparison

### Function Declaration
```javascript
// Standard function declaration
function greet(name) {
  return `Hello, ${name}!`;
}

// Usage
console.log(greet("Alice")); // "Hello, Alice!"
```

### Function Expression
```javascript
// Anonymous function expression
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Named function expression
const greet = function user(name) {
  return `Hello, ${name}!`;
};

// Arrow function expression (ES6+)
const greet = (name) => `Hello, ${name}!`;

// Usage (must come after declaration)
console.log(greet("Bob")); // "Hello, Bob!"
```

## Key Differences

### 1. Hoisting Behavior

#### Function Declarations are Hoisted
```javascript
// Declaration can be called before it's defined
console.log(declaration()); // "Declaration called"

// Function declaration is hoisted
function declaration() {
  return "Declaration called";
}
```

#### Function Expressions are Not Hoisted
```javascript
// Expression cannot be called before definition
console.log(expression()); // ReferenceError: expression is not defined

// Function expression
const expression = function() {
  return "Expression called";
};

console.log(expression()); // "Expression called" (works after declaration)
```

### 2. Scope and Context

#### Function Declaration Scope
```javascript
// Function declarations are bound to their enclosing scope
if (true) {
  function scopedDeclaration() {
    return "I'm scoped";
  }
}

// In non-strict mode, function declarations are function-scoped (can be called outside block)
// In strict mode, they are block-scoped in most browsers

// Function declarations create their own scope
function outer() {
  console.log(declaration); // Function itself
  
  function declaration() {
    return "inner declaration";
  }
  
  console.log(declaration()); // "inner declaration"
}
```

#### Function Expression Scope
```javascript
// Bound by variable scoping rules
if (true) {
  const scopedExpression = function() {
    return "I'm scoped to block";
  };
  
  console.log(scopedExpression()); // Works inside block
}

// console.log(scopedExpression); // ReferenceError (not accessible outside block)

// Variable scope rules apply
let expression;
if (condition) {
  expression = function() {
    return "assigned in block";
  };
}

console.log(typeof expression); // "function" or "undefined" (depends on condition)
```

### 3. The `this` Context

#### Function Declaration
```javascript
// Normal function declaration
function Person(name) {
  this.name = name;
}

const person = new Person("Alice");
// this refers to the newly created object

// Method context
const obj = {
  method: function() {
    return this.value;
  },
  value: 42
};

console.log(obj.method()); // 42 (this === obj)
```

#### Function Expression
```javascript
// Normal function expression (same this behavior)
const PersonExpression = function(name) {
  this.name = name;
};

const person2 = new PersonExpression("Bob"); // Works the same way

// Arrow function expression (lexical this)
const obj = {
  arrowMethod: () => {
    return this.value; // this not bound to obj, but to enclosing scope
  },
  value: 42
};

console.log(obj.arrowMethod()); // undefined (if not in an enclosing context)
```

### 4. Named Functions

#### Function Declaration (Always Named)
```javascript
// Function name is automatically set
function namedDeclaration() {
  return "I'm named";
}

console.log(namedDeclaration.name); // "namedDeclaration"
```

#### Function Expression (Can be Named or Anonymous)
```javascript
// Anonymous function expression
const anonymous = function() {
  return "I'm anonymous";
};

console.log(anonymous.name); // "" (empty string)

// Named function expression
const namedExpression = function named() {
  return "I'm named";
};

console.log(namedExpression.name); // "named" (accessible in the function body)

// The name is useful for recursion and debugging
const factorial = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1); // 'fact' refers to the function itself
};
```

### 5. Function Properties and Methods

#### Function Declaration
```javascript
function example(a, b) {
  return a + b;
}

// Already has properties when hoisted
console.log(example.length); // 2 (number of parameters)
console.log(example.name);   // "example"

// Can add properties immediately
example.version = "1.0";
console.log(example.version); // "1.0"
```

#### Function Expression
```javascript
// Properties cannot be accessed until after assignment
// console.log(expression.length); // ReferenceError

const expression = function(a, b) {
  return a + b;
};

// Now accessible
console.log(expression.length); // 2
console.log(expression.name);   // "" (unless named)

expression.version = "1.0";
console.log(expression.version); // "1.0"
```

## Performance Implications

### Hoisting and Parsing
```javascript
// Browser can optimize declared functions during compilation
function declaredFunction() {
  // Fast - available before execution
}

// Expression must be evaluated at runtime
// const expression = function() { ... }; - slower first-time access

// In tight loops or critical paths:
const functions = [];
for (let i = 0; i < 1000; i++) {
  // Function declaration in loop - recreated each time
  functions.push(function funcDeclared() { return i; });
  
  // Function expression in loop - also recreated each time
  functions.push(function funcExpression() { return i; });
}

// Better: Create outside loop
function declared(num) { return num; }
const expression = (num) => num;
```

## Practical Usage Scenarios

### When to Use Function Declarations

#### 1. Main Program Functions
```javascript
// Function declarations are appropriate for the main program flow
function main() {
  initialize();
  processData();
  renderUI();
}

function initialize() {
  // Set up application
}

function processData() {
  // Handle data processing
}

function renderUI() {
  // Update user interface
}

// Call main function
main();
```

#### 2. Recursively Called Functions
```javascript
function factorial(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Reference itself by name
}

function traverseDOM(node) {
  if (!node) return;
  
  // Process current node
  processNode(node);
  
  // Recursively process children
  node.childNodes.forEach(child => traverseDOM(child));
}
```

#### 3. Functions Referenced Before Definition
```javascript
// Event handlers that reference each other
document.addEventListener('click', handleClick);

// Function defined later but still works due to hoisting
function handleClick() {
  if (condition) {
    showMessage();
  }
}

function showMessage() {
  // Handle message display
}
```

### When to Use Function Expressions

#### 1. As Function Arguments (Callbacks)
```javascript
// Event listeners
button.addEventListener('click', function() {
  console.log('Button clicked');
});

// Array methods
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(function(num) {
  return num * 2;
});

// Promises
fetch('/api/data')
  .then(function(response) {
    return response.json();
  })
  .then(function(data) {
    console.log(data);
  });
```

#### 2. Immediately Invoked Function Expressions (IIFE)
```javascript
// Create isolated scope
(function() {
  const privateVar = "secret";
  console.log(privateVar); // "secret"
})();

// console.log(privateVar); // ReferenceError

// IIFE with parameters
(const multiplier = 2,
 function initApp(multiplier) {
   console.log(`App initialized with multiplier: ${multiplier}`);
 }(multiplier || 1));
```

#### 3. Conditional Function Assignment
```javascript
// Choose function based on environment
const logger = (typeof console !== 'undefined') 
  ? function(message) { console.log(message); }
  : function(message) { /* silent fallback */ };

logger("Application started");
```

#### 4. Encapsulating Private Logic
```javascript
// Module pattern with function expressions
const calculator = (function() {
  const privateUtility = function(a, b) {
    return a + b; // Private helper
  };

  return {
    add: function(a, b) {
      return privateUtility(a, b);
    },
    
    multiply: function(a, b) {
      return a * b;
    }
  };
})();

console.log(calculator.add(5, 3)); // 8 (uses private function)
```

## Best Practices and Performance

### 1. Consistent Declaration Style
```javascript
// Prefer consistent style within a codebase

// Function declarations for top-level functions
function main() { }
function helper() { }

// Function expressions for callbacks and assignments
const callback = function() { };
const arrowCallback = () => { };
```

### 2. Named Function Expressions for Debugging
```javascript
// Better debugging with named functions
const requestHandler = function handleRequest(request) {
  if (!request.valid) {
    throw new Error('Invalid request in handleRequest');
  }
  // Function name appears in stack traces
};

setTimeout(requestHandler, 1000);

// Stack trace will show: handleRequest at line X
```

### 3. Arrow Functions for Concise Expressions
```javascript
// Short, single-purpose functions
const numbers = [1, 2, 3, 4, 5];
const squares = numbers.map(n => n * n);

// Object transformations
const userData = users.map(user => ({
  id: user.id,
  name: user.name.toUpperCase()
}));

// Converting function declaration style to arrow
// From: function(event) { this.handleEvent(event); }
// To: event => this.handleEvent(event) // lexical this preserved
```

### 4. Performance Considerations
```javascript
// In performance-critical code, declarations might have slight edge
// due to hoisting and compile-time optimization

// But modern JavaScript engines optimize both effectively
// Prioritize code clarity over micro-optimizations

// Example: Hot code path
function processArray(items) {
  // Function declaration inside scope - optimized by engine
  function processItem(item) {
    return item.value * 2;
  }
  
  return items.map(processItem); // Redefined on each call
}

// Better: Define outside scope for reuse
function processItem(item) {
  return item.value * 2;
}

function processArray(items) {
  return items.map(processItem); // Same function reused
}
```

## Common Pitfalls and Mistakes

### 1. Forgetting Function Expression Scope
```javascript
// Common mistake with loops (before ES6)
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Always 3, not 0, 1, 2
  }, 100);
}

// Fixed with function declarations (creates new scope each iteration)
for (var i = 0; i < 3; i++) {
  (function(currentI) {
    setTimeout(function() { console.log(currentI); }, 100);
  })(i);
}

// Modern fix with let (block scope)
for (let i = 0; i < 3; i++) {
  setTimeout(function() { console.log(i); }, 100);
}
```

### 2. Recursive Function Expressions
```javascript
// Anonymous function expression - cannot reference itself
const factorial = function(n) {
  if (n <= 1) return 1;
  return n * factorial(n - 1); // Works but confusing
};

// Clearer: Named function expression
const factorialNamed = function fact(n) {
  if (n <= 1) return 1;
  return n * fact(n - 1); // Clear it's recursive
};
```

### 3. Hoisting Misunderstandings
```javascript
// Function declaration hoisted - conditional won't prevent hoisting
if (false) {
  function shouldNotExist() {
    return "I don't exist";
  }
}

// But in non-strict mode, function might still exist!
// str mode: function declarations in blocks are scoped to block
```

### 4. Function Declaration in Blocks (Strict Mode)
```javascript
// In strict mode
if (true) {
  function conditionalDeclaration() {
    return "conditional";
  }
}

console.log(typeof conditionalDeclaration); // "function" in non-strict, "undefined" in strict
```

## Browser Compatibility

### Function Declaration Hoisting
- All browsers hoist function declarations
- Strict mode affects block-scoped declarations

### Function Expression Support
- ES3+ browsers support function expressions
- Arrow functions: ES6+ support required

### Polyfills and Transpilation
```javascript
// For older browsers without arrow function support
// Babel transpiles: const add = (a, b) => a + b;
// To: var add = function(a, b) { return a + b; };
```

## When to Choose Which Approach

### Use Function Declarations when:
- Function is a core part of your module's API
- Function needs to be referenced before its declaration
- You need recursive functions with clear names
- Performance is critical (slight edge in some engines)

### Use Function Expressions when:
- Function will be used as a callback or argument to another function
- You want to leverage closures and encapsulation
- Creating private or conditional functions
- Code organization benefits from storing functions in variables

### Use Arrow Functions when:
- Function is short and simple
- You need lexical `this` binding
- Function is a transformation or mapping operation
- You want concise syntax for callbacks

## Key Takeaway
Function declarations are hoisted and can be called before they are defined, making them suitable for program structure and recursive functions. Function expressions are assigned to variables and must be defined before use, making them ideal for callbacks, conditional logic, and modular code. Arrow functions provide concise syntax with lexical `this` binding, perfect for simple transformations and event handlers. Choose the approach that best fits your code structure needs and maintain consistency within your project.
