# What is a variable?

## Overview
A variable in JavaScript is a named storage location that holds a value and can be referenced and modified throughout the program. Variables are fundamental building blocks in programming, allowing you to store, retrieve, and manipulate data dynamically during execution.

## Basic Concept

### What is a Variable?
- **Container for Data**: A way to store information that can be accessed and modified
- **Named Reference**: Identified by a unique name within its scope
- **Dynamic Values**: Can hold different types of data and values can change over time
- **Memory Allocation**: Represents a location in memory where data is stored

### Simple Example
```javascript
let age = 25;     // Variable declaration and initialization
age = 26;         // Value modification
console.log(age); // Accessing variable value
```

## Variable Declaration

### Three Declaration Keywords

#### 1. var (Legacy, Function-scoped)
```javascript
var message = "Hello";
console.log(message); // "Hello"

// Hoisting behavior
console.log(hoisted); // undefined (hoisted)
var hoisted = "I'm hoisted";

// Function scope
function example() {
  var localVar = "local";
  if (true) {
    var stillLocal = "still function-scoped"; // Not block-scoped!
  }
  console.log(stillLocal); // "still function-scoped"
}
example();
// console.log(localVar); // ReferenceError
```

#### 2. let (Modern, Block-scoped)
```javascript
let counter = 0;
counter = 1; // Reassignment allowed

// Temporal Dead Zone (TDZ)
console.log(tdz); // ReferenceError: Cannot access 'tdz' before initialization
let tdz = "temporal dead zone";

// Block scope
if (true) {
  let blockScoped = "inside block";
  console.log(blockScoped); // "inside block"
}
// console.log(blockScoped); // ReferenceError

// Loop scope
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0); // 0, 1, 2 (each iteration has its own i)
}
```

#### 3. const (Constant, Block-scoped)
```javascript
const PI = 3.14159;
// PI = 3.14; // TypeError: Assignment to constant variable

// Must be initialized
// const uninitialized; // SyntaxError: Missing initializer in const declaration

// Object/array contents can be modified (reference is constant)
const person = { name: "John" };
person.name = "Jane"; // Allowed - modifying object property
person = { name: "Bob" }; // TypeError - reassigning the reference

const numbers = [1, 2, 3];
numbers.push(4); // Allowed - modifying array
numbers = [4, 5, 6]; // TypeError - reassigning the reference
```

## Variable Naming Rules

### Valid Characters
```javascript
let variableName;    // Underscore and letters
let variable_name;   // Underscore
let $dollarSign;     // Dollar sign
let camelCase;       // Convention for JS
let PascalCase;      // For constructors/classes
let SCREAMING_CASE;  // For constants

// ES6 features
let snake_case;      // Still allowed
let emojiüòÄ;         // Unicode allowed (but not recommended)
```

### Invalid Names
```javascript
// Cannot start with number
// let 123variable; // SyntaxError: Invalid variable declaration

// Reserved keywords
// let var; // SyntaxError: Unexpected token 'var'
// let if;  // SyntaxError
// let for; // SyntaxError

// Cannot use spaces or special characters except _ and $
// let my-variable; // SyntaxError (hyphens not allowed)
```

### Best Practices for Naming
```javascript
// Use descriptive, meaningful names
let userName = "john_doe";     // ‚úÖ Clear purpose
let str = "john_doe";          // ‚ùå Unclear

// Use camelCase for variables
let firstName = "John";        // ‚úÖ
let first_name = "John";       // ‚ùå (not JavaScript convention)

// Use PascalCase for constructors
let person = new Person();     // Person is PascalCase

// Use descriptive prefixes for types (when helpful)
let isLoading = true;          // Boolean
let userCount = 5;             // Number
let users = [];               // Array
```

## Variable Scope

### Understanding Scope
Scope defines where a variable is accessible in your code.

#### Global Scope
```javascript
// Global variables declared outside functions
const globalVar = "I'm global";

function accessGlobal() {
  console.log(globalVar); // Accessible
}

// Global scope pollution (avoid this)
withoutVar = "global without var"; // Creates global variable
```

#### Function Scope
```javascript
function exampleScope() {
  var functionScoped = "inside function";
  
  if (true) {
    let blockScoped = "inside block";
    var stillFunctionScoped = "also inside function";
  }
  
  console.log(functionScoped);     // ‚úÖ "inside function"
  console.log(stillFunctionScoped); // ‚úÖ "also inside function"
  // console.log(blockScoped);     // ‚ùå ReferenceError
}

exampleScope();
```

#### Block Scope (let/const)
```javascript
{
  let blockVar = "block scoped";
  const blockConst = "also block scoped";
}

console.log(blockVar); // ReferenceError
console.log(blockConst); // ReferenceError

// Loop block scope
for (let i = 0; i < 3; i++) {
  // i is scoped to this block
}
// console.log(i); // ReferenceError
```

#### Module Scope (ES6 Modules)
```javascript
// In a module file
export const publicVar = "accessible from outside";
const privateVar = "only in this module";
```

## Variable Types and Values

### Primitive Types
```javascript
// Number
let count = 42;
let price = 29.99;

// String
let message = "Hello World";
let dynamicMessage = `Count: ${count}`;

// Boolean
let isActive = true;
let hasItems = false;

// undefined
let uninitialized;
let explicitlyUndefined = undefined;

// null
let noValue = null;

// Symbol (ES6)
let uniqueId = Symbol('id');

// BigInt (ES11)
let largeNumber = 123456789012345678901234567890n;
```

### Reference Types
```javascript
// Object
let person = {
  name: "John",
  age: 30,
  greet: function() { return `Hi, I'm ${this.name}`; }
};

// Array
let numbers = [1, 2, 3, 4, 5];
let mixedArray = [1, "two", true, {item: 4}];

// Function
let greet = function(name) { return `Hello ${name}`; };
let arrowFunction = (name) => `Hi ${name}`;

// Date
let currentDate = new Date();

// Regular Expression
let pattern = /hello/i;

// Map and Set
let userMap = new Map();
let uniqueTags = new Set(['javascript', 'programming']);
```

## Variable Assignment and Reassignment

### Initial Assignment
```javascript
// Declaration with initialization
let name = "Alice";
const PI = 3.14159;

// Declaration without initialization
let unassigned; // undefined by default

// Multiple declarations
let a = 1, b = 2, c = 3;
```

### Reassignment
```javascript
let counter = 0;
counter = 1;     // Valid (let allows reassignment)
counter++;       // 2
counter += 10;   // 12

// Changing data types (dynamic typing)
counter = "twelve"; // Valid in JavaScript, but not recommended
counter = true;     // Also valid
counter = null;     // Also valid

// const doesn't allow reassignment
const fixedValue = "immutable";
// fixedValue = "changed"; // TypeError
```

### Destructuring Assignment
```javascript
// Array destructuring
let [first, second] = [1, 2, 3, 4];
console.log(first, second); // 1, 2

// Object destructuring
let {name, age} = {name: "John", age: 30, city: "NYC"};
console.log(name, age); // "John", 30

// Default values
let [x = 1, y = 2] = [10];
console.log(x, y); // 10, 2

// Rest operator
let [a, b, ...rest] = [1, 2, 3, 4, 5];
console.log(a, b, rest); // 1, 2, [3, 4, 5]
```

## Variable Memory Management

### Garbage Collection
```javascript
let reference = { data: "heavy object" };

// The object is kept in memory because of the reference
console.log(reference.data);

// Removing the reference allows garbage collection
reference = null; // Object can now be garbage collected

// Or remove from arrays/objects
let array = [{}, {}, {}];
let object = { key: "value" };

// Clearing references
array.length = 0;
delete object.key;
```

### Memory Leaks
```javascript
// Global variables persist until page unload
window.globalReference = { largeObject: "data" };
// Never garbage collected unless explicitly removed
delete window.globalReference;

// Forgotten event listeners
const element = document.getElementById('button');
element.addEventListener('click', function() {
  // This closure creates a persistent reference
  console.log(event.target);
}); // Never removed - memory leak if element is dynamically removed
```

### Weak References (ES6)
```javascript
// WeakMap and WeakSet don't prevent garbage collection
const weakMap = new WeakMap();
let key = { id: 1 };
weakMap.set(key, "value");

key = null; // Object can be garbage collected
// weakMap entry is automatically removed

// Regular Map keeps the reference
const strongMap = new Map();
key = { id: 1 };
strongMap.set(key, "value");
key = null; // Object stays in memory due to Map reference
```

## Variable Best Practices

### 1. Prefer const over let
```javascript
// Use const for values that shouldn't change
const API_URL = 'https://api.example.com';
const CONFIGURATION = { theme: 'dark', language: 'en' };

// Use let only when reassignment is needed
let counter = 0;
while (counter < 10) {
  processItem(counter);
  counter++;
}

// Use var only for legacy compatibility
var legacyVariable; // Avoid in modern code
```

### 2. Avoid Global Variables
```javascript
// Bad - pollutes global scope
globalCounter = 0;

// Good - encapsulated
function createCounter() {
  let count = 0; // Private
  
  return {
    get: () => count,
    increment: () => ++count,
    decrement: () => --count
  };
}

const counter = createCounter();
```

### 3. Descriptive Naming
```javascript
// Bad - unclear purpose
let a = 5;
let b = [];
let c = function() {};

// Good - self-documenting
let numberOfUsers = 5;
let userList = [];
let validateUser = function() {};
```

### 4. Initialize Variables
```javascript
// Bad - uninitialized
let status;
if (user.isActive) {
  status = 'active';
}

// Good - initialized
let status = 'inactive'; // Default value
if (user.isActive) {
  status = 'active';
}
```

### 5. Group Related Variables
```javascript
// Centralized configuration
const config = {
  API_BASE_URL: 'https://api.example.com',
  MAX_RETRIES: 3,
  TIMEOUT: 5000
};

// Instead of scattered variables:
// const API_BASE_URL = 'https://api.example.com';
// const MAX_RETRIES = 3;
// const TIMEOUT = 5000;
```

## Variable Patterns and Techniques

### 1. Variable Swapping
```javascript
let a = 1, b = 2;

// Traditional way
let temp = a;
a = b;
b = temp;

// Modern way (destructuring)
[a, b] = [b, a];
```

### 2. Computed Property Names
```javascript
const propertyName = 'dynamicProperty';
const obj = {
  [propertyName]: 'value',
  ['computed_' + 42]: 'another value'
};

console.log(obj.dynamicProperty);      // 'value'
console.log(obj.computed_42);          // 'another value'
```

### 3. Variable Hoisting Considerations
```javascript
// Hoisted (var)
console.log(hoisted); // undefined
var hoisted = "I'm hoisted";

// Temporal dead zone (let/const)
try {
  console.log(tdz); // ReferenceError
  let tdz = "temporal dead zone";
} catch (e) {
  console.log('TDZ error:', e.message);
}
```

### 4. Closures and Variable Capturing
```javascript
function createFunctions() {
  const functions = [];
  
  for (let i = 0; i < 3; i++) {
    functions[i] = function() {
      return i; // Lexical scope capture
    };
  }
  
  return functions;
}

const myFunctions = createFunctions();
console.log(myFunctions[0]()); // 0
console.log(myFunctions[1]()); // 1
console.log(myFunctions[2]()); // 2
```

### 5. Default Parameters
```javascript
// Old way
function greet(name) {
  const greetingName = name || 'Guest';
  return `Hello ${greetingName}`;
}

// Modern way with default parameters
function greet(name = 'Guest') {
  return `Hello ${name}`;
}
```

## Key Takeaway
Variables are named storage locations that hold values and can be modified throughout program execution. Understanding the different declaration keywords (var, let, const), scope rules, and best practices is crucial for writing maintainable JavaScript code. The choice of variable declaration affects hoisting, scope, and mutability, with let and const being the modern standards that provide better control over variable behavior.
