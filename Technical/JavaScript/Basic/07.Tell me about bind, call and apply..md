# Tell me about bind, call and apply

## Overview
`bind()`, `call()`, and `apply()` are methods available on JavaScript function objects that allow you to control the `this` context when a function is executed. They are fundamental tools for managing function context and enabling functional programming patterns.

## The `this` Context Problem

Before diving into these methods, understand why they're needed:

```javascript
const person = {
  name: 'John',
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

person.greet(); // "Hello, my name is John" - this refers to person

const greetFunction = person.greet;
greetFunction(); // "Hello, my name is undefined" - this is window/global

// Problem: When extracting methods, context is lost
```

## The Three Methods

## 1. `call()` Method

### Description
- Immediately invokes the function it is called on
- First argument: value to bind to `this`
- Subsequent arguments: individual parameters passed to the function

### Syntax
```javascript
function.method.call(thisArg, arg1, arg2, ..., argN)
```

### Examples
```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, my name is ${this.name}${punctuation}`);
}

const person = { name: 'Alice' };

// Using call
greet.call(person, 'Hello', '!'); // "Hello, my name is Alice!"
greet.call(person, 'Hi', '.');    // "Hi, my name is Alice."

// Another example
function calculateArea(width) {
  return width * this.height;
}

const rectangle = { height: 10 };
console.log(calculateArea.call(rectangle, 5)); // 50 (5 * 10)
```

### Real-World Use Cases
```javascript
// Constructor borrowing (inheritance simulation)
function Animal(name) {
  this.name = name;
}

function Bird(name, canFly) {
  Animal.call(this, name); // Call Animal constructor
  this.canFly = canFly;
}

const eagle = new Bird('Eagle', true);
console.log(eagle.name); // 'Eagle'

// Function reusability
const numbers = [5, 6, 2, 3, 7];
const max = Math.max.apply(null, numbers);
console.log(max); // 7
```

## 2. `apply()` Method

### Description
- Immediately invokes the function it is called on
- First argument: value to bind to `this`
- Second argument: array (or array-like object) of parameters

### Syntax
```javascript
function.apply(thisArg, [argsArray])
```

### Examples
```javascript
function introduce(intro, age) {
  console.log(`${intro}. I'm ${this.name} and I'm ${age} years old.`);
}

const person = { name: 'Bob' };

// Using apply
introduce.apply(person, ["Hi there", 25]); // "Hi there. I'm Bob and I'm 25 years old."

// Another example with array spreading
function sumNumbers(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];
console.log(sumNumbers.apply(null, numbers)); // 6
```

### Key Difference from `call()`
The main difference is how arguments are passed:

```javascript
// call: individual arguments
someFunction.call(thisArg, arg1, arg2, arg3);

// apply: array of arguments
someFunction.apply(thisArg, [arg1, arg2, arg3]);
```

### Real-World Use Cases
```javascript
// Finding minimum/maximum in array
const numbers = [5, 6, 2, 3, 7];
const min = Math.min.apply(null, numbers); // 2
const max = Math.max.apply(null, numbers); // 7

// Applying array methods to array-like objects
function logArguments() {
  console.log(Array.prototype.slice.apply(arguments));
  // Converts arguments object to real array
}

logArguments('a', 'b', 'c'); // ['a', 'b', 'c']

// Function composition
function compose() {
  const functions = Array.prototype.slice.apply(arguments); // Convert to array
  return function(x) {
    return functions.reduceRight((result, fn) => fn(result), x);
  };
}
```

## 3. `bind()` Method

### Description
- Returns a new function with the `this` context bound permanently
- Does not invoke the function immediately
- Can bind some parameters while leaving others to be set later

### Syntax
```javascript
const boundFunction = function.bind(thisArg, [preSetArg1, preSetArg2, ...])
```

### Examples
```javascript
function greet(message, punctuation) {
  console.log(`${message}, ${this.name}${punctuation}`);
}

const person = { name: 'Charlie' };

// Using bind
const greetCharlie = greet.bind(person);
greetCharlie('Hello', '!');             // "Hello, Charlie!"
greetCharlie('Goodbye', '.');           // "Goodbye, Charlie."

// Partial application
const sayHello = greet.bind(person, 'Hello');
sayHello('!');                         // "Hello, Charlie!"
sayHello('?');                         // "Hello, Charlie?"

// Yet another example
const multiplier = {
  factor: 5,
  multiply(value) {
    return value * this.factor;
  }
};

const multiplyBy5 = multiplier.multiply.bind(multiplier);
console.log(multiplyBy5(3)); // 15
```

### Returning Bound Functions
```javascript
// Original function
function logGreeting() {
  console.log(`Hello, ${this.name}!`);
}

// Create bound versions
const person1 = { name: 'Alice' };
const person2 = { name: 'Bob' };

const greetAlice = logGreeting.bind(person1);
const greetBob = logGreeting.bind(person2);

// Use later
greetAlice(); // "Hello, Alice!"
greetBob();   // "Hello, Bob!"
```

## Comparison Summary

| Method | Immediate Execution | Arguments Pass | Returns | Use Case |
|--------|-------------------|-----------------|---------|----------|
| `call()` | Yes | Individual | Function result | Invoke function with specific context |
| `apply()` | Yes | Array | Function result | Invoke function with array of arguments |
| `bind()` | No | Pre-bound + runtime | Bound function | Create reusable function with bound context |

## Practical Examples

### 1. Event Handling with `bind()`
```javascript
class Button {
  constructor(text) {
    this.text = text;
  }

  handleClick() {
    console.log(`Button "${this.text}" was clicked`);
  }
}

const button1 = new Button('Save');
const button2 = new Button('Delete');

// With bind - preserve context
document.getElementById('saveBtn').addEventListener('click',
  button1.handleClick.bind(button1));

document.getElementById('deleteBtn').addEventListener('click',
  button2.handleClick.bind(button2));
```

### 2. Method Borrowing with `call()` and `apply()`
```javascript
const arrayLike = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};

// Borrow Array methods
Array.prototype.slice.call(arrayLike);     // ['a', 'b', 'c']
Array.prototype.map.call(arrayLike, x => x.toUpperCase()); // ['A', 'B', 'C']

// Using apply for dynamic arguments
function validateUser(id, name, email) {
  // validation logic
}

const userData = [123, 'John', 'john@example.com'];
validateUser.apply(null, userData); // Equivalent to: validateUser(123, 'John', 'john@example.com')
```

### 3. Currying with `bind()`
```javascript
function apiRequest(method, url, data) {
  // Make API request
  console.log(`${method} ${url} with data:`, data);
}

// Create specialized functions
const getRequest = apiRequest.bind(null, 'GET');
const postRequest = apiRequest.bind(null, 'POST');

getRequest('/users');                   // "GET /users with data: undefined"
postRequest('/users', {name: 'John'}); // "POST /users with data: {name: 'John'}"
```

### 4. Throttling/Debouncing with Context Preservation
```javascript
function debounce(func, wait, context) {
  let timeout;
  return function() {
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Create debounced function with preserved context
class SearchBar {
  constructor() {
    this.search = debounce(this.performSearch, 300, this);
  }

  performSearch(query) {
    console.log(`Searching for: ${query} in context:`, this);
  }
}
```

## Common Pitfalls

### 1. `bind()` Returns New Function
```javascript
const obj = {
  method() { console.log(this.value); }
};

const bound = obj.method.bind(obj); // New function
const alsoBound = bound.bind(obj);  // Does nothing - already bound
```

### 2. Arrow Functions Can't Be Bound
```javascript
const arrowFunc = () => { console.log(this.name); };
arrowFunc.bind({name: 'John'})(); // Still uses lexical this, not 'John'
```

### 3. Lost Bindings
```javascript
const obj = {
  name: 'test',
  method: function() {
    return function() {
      console.log(this.name); // undefined - lost context
    };
  }.bind(this) // binding inner function
};
```

### 4. Performance Impact
```javascript
// Avoid in loops - creates new function each time
for (let item of items) {
  doSomething.bind(item)(); // Creates new bound function each iteration
}

// Instead, use call/apply or store bound function
```

## Best Practices

### 1. Use Arrow Functions for Lexical `this`
```javascript
// Good - lexical binding
const obj = {
  name: 'Test',
  method: () => {
    setTimeout(() => {
      console.log(this.name); // Refers to obj
    });
  }
};
```

### 2. Prefer `call()`/`apply()` for One-Time Usage
```javascript
function greet() {
  console.log(`Hello, ${this.name}`);
}

greet.call({name: 'John'}); // Single use
```

### 3. Use `bind()` for Persistent Context
```javascript
const user = { name: 'Alice' };
setTimeout(function() {
  this.greet(); // Broken - lost context
}.bind(user), 1000);
```

### 4. Method Borrowing for Array-Like Objects
```javascript
function processArguments() {
  const args = Array.prototype.slice.call(arguments);
  args.forEach(arg => console.log(arg));
}
```

### 5. Safer Alternatives in Modern JavaScript
```javascript
// Class fields and arrow functions
class Component {
  handleClick = () => { // Automatic binding
    console.log(this.value);
  };
}
```

## Key Takeaway
- **`call()`**: Invoke function immediately with specific context and individual arguments
- **`apply()`**: Invoke function immediately with specific context and array of arguments
- **`bind()`**: Create new function with permanently bound context (doesn't invoke)
- These methods are essential for controlling the `this` context in JavaScript, especially when borrowing methods, implementing inheritance, or handling events.
