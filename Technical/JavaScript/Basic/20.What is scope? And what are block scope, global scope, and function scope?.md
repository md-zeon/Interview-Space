# What is scope? And what are block scope, global scope, and function scope?

## Overview
Scope in JavaScript defines the accessibility and visibility of variables, functions, and objects. It determines where variables can be accessed or modified and prevents naming conflicts. Understanding scope is fundamental for writing clean, maintainable JavaScript code and avoiding common bugs related to variable accessibility.

## What is Scope?

### Definition
Scope is the context in which variables are declared and accessible. It defines the "lifetime" and "visibility" of identifiers (variables, functions, objects) during program execution.

### Key Concepts

#### Lexical Scope (Static Scope)
- Determined at compile time based on code structure
- Variables accessible within their declaration's lexical context
- Nested functions have access to parent scope variables

#### Execution Context
- Dynamically created when code executes
- Each execution context has its own scope chain
- Manages variable environment and this binding

## Scope Chain

### How It Works
JavaScript uses a scope chain to resolve variable references:

1. **Local Scope**: Current execution context
2. **Parent Scope**: Immediately enclosing scope
3. **Global Scope**: Top-level scope
4. **Scope Resolution**: Moves outward until variable found or ReferenceError

```javascript
function outer() {
  const outerVar = 'outer';
  
  function middle() {
    const middleVar = 'middle';
    
    function inner() {
      const innerVar = 'inner';
      
      // Can access: innerVar, middleVar, outerVar, globalVar
      console.log(innerVar, middleVar, outerVar, globalVar);
    }
    
    inner();
    // Cannot access: innerVar
  }
  
  middle();
  // Cannot access: middleVar, innerVar
}

const globalVar = 'global';
outer();
```

## Types of Scope in JavaScript

### 1. Global Scope

#### Definition
Variables declared outside any function or block are in global scope.

#### Characteristics
- Accessible from anywhere in the program
- Persist for entire application lifetime
- Always available in global object (`window` in browsers)
- Considered "bad practice" to overuse

#### Examples

```javascript
// Global variable declaration
var globalVar = "I'm global";
let globalLet = "Also global";
const globalConst = "Constants too";

// Accessible from functions
function accessGlobal() {
  console.log(globalVar, globalLet, globalConst);
}

// Accessible from anywhere
console.log(globalVar); // "I'm global"

// Global objects (browsers)
window.globalVar; // Same as globalVar
globalThis.globalVar; // ES2020 universal global reference
```

#### Issues with Global Scope

```javascript
// Problem: Global pollution
var counter = 0;
function increment() {
  counter++;
}

// Another file/scope might accidentally override
counter = "overridden"; // No warning - hard to debug

// Solution: Encapsulation
const counterModule = (function() {
  let privateCounter = 0;
  
  return {
    increment: function() {
      privateCounter++;
      return privateCounter;
    },
    get: function() {
      return privateCounter;
    }
  };
})();

// Private counter protected from global interference
```

### 2. Function Scope (Local Scope)

#### Definition
Variables declared within a function are accessible only within that function.

#### Characteristics
- Created when function is executed
- Destroyed when function completes (unless closures)
- Arguments are also function-scoped
- Functions can access outer function's variables

#### Examples

```javascript
function calculateTax(income) {
  // income parameter is function-scoped
  let taxRate = 0.25; // Function-scoped variable
  var alternativeTax = income * 0.2; // Also function-scoped
  
  if (income > 50000) {
    let bonusTax = income * 0.05; // Block-scoped (ES6)
    var extraTax = income * 0.1; // Function-scoped (legacy behavior)
  }
  
  console.log(taxRate, alternativeTax); // ‚úÖ Accessible
  console.log(extraTax); // ‚úÖ Accessible (var leaked out)
  // console.log(bonusTax); // ‚ùå ReferenceError (let stayed in block)
  
  return income * taxRate;
}

calculateTax(60000);

// Variables not accessible outside
// console.log(taxRate); // ‚ùå ReferenceError
```

#### Function Scope vs var Hoisting

```javascript
function demonstrateHoisting() {
  console.log(variable); // undefined (hoisted but not initialized)
  var variable = "defined later";
  console.log(variable); // "defined later"
}

demonstrateHoisting();
```

### 3. Block Scope

#### Definition
Introduced in ES6 (let/const), variables declared in code blocks (if, for, while, etc.) are accessible only within that block.

#### Characteristics
- Uses `{ }` to define scope boundaries
- var declarations ignore block boundaries (function scope)
- let/const respect block boundaries
- Each iteration of loops gets its own scope

#### Examples

```javascript
// if block
if (true) {
  let blockVar = "I'm in a block";
  const blockConst = "Also in block";
  var leakedVar = "I'm everywhere"; // Ignores block
  
  console.log(blockVar, blockConst, leakedVar); // ‚úÖ All accessible here
}

// Outside the block
console.log(leakedVar); // ‚úÖ var still accessible
// console.log(blockVar); // ‚ùå ReferenceError
// console.log(blockConst); // ‚ùå ReferenceError

// Loop scope
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 0, 1, 2 (each has its own i)
}

// With var (problematic)
for (var j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100); // 3, 3, 3 (shared j)
}

// try/catch blocks
try {
  throw new Error("Test error");
} catch (error) {
  let errorMessage = error.message; // Scoped to catch block
  console.log(errorMessage); // ‚úÖ Accessible
}
```

#### Block Scope in Switch Statements

```javascript
const action = 'save';

switch (action) {
  case 'save':
    let formId = 'form-123';
    if (formId) {
      const submitData = { formId, data: 'content' };
      console.log(submitData); // ‚úÖ Block scoped
    }
    // console.log(submitData); // ‚ùå Outside block
    break;
    
  case 'delete':
    let itemId = 'item-456';
    break;
}

// Variables not accessible outside switch
// console.log(formId); // ‚ùå ReferenceError
```

## Temporal Dead Zone (TDZ)

### What is TDZ?
The period between variable declaration and initialization where accessing the variable throws a ReferenceError (only for let/const).

```javascript
// TDZ exists here
console.log(myVar); // ‚ùå ReferenceError: Cannot access before initialization
let myVar = "Initialized";

// Now accessible
console.log(myVar); // ‚úÖ "Initialized"

// TDZ doesn't apply to var
console.log(varVar); // ‚úÖ undefined (hoisted and initialized undefined)
var varVar = "Initialized";
```

### TDZ in Different Scopes

```javascript
function demonstrateTDZ() {
  console.log("Before function declaration");
  
  // TDZ starts here
  console.log(func); // ‚ùå ReferenceError (TDZ for let)
  console.log(varFunc); // ‚úÖ undefined (no TDZ for var)
  
  // End of TDZ for let
  let func = function() {};
  var varFunc = function() {};
  
  console.log(func); // ‚úÖ Accessible
  console.log(varFunc); // ‚úÖ Accessible
}

demonstrateTDZ();
```

## Closures and Scope

### Closures Preserve Lexical Scope

```javascript
function createCounter() {
  let count = 0; // Outer function scope
  
  return function() {
    count++; // Closure preserves access to count
    return count;
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1()); // 1 (separate scope)
console.log(counter1()); // 2 (preserved state)
console.log(counter2()); // 1 (separate scope)

// Complex closure example
function createBankAccount(initialBalance) {
  let balance = initialBalance; // Private state
  
  return {
    deposit: function(amount) {
      balance += amount;
      return balance;
    },
    
    withdraw: function(amount) {
      if (balance >= amount) {
        balance -= amount;
        return balance;
      }
      return "Insufficient funds";
    },
    
    getBalance: function() {
      return balance;
    }
  };
}

const account = createBankAccount(1000);
account.deposit(500); // 1500
account.withdraw(200); // 1300
console.log(account.getBalance()); // 1300
// balance variable is completely private!
```

## Module Scope (ES6 Modules)

### ES6 Module Scope

```javascript
// math.js
const PI = 3.14159;
let calculationCount = 0;

export function calculateArea(radius) {
  calculationCount++;
  return PI * radius * radius;
}

export function getCalculationCount() {
  return calculationCount;
}

// main.js
import { calculateArea, getCalculationCount } from './math.js';

calculateArea(5); // Accesses PI and calculationCount
console.log(getCalculationCount()); // 1

// PI and calculationCount are NOT in global scope
// console.log(PI); // ‚ùå ReferenceError
```

## Scope Best Practices

### 1. Prefer const and let over var
```javascript
// Good: Use const for immutable values
const API_BASE_URL = 'https://api.example.com';
const userConfig = { theme: 'dark' };

// Good: Use let for mutable values
let score = 0;
let playerPosition = { x: 0, y: 0 };

// Avoid: var causes unexpected behavior
var globalLeak = "Bad practice";
```

### 2. Avoid Global Pollution
```javascript
// Bad: Accidental global variables
function processData() {
  // Forgot "let" or "const"
  result = computeData(); // Creates global variable! üò±
}

// Good: Explicit declarations
function processData() {
  const result = computeData();
  return result;
}
```

### 3. Use Function Parameters Effectively
```javascript
// Good: Parameters are function-scoped
function calculate(options) {
  const { width, height, basePrice } = options;

  let total = basePrice;
  const area = width * height;
  
  if (area > 100) {
    const discount = 0.1; // Block-scoped
    total = total * (1 - discount);
  }
  
  // discount not accessible here
  return total;
}
```

### 4. Minimize Scope Chain Length
```javascript
// Avoid deep nesting that creates long scope chains
function complexFunction() {
  const level1Var = "outer";
  
  if (condition) {
    const level2Var = level1Var + "middle";
    
    if (anotherCondition) {
      const level3Var = level2Var + "inner";
      return process(level3Var); // 3 levels deep
    }
  }
}

// Better: Extract nested functionality
function complexFunction() {
  if (!condition || !anotherCondition) return;
  
  const result = "outer" + "middle" + "inner";
  return process(result); // All logic at top level
}
```

### 5. Use IIFE for Encapsulation
```javascript
// Immediately Invoked Function Expression (IIFE)
const Calculator = (function() {
  // Private scope
  let calculationHistory = [];
  
  function addToHistory(operation) {
    calculationHistory.push(operation);
  }
  
  // Public interface
  return {
    add: function(a, b) {
      const result = a + b;
      addToHistory(`${a} + ${b} = ${result}`);
      return result;
    },
    
    getHistory: function() {
      return calculationHistory;
    }
  };
})();

// Usage
Calculator.add(2, 3); // 5
console.log(Calculator.getHistory()); // ["2 + 3 = 5"]
// calculationHistory is completely private
```

## Debugging Scope Issues

### Common Scope Errors

#### ReferenceError
```javascript
// Variable doesn't exist in this scope
console.log(unknownVariable); // ReferenceError
```

```javascript
// Accessing variable before declaration (TDZ)
console.log(declaredLater); // ReferenceError
let declaredLater = "value";
```

```javascript
// Wrong scope or spelling
function sum(a, b) {
  const total = a + b;
  return totall; // ReferenceError: totall is not defined
}
```

#### Shadowing Issues
```javascript
let value = "global";

function shadowExample() {
  let value = "local"; // Shadows global variable
  
  function inner() {
    let value = "inner"; // Shadows both
    console.log(value); // "inner"
  }
  
  inner();
  console.log(value); // "local"
}

shadowExample();
console.log(value); // "global"
```

### Scope Debugging Tips

#### Use console.trace() for Scope Investigation
```javascript
function outer() {
  const outerVar = "outer";
  
  function inner() {
    const innerVar = "inner";
    
    // Log current scope chain
    console.trace("Current execution context");
    console.log("innerVar:", innerVar);
    console.log("outerVar:", outerVar);
  }
  
  inner();
}

outer();
// Output shows function call stack
```

#### Browser DevTools Scope Inspection
```javascript
// In browser developer tools
function inspectScope() {
  const localVar = "I'm local";
  debugger; // Pauses execution, allows scope inspection
  
  console.log(localVar);
}

inspectScope();
// Inspect "Scope" panel in DevTools to see variable scopes
```

## Advanced Scope Concepts

### eval() and Scope Pollution

```javascript
function avoidEval() {
  let safeVar = "safe";
  
  // Bad: eval executes in current scope
  eval("var dangerousVar = 'harmful'; console.log(safeVar);");
  
  console.log(dangerousVar); // Unexpected global scope pollution
  // eval created dangerousVar in containing scope
}

// Better: Avoid eval or use isolated contexts
(new Function("console.log('Isolated execution')"))();
```

### with Statement (Avoid)

```javascript
// with statement creates its own scope (deprecated, avoid)
// Changes object property access rules
const obj = { name: "John", age: 30 };

with (obj) {
  name = "Jane"; // obj.name = "Jane"
  age = 25;      // obj.age = 25
  newProp = "value"; // Creates global variable!
}

console.log(newProp); // "value" - unexpected global
```

## Key Takeaway
Scope in JavaScript defines variable accessibility and lifetime. Global scope makes variables accessible everywhere but should be minimized to prevent pollution. Function scope contains variables within function boundaries. Block scope (introduced with ES6) limits variables to `{}` blocks, providing better control and preventing accidental bugs. Understanding scope chain resolution, hoisting, and temporal dead zones is essential for writing predictable JavaScript code. Modern JavaScript development favors minimal global scope, proper use of let/const for block scoping, and encapsulated modules to manage complexity effectively.
