# What is a recursive function?

## Overview
A recursive function is a function that calls itself during its execution. Recursion is a programming technique where a problem is broken down into smaller, identical subproblems, and the function continuously calls itself until it reaches a base case (stopping condition).

## Basic Concept

### Recursion Definition
- A function that invokes itself directly or indirectly
- Solves problems by breaking them into smaller, similar problems
- Requires a base case to prevent infinite recursion

### Simple Example: Countdown
```javascript
function countdown(n) {
  if (n <= 0) {  // Base case
    console.log('Done!');
    return;
  }
  
  console.log(n);
  countdown(n - 1);  // Recursive call
}

countdown(3);
// Output: 3 → 2 → 1 → Done!
```

## Anatomy of a Recursive Function

### Essential Components
Every recursive function needs:

1. **Base Case**: Condition that stops recursion
2. **Recursive Case**: The self-call that makes progress toward the base case
3. **Work**: The computation done in each call

### Example: Factorial
```javascript
function factorial(n) {
  // Base case
  if (n === 0 || n === 1) {
    return 1;
  }
  
  // Recursive case with work
  return n * factorial(n - 1);
}

// Work: multiply by current number
// Recursive call: factorial(n-1)
// Base case: n === 0 or n === 1

console.log(factorial(5)); // 120 (5! = 5 × 4 × 3 × 2 × 1 = 120)
```

## Common Recursion Patterns

### 1. Linear Recursion (Single Call)
```javascript
function printArray(arr, index = 0) {
  if (index >= arr.length) return; // Base case
  
  console.log(arr[index]); // Work
  printArray(arr, index + 1); // Single recursive call
}

printArray([1, 2, 3, 4, 5]);
```

### 2. Binary Recursion (Two Calls)
```javascript
function fibonacci(n) {
  if (n <= 1) return n; // Base cases
  
  // Two recursive calls
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8 (0, 1, 1, 2, 3, 5, 8)
```

### 3. Tail Recursion (Call at End)
```javascript
function sumArray(arr, index = 0, sum = 0) {
  if (index >= arr.length) return sum; // Base case
  
  // Recursive call at the end
  return sumArray(arr, index + 1, sum + arr[index]);
}

console.log(sumArray([1, 2, 3, 4, 5])); // 15
```

### 4. Mutual Recursion (Functions Call Each Other)
```javascript
function isEven(n) {
  if (n === 0) return true;
  if (n === 1) return false;
  
  return isOdd(n - 1); // Calls isOdd
}

function isOdd(n) {
  if (n === 0) return false;
  if (n === 1) return true;
  
  return isEven(n - 1); // Calls isEven
}

console.log(isEven(4)); // true
console.log(isOdd(5));  // true
```

## Real-World Applications

### 1. Traversing Tree Structures
```javascript
const fileSystem = {
  name: 'root',
  children: [
    {
      name: 'folder1',
      children: [
        { name: 'file1.txt', children: null },
        { name: 'file2.txt', children: null }
      ]
    },
    {
      name: 'folder2',
      children: [
        { name: 'file3.txt', children: null }
      ]
    }
  ]
};

function printFileSystem(node, indent = '') {
  console.log(indent + node.name);
  
  if (node.children) {
    node.children.forEach(child => {
      printFileSystem(child, indent + '  '); // Recursive call
    });
  }
}

printFileSystem(fileSystem);
// Output:
// root
//   folder1
//     file1.txt
//     file2.txt
//   folder2
//     file3.txt
```

### 2. Solving Mazes (Path Finding)
```javascript
function findPath(maze, startRow, startCol, endRow, endCol, path = []) {
  const rows = maze.length;
  const cols = maze[0].length;
  
  // Check boundaries and walls
  if (startRow < 0 || startRow >= rows || 
      startCol < 0 || startCol >= cols || 
      maze[startRow][startCol] === 1) { // 1 = wall
    return false;
  }
  
  // Check if we found the end
  if (startRow === endRow && startCol === endCol) {
    return true;
  }
  
  // Mark as visited
  maze[startRow][startCol] = 1;
  
  // Try all four directions
  if (findPath(maze, startRow - 1, startCol, endRow, endCol, path) ||
      findPath(maze, startRow, startCol + 1, endRow, endCol, path) ||
      findPath(maze, startRow + 1, startCol, endRow, endCol, path) ||
      findPath(maze, startRow, startCol - 1, endRow, endCol, path)) {
    
    path.unshift([startRow, startCol]);
    return true;
  }
  
  return false;
}
```

### 3. Parsing HTML/DOM Traversal
```javascript
function findElementsByClassName(element, className, results = []) {
  // Check current element
  if (element.classList && element.classList.contains(className)) {
    results.push(element);
  }
  
  // Recursively check children
  if (element.children) {
    Array.from(element.children).forEach(child => {
      findElementsByClassName(child, className, results);
    });
  }
  
  return results;
}

// Usage
const allButtons = findElementsByClassName(document.body, 'btn');
console.log(allButtons);
```

### 4. Sorting Algorithms (Merge Sort)
```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr; // Base case
  
  const middle = Math.floor(arr.length / 2);
  const left = arr.slice(0, middle);
  const right = arr.slice(middle);
  
  // Recursive calls to sort subarrays
  const sortedLeft = mergeSort(left);
  const sortedRight = mergeSort(right);
  
  return merge(sortedLeft, sortedRight);
}

function merge(left, right) {
  const result = [];
  let leftIndex = 0, rightIndex = 0;
  
  // Merge two sorted arrays
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex++]);
    } else {
      result.push(right[rightIndex++]);
    }
  }
  
  // Add remaining elements
  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}

console.log(mergeSort([64, 34, 25, 12, 22, 11, 90]));
// Output: [11, 12, 22, 25, 34, 64, 90]
```

## Recursive vs Iterative Approaches

### When to Use Recursion
- **Natural fit**: Problems that decompose naturally (trees, directories)
- **Cleaner code**: More readable than iterative versions
- **Mathematical problems**: Factorial, Fibonacci, etc.
- **Search algorithms**: Depth-first search, backtracking

### When to Use Iteration
- **Performance**: Recursive calls have overhead
- **Stack overflow**: Deep recursion can crash the program
- **Memory**: Each call adds to call stack
- **Simple loops**: Straightforward iteration is clearer

### Converting Between Approaches

```javascript
// Recursive factorial
function factorialRecursive(n) {
  if (n <= 1) return 1;
  return n * factorialRecursive(n - 1);
}

// Iterative factorial
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

console.log(factorialRecursive(5)); // 120
console.log(factorialIterative(5));  // 120
```

## Common Recursion Pitfalls

### 1. Missing Base Case (Infinite Recursion)
```javascript
function badFunction() {
  badFunction(); // No base case - stack overflow!
}
```

### 2. Wrong Base Case Position
```javascript
function misplacedBaseCase(n) {
  console.log(n);
  misplacedBaseCase(n - 1); // Too late - will print -1, -2, -3...
  
  if (n === 0) return; // Base case never reached!
}
```

### 3. Exponential Time Complexity (Poor Performance)
```javascript
function badFibonacci(n) {
  if (n <= 1) return n;
  return badFibonacci(n - 1) + badFibonacci(n - 2);
  // Each call makes 2 more calls - exponential!
}

badFibonacci(10); // Takes hundreds of calls
```

### 4. Using Global State Incorrectly
```javascript
let counter = 0; // Shared across recursive calls

function countUp(n) {
  if (n === 0) return;
  
  counter++; // Modifies shared state
  console.log(counter);
  
  countUp(n - 1);
}

countUp(3); // 1, 2, 3
countUp(2); // 4, 5 (unexpected!)
```

## Advanced Recursion Techniques

### 1. Memoization (Caching Results)
```javascript
function memoize(fn) {
  const cache = {};
  
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache[key]) return cache[key];
    
    cache[key] = fn.apply(this, args);
    return cache[key];
  };
}

const memoizedFib = memoize(function fibonacci(n) {
  if (n <= 1) return n;
  return memoizedFib(n - 1) + memoizedFib(n - 2);
});

console.log(memoizedFib(10)); // Much faster on second call
```

### 2. Continuation-Passing Style (CPS)
```javascript
function factorialCPS(n, continuation) {
  if (n === 0 || n === 1) {
    return continuation(1);
  }
  
  const newContinuation = (result) => continuation(n * result);
  factorialCPS(n - 1, newContinuation);
}

factorialCPS(5, (result) => console.log(result)); // 120
```

### 3. Trampolining (Avoiding Stack Overflow)
```javascript
function trampoline(fn) {
  return function trampolined(...args) {
    let result = fn(...args);
    
    while (typeof result === 'function') {
      result = result();
    }
    
    return result;
  };
}

function factorialThunk(n, result = 1) {
  if (n <= 1) return result;
  
  return () => factorialThunk(n - 1, n * result); // Return thunk
}

const trampolinedFactorial = trampoline(function(n) {
  return factorialThunk(n);
});

console.log(trampolinedFactorial(100000)); // No stack overflow
```

## Browser JavaScript Considerations

### Call Stack Limits
```javascript
function testStackDepth(n) {
  if (n <= 0) return;
  testStackDepth(n - 1); // Most browsers limit to ~10,000-50,000 calls
}

testStackDepth(10000); // May cause stack overflow
```

### Tail Call Optimization (Promise)
ECMAScript 6 specification promises tail call optimization, but support is limited:

```javascript
// In the future (if fully implemented):
function factorial(n, result = 1) {
  if (n <= 1) return result;
  
  // Tail call - should be optimized to avoid stack growth
  return factorial(n - 1, n * result);
}
```

## Debugging Recursive Functions

### 1. Add Logging
```javascript
function debugFactorial(n) {
  console.log(`Calling factorial(${n})`);
  
  if (n <= 1) {
    console.log(`Base case: factorial(${n}) = 1`);
    return 1;
  }
  
  const result = n * debugFactorial(n - 1);
  console.log(`factorial(${n}) = ${result}`);
  
  return result;
}

debugFactorial(4);
// Output:
// Calling factorial(4)
// Calling factorial(3)
// Calling factorial(2)
// Calling factorial(1)
// Base case: factorial(1) = 1
// factorial(2) = 2
// factorial(3) = 6
// factorial(4) = 24
```

### 2. Use Browser DevTools
- Set breakpoints in recursive functions
- Watch the call stack grow and shrink
- Use "async" checkbox to see return flow

## Performance Optimization

### 1. Base Case First
```javascript
// Good - base case first, reduces stack depth for average case
function binarySearch(arr, target, start = 0, end = arr.length - 1) {
  if (start > end) return -1; // Base case first
  
  const mid = Math.floor((start + end) / 2);
  
  if (arr[mid] === target) return mid;
  if (arr[mid] > target) return binarySearch(arr, target, start, mid - 1);
  return binarySearch(arr, target, mid + 1, end);
}
```

### 2. Accumulator Pattern
```javascript
// Tail recursive version (better performance)
function factorialAccumulator(n, accumulator = 1) {
  if (n <= 1) return accumulator;
  
  return factorialAccumulator(n - 1, n * accumulator);
  // Accumulator built up, no multiplication on return
}

// Stack-intensive version
function factorialMultiply(n) {
  if (n <= 1) return 1;
  
  return n * factorialMultiply(n - 1); // Must wait for recursion to finish
}
```

## Key Takeaway
Recursive functions provide elegant solutions for problems that can be broken down into smaller, identical subproblems. While powerful and often more intuitive than iterative approaches, recursion requires careful handling of base cases and can be prone to stack overflow errors. Understanding when to use recursion versus iteration is crucial for writing efficient JavaScript applications, and advanced techniques like memoization can significantly improve performance.
