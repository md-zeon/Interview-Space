# What is a function in Javascript ?

## Overview
In JavaScript, functions are first-class citizens that serve as the foundation for code organization, reusability, and behavior definition. Unlike many traditional programming languages, JavaScript treats functions as objects, enabling powerful functional programming patterns and dynamic code execution.

## Basic Definition

### What is a Function?
- **Core Building Block**: Executable units that encapsulate logic and can be invoked repeatedly
- **Objects**: Functions are a special type of object with additional callable capabilities
- **First-Class Citizens**: Can be assigned to variables, passed as arguments, returned from other functions
- **Scope Creaters**: Generate their own execution contexts with variable scoping

```javascript
// Function as a value
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Function invocation
console.log(greet("Alice")); // "Hello, Alice!"

// Functions have properties
console.log(typeof greet); // "function"
greet.description = "A simple greeting function";
console.log(greet.description); // "A simple greeting function"
```

## Function Declaration Types

### 1. Function Declaration (Function Statement)
```javascript
// Hoisted - can be called before declaration
function greet(name) {
  return `Hello, ${name}!`;
}

// Usage anywhere in the code
console.log(greet("World")); // "Hello, World!"

// Properties
console.log(greet.length); // 1 (number of parameters)
console.log(greet.name);   // "greet" (function name)
```

### 2. Function Expression
```javascript
// Assigned to a variable
const greet = function(name) {
  return `Hello, ${name}!`;
};

// Anonymous or named
const namedGreet = function user(name) {
  return `Hello, ${name}!`;
};

// Arrow function expression
const arrowGreet = (name) => `Hello, ${name}!`;

// Usage (declarations must come before usage)
console.log(arrowGreet("Bob")); // "Hello, Bob!"
```

### 3. Arrow Functions (ES6+)
```javascript
// Compact syntax
const add = (a, b) => a + b;

// Single parameter (parentheses optional)
const square = x => x * x;

// Multiple statements require braces and return
const describe = (name, age) => {
  const description = `${name} is ${age} years old.`;
  return description.toUpperCase();
};

// No arguments
const getTimestamp = () => new Date().toISOString();

// Returning objects (wrap in parentheses)
const createUser = (name, email) => ({
  id: Math.random(),
  name: name,
  email: email
});
```

### 4. Function Constructor (Not Recommended)
```javascript
// Code as string (security risk, slow)
const add = new Function('a', 'b', 'return a + b;');

// Avoid using Function constructor
console.log(add(5, 3)); // 8
```

### 5. Method Definition (ES6+)
```javascript
const calculator = {
  // Method shorthand
  add(a, b) {
    return a + b;
  },

  // Traditional method
  subtract: function(a, b) {
    return a - b;
  }
};

console.log(calculator.add(5, 3)); // 8
console.log(calculator.subtract(5, 3)); // 2
```

## Function Parameters and Arguments

### Parameters vs Arguments
```javascript
// Parameters (definition time)
function greet(firstName, lastName, age) {
  return `Hello, ${firstName} ${lastName}. You are ${age} years old.`;
}

// Arguments (call time)
greet("John", "Doe", 30); // arguments: "John", "Doe", 30

// Parameters become local variables
function sum(a, b) {
  console.log(typeof a, typeof b); // Both numbers
  return a + b;
}

sum(5, 10);
```

### Default Parameters (ES6+)
```javascript
function greet(name, greeting = "Hello") {
  return `${greeting}, ${name}!`;
}

console.log(greet("Alice"));        // "Hello, Alice!"
console.log(greet("Bob", "Hi"));    // "Hi, Bob!"

// Expression as default
function createUser(name, verified = false, timestamp = Date.now()) {
  return { name, verified, timestamp };
}
```

### Rest Parameters (ES6+)
```javascript
function sumAll(first, second, ...other) {
  console.log(first, second);  // 1, 2
  console.log(other);          // [3, 4, 5, 6]
  return [first, second, ...other].reduce((sum, num) => sum + num, 0);
}

console.log(sumAll(1, 2, 3, 4, 5, 6)); // 21

// Rest in arrow functions
const collect = (...items) => items;
console.log(collect(1, 2, 3)); // [1, 2, 3]
```

### Arguments Object (Legacy)
```javascript
function oldStyleFunction() {
  console.log(arguments); // Array-like object: {0: 1, 1: 2, 2: 3}
  console.log(arguments.length); // 3
  
  // Convert to real array
  const args = Array.from(arguments);
  return args.map(x => x * 2);
}

console.log(oldStyleFunction(1, 2, 3)); // [2, 4, 6]
```

## Function Execution Context

### Global Context
```javascript
// Top-level code runs in global context
console.log(this); // Window (in browsers)

// Global function
function globalFunction() {
  console.log(this); // Also global object
}
```

### Function Context
```javascript
function regularFunction() {
  console.log(this); // Global object or undefined (strict mode)
}

const obj = {
  method() {
    console.log(this); // Points to obj
  }
};
```

### Arrow Function Context
```javascript
const obj = {
  data: [1, 2, 3],

  regularMethod() {
    // this === obj
    this.data.forEach(function(item) {
      // this === global/undefined (lexical this lost)
      console.log(this);
    });
  },

  arrowMethod() {
    // this === obj
    this.data.forEach((item) => {
      // this === obj (lexical this preserved)
      console.log(this);
    });
  }
};
```

## Hoisting Behavior

### Function Declarations are Hoisted
```javascript
// Called before declaration - works!
console.log(declarationResult()); // "Declared function called"

function declarationResult() {
  return "Declared function called";
}
```

### Function Expressions are Not Hoisted
```javascript
// Called before declaration - error!
console.log(expressionResult()); // ReferenceError

const expressionResult = function() {
  return "Expression function called";
};
```

### Variable Hoisting
```javascript
console.log(hoisted); // undefined (var hoisted but not initialized)
var hoisted = "Declared later";

console.log(notHoisted); // ReferenceError (let not hoisted)
let notHoisted = "Temporal dead zone";
```

## Return Values

### Returning Values
```javascript
function calculateTax(price, rate) {
  const tax = price * rate;
  return tax; // Function returns tax value
}

function formatPrice(price) {
  return `$${price.toFixed(2)}`;
}

// Chaining returns
function getFormattedTax(price, rate) {
  const tax = calculateTax(price, rate);
  return formatPrice(tax); // Returns formatted value
}

console.log(getFormattedTax(100, 0.08)); // "$8.00"
```

### Implicit Return (Arrow Functions)
```javascript
// Single expression - implicitly returned
const double = x => x * 2;
const isEven = x => x % 2 === 0;

// Multi-line - must use return
const calculateArea = (width, height) => {
  if (width <= 0 || height <= 0) {
    return null;
  }
  return width * height;
};
```

### Returning Objects
```javascript
// Need parentheses for object literal return
const createUser = (name, email) => ({
  name: name,
  email: email,
  created: new Date()
});

// Wrong (missing parentheses - returns undefined)
const wrongUser = (name, email) => {
  name: name,
  email: email
}; // JavaScript thinks name: name is a labeled statement

console.log(createUser("John", "john@example.com").created); // Date object
```

### No Return Statement
```javascript
function logMessage(message) {
  console.log(message);
  // No return - returns undefined
}

const result = logMessage("Hello"); // undefined
```

## Functions as Objects

### Functions Have Properties
```javascript
function example(param) {
  return param * 2;
}

// Built-in properties
console.log(example.length);     // 1 (parameter count)
console.log(example.name);       // "example" (function name)

// Can add custom properties
example.description = "Doubles the input";
example.version = "1.0";

console.log(example.description); // "Doubles the input"
```

### Functions Have Methods
```javascript
function add(a, b) {
  return a + b;
}

// .call() - invoke with specific this
console.log(add.call(null, 5, 3)); // 8

// .apply() - invoke with array of arguments
console.log(add.apply(null, [5, 3])); // 8

// .bind() - create bound function
const addToFive = add.bind(null, 5);
console.log(addToFive(3)); // 8 (adds 5 + 3)
```

### Functions as Constructors
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  return `Hello, I'm ${this.name}`;
};

// Constructor pattern
const alice = new Person("Alice", 30);
console.log(alice.greet()); // "Hello, I'm Alice"

// Important: Don't forget 'new'!
const bob = Person("Bob", 25); // Creates global variables
console.log(window.name, window.age); // "Bob", 25
```

## Function Scope and Closures

### Lexical Scope
```javascript
function outer() {
  const outerVar = "I'm outer";

  function inner() {
    const innerVar = "I'm inner";
    console.log(outerVar); // Accessible (lexical scope)
    console.log(innerVar); // Accessible
  }

  inner();
  // console.log(innerVar); // ReferenceError (not in scope)
}

outer();
```

### Closure Formation
```javascript
function counterFactory() {
  let count = 0;

  return function() {
    count++;
    return count;
  };
}

const counter = counterFactory(); // counter is a closure
console.log(counter()); // 1
console.log(counter()); // 2

// New closure - independent count
const anotherCounter = counterFactory();
console.log(anotherCounter()); // 1 (different count variable)
```

## Advanced Function Concepts

### IIFE (Immediately Invoked Function Expression)
```javascript
// Anonymous IIFE
(function() {
  const privateVar = "I'm private";
  console.log(privateVar); // "I'm private"
})();

// console.log(privateVar); // ReferenceError (scoped to IIFE)

// Named IIFE (for debugging)
(async function loadData() {
  const data = await fetch('/api/data');
  console.log(data);
})();
```

### Factory Functions
```javascript
function createGreeter(language) {
  const greeting = language === 'es' ? 'Hola' : 'Hello';

  return function(name) {
    return `${greeting}, ${name}!`;
  };
}

const englishGreeter = createGreeter('en');
const spanishGreeter = createGreeter('es');

console.log(englishGreeter("John")); // "Hello, John!"
console.log(spanishGreeter("Maria")); // "Hola, Maria!"
```

### Higher-Order Functions
```javascript
// Functions that take functions as arguments
function runTwice(func) {
  func();
  func();
}

runTwice(() => console.log("Running!")); // Prints twice

// Functions that return functions
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = multiplier(2);
const triple = multiplier(3);
console.log(double(5)); // 10
console.log(triple(5)); // 15
```

## Generator Functions (ES6+)

### Basic Generator
```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = numberGenerator();

console.log(generator.next()); // {value: 1, done: false}
console.log(generator.next()); // {value: 2, done: false}
console.log(generator.next()); // {value: 3, done: false}
console.log(generator.next()); // {value: undefined, done: true}
```

### Infinite Generator
```javascript
function* fibonacciGenerator() {
  let a = 0, b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

const fib = fibonacciGenerator();
console.log(fib.next().value); // 0
console.log(fib.next().value); // 1
console.log(fib.next().value); // 1
console.log(fib.next().value); // 2
```

## Async Functions (ES8+)

### Async Function Basics
```javascript
async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    return user;
  } catch (error) {
    throw new Error(`Failed to fetch user: ${error.message}`);
  }
}

// Usage
fetchUser(123)
  .then(user => console.log(user))
  .catch(error => console.error(error));

// Or with async/await
async function displayUser() {
  try {
    const user = await fetchUser(123);
    console.log(user);
  } catch (error) {
    console.error(error);
  }
}
```

### Async Arrow Functions
```javascript
const fetchData = async (url) => {
  const response = await fetch(url);
  return await response.json();
};

// Equivalent async method
const api = {
  async getUsers() {
    return await fetchData('/api/users');
  }
};
```

## Function Performance Considerations

### Recursive Functions and Stack Overflow
```javascript
// Risky - could cause stack overflow
function riskyRecursion(n) {
  if (n <= 0) return 0;
  return n + riskyRecursion(n - 1);
}

riskyRecursion(10000); // StackOverflowError

// Solutions: Use iterative approach or convert to tail recursion
function safeIteration(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}
```

### Function Context and Performance
```javascript
const obj = {
  data: [1, 2, 3],

  // Avoid in loops or frequently called functions
  slowMethod() {
    this.data.forEach(function(item) {
      // 'this' undefined - need to bind
    }.bind(this));
  },

  // Better
  fastMethod() {
    const self = this;
    this.data.forEach(function(item) {
      // Use self reference
    });
  },

  // Best
  bestMethod() {
    this.data.forEach((item) => {
      // Arrow function captures lexical this
    });
  }
};
```

## Key Takeaway
Functions in JavaScript are powerful, flexible objects that can be declared in multiple ways (declarations, expressions, arrows), support various parameter patterns (default, rest), and create their own execution contexts with closure capabilities. Understanding the different function types, their scoping rules, and how they handle the `this` keyword is fundamental for effective JavaScript programming. Functions enable code reuse, abstraction, and the powerful paradigms of functional programming while remaining simple to use for basic tasks.
