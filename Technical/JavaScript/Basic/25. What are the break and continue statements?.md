# What are the break and continue statements?

## Overview
The `break` and `continue` statements are control flow statements in JavaScript that alter the execution of loops and switch statements. They provide mechanisms to exit loops early or skip iterations, enabling more efficient and readable code in scenarios where immediate exits or selective processing are needed.

## The `break` Statement

### What is `break`?
`break` terminates the execution of the nearest enclosing loop or switch statement and transfers control to the statement immediately following the terminated statement.

### Basic Syntax
```javascript
// In loops
break;

// Labeled break
labelName: break labelName;

// In switch statements
switch (expression) {
  case value1:
    // code
    break; // exits switch
}
```

### `break` in Loops

#### Basic Loop Exit
```javascript
// Exit when target is found
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let target = 7;
let found = false;

for (let i = 0; i < numbers.length; i++) {
  console.log(`Checking: ${numbers[i]}`);
  
  if (numbers[i] === target) {
    found = true;
    break; // Exit loop immediately
  }
}

console.log(`Target ${target} found: ${found}`);
// Output: Checking: 1, Checking: 2, ..., Checking: 7, Target 7 found: true
```

#### Breaking Out of Nested Loops
```javascript
// Label for nested loops
outerLoop: for (let i = 0; i < 3; i++) {
  console.log(`Outer loop: ${i}`);
  
  for (let j = 0; j < 3; j++) {
    console.log(`  Inner loop: ${j}`);
    
    if (i === 1 && j === 1) {
      console.log('Breaking out of both loops!');
      break outerLoop; // Breaks out of labeled loop
    }
  }
}

// Output:
// Outer loop: 0
//   Inner loop: 0
//   Inner loop: 1
//   Inner loop: 2
// Outer loop: 1
//   Inner loop: 0
//   Inner loop: 1
//   Breaking out of both loops!
```

### `break` in Switch Statements

#### Basic Switch with Break
```javascript
const day = 'monday';

switch (day) {
  case 'monday':
    console.log('Start of work week');
    break; // Exit switch - prevents fallthrough
    
  case 'tuesday':
    console.log('Second day');
    break;
    
  case 'wednesday':
    console.log('Middle of week');
    break;
    
  default:
    console.log('Weekend or unknown day');
}

// Without break, execution would continue to next case (fallthrough)
```

#### Intentional Fallthrough (No Break)
```javascript
const grade = 'B';

switch (grade) {
  case 'A':
    console.log('Excellent');
    // No break - intentional fallthrough
  case 'B':
    console.log('Good'); 
    // No break - intentional fallthrough
  case 'C':
    console.log('Satisfactory');
    break; // Stop here
    
  default:
    console.log('Needs improvement');
}

// Output for 'B': Good, Satisfactory
```

## The `continue` Statement

### What is `continue`?
`continue` skips the rest of the current iteration of a loop and immediately begins the next iteration.

### Basic Syntax
```javascript
continue;
// or with label
continue labelName;
```

### `continue` in Loops

#### Skipping Iterations
```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Print only even numbers
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 !== 0) {
    continue; // Skip odd numbers
  }
  
  console.log(`${numbers[i]} is even`);
}

// Output: 2 is even, 4 is even, ..., 10 is even
```

#### Continue in While Loops
```javascript
let vegetables = ['carrot', 'lettuce', 'tomato', 'onion', 'broccoli'];
let i = 0;

while (i < vegetables.length) {
  if (vegetables[i] === 'onion') {
    console.log('Skipping onion (allergies!)');
    i++; // Don't forget to increment!
    continue;
  }
  
  console.log(`Eating ${vegetables[i]}`);
  i++;
}

// Output:
// Eating carrot
// Eating lettuce  
// Eating tomato
// Skipping onion (allergies!)
// Eating broccoli
```

#### Continue in Nested Loops
```javascript
for (let i = 1; i <= 3; i++) {
  console.log(`Outer: ${i}`);
  
  for (let j = 1; j <= 3; j++) {
    if (j === 2) {
      continue; // Skip inner loop iteration when j === 2
    }
    
    console.log(`  Inner: ${i}-${j}`);
  }
}

// Output:
// Outer: 1
//   Inner: 1-1
//   Inner: 1-3
// Outer: 2
//   Inner: 2-1
//   Inner: 2-3
// Outer: 3
//   Inner: 3-1  
//   Inner: 3-3
```

#### Labeled Continue
```javascript
outerLoop: for (let i = 0; i < 3; i++) {
  console.log(`Outer iteration: ${i}`);
  
  for (let j = 0; j < 3; j++) {
    if (j === 1) {
      continue outerLoop; // Skip to next outer loop iteration
    }
    
    console.log(`  Inner: ${i}-${j}`);
  }
}

// Output:
// Outer iteration: 0
//   Inner: 0-0
// Outer iteration: 1
//   Inner: 1-0
// Outer iteration: 2
//   Inner: 2-0
```

## Comparison: `break` vs `continue`

| Aspect | `break` | `continue` |
|--------|---------|------------|
| **Function** | Exits the loop entirely | Skips current iteration, continues loop |
| **When to Use** | Found what we're looking for | Want to skip specific items but continue processing |
| **Loop Completion** | Loop stops immediately | Loop continues with next iteration |
| **Common Use Case** | Early termination search | Filtering while processing |

### Example Comparison

#### `break` Example
```javascript
// Search for first admin user
const users = [
  { name: 'Alice', role: 'user' },
  { name: 'Bob', role: 'user' },
  { name: 'Charlie', role: 'admin' },
  { name: 'David', role: 'user' }
];

let adminUser = null;
for (let user of users) {
  if (user.role === 'admin') {
    adminUser = user;
    break; // Found admin, no need to check rest
  }
}

console.log(adminUser); // { name: 'Charlie', role: 'admin' }
```

#### `continue` Example
```javascript
// Process valid scores, skip invalid ones
const scores = [85, -5, 92, 78, 105, 67];
const validScores = [];

for (let score of scores) {
  if (score < 0 || score > 100) {
    continue; // Skip invalid scores
  }
  
  validScores.push(score);
}

console.log(validScores); // [85, 92, 78, 67]
```

## Practical Applications

### Loop Optimization
```javascript
// Processing large dataset with premature exit
function findUserByEmail(users, email) {
  for (let user of users) {
    if (user.email === email) {
      return user; // Early return instead of break
    }
  }
  
  return null; // User not found
}

// Using break (less optimal)
function findUserById(users, id) {
  let foundUser = null;
  
  for (let user of users) {
    if (user.id === id) {
      foundUser = user;
      break; // Could return instead
    }
  }
  
  return foundUser;
}
```

### Input Validation
```javascript
function validateDataEntries(entries) {
  const errors = [];
  
  for (let entry of entries) {
    // Skip empty entries
    if (!entry.trim()) {
      continue;
    }
    
    // Validate each entry
    if (!isValidEntry(entry)) {
      errors.push(`Invalid entry: ${entry}`);
      break; // Stop at first error
    }
    
    processEntry(entry);
  }
  
  return errors;
}
```

### Array Processing with Conditions
```javascript
function processOrders(orders) {
  for (let order of orders) {
    // Skip completed orders
    if (order.status === 'completed') {
      continue;
    }
    
    // Stop processing if urgent order found
    if (order.priority === 'urgent' && order.status === 'pending') {
      processUrgentOrder(order);
      break;
    }
    
    // Process normal orders
    processNormalOrder(order);
  }
}
```

## Performance Considerations

### `break` in Long Loops
```javascript
// Efficient: break when condition met
for (let i = 0; i < array.length; i++) {
  if (array[i].isTarget) {
    processTarget(array[i]);
    break; // Don't waste time checking rest of array
  }
}
```

### `continue` for Filtering
```javascript
// More efficient than collecting and filtering
for (let i = 0; i < largeArray.length; i++) {
  if (largeArray[i].shouldSkip) {
    continue; // Process less items
  }
  
  processItem(largeArray[i]);
}

// Alternative (less efficient)
const filtered = largeArray.filter(item => !item.shouldSkip);
filtered.forEach(processItem);
```

### Avoid Nested Breaks
```javascript
// Hard to maintain
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    if (someCondition) {
      flag = true;
      break; // Only breaks inner loop
    }
  }
  if (flag) break; // Need additional flag
}

// Better: Early return or labeled break
function processGrid(grid) {
  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j].isTarget) {
        return [i, j]; // Clean exit
      }
    }
  }
}
```

## Common Pitfalls

### Forgetting to Control Index in `continue`
```javascript
// While loop with continue - easy mistake
let i = 0;
while (i < 10) {
  if (i % 3 === 0) {
    continue; // Index not incremented!
    // Infinite loop!
  }
  
  console.log(i);
  i++;
}

// Fix: Increment before continue
let i = 0;
while (i < 10) {
  if (i % 3 === 0) {
    i++; // Increment before continue
    continue;
  }
  
  console.log(i); // Will print 1, 2, 4, 5, 7, 8
  i++;
}
```

### Misusing `break` in Switch with Loops
```javascript
switch (command) {
  case 'exit':
    break; // Breaks switch, not while loop!
    
  case 'process':
    if (shouldStop) {
      break; // Still breaks switch only
    }
    // process...
    break;
}

// To break while loop, use labels or return
loopLabel: while (condition) {
  switch (command) {
    case 'exit':
      break loopLabel; // Breaks the while loop
  }
}
```

### Using `break`/`continue` with async code
```javascript
// break/continue don't work with forEach
[1, 2, 3, 4, 5].forEach(num => {
  if (num === 3) {
    // break; // SyntaxError: illegal break statement
    // continue; // SyntaxError: illegal continue statement
  }
  
  console.log(num);
});

// Instead, use for...of or traditional for loops
for (let num of [1, 2, 3, 4, 5]) {
  if (num === 3) continue;
  console.log(num);
}
```

## Best Practices

### 1. Use Early Returns Instead of `break` When Possible
```javascript
// Better than using break in function
function findElement(array, target) {
  for (let element of array) {
    if (matchesCriteria(element, target)) {
      return element; // Clean and clear
    }
  }
  
  return null;
}

// When break makes sense
function processWithBreak(array) {
  let result = null;
  
  for (let item of array) {
    if (meetsCondition(item)) {
      result = process(item);
      break; // Multiple exit points, but sometimes necessary
    }
  }
  
  return result;
}
```

### 2. Prefer `continue` for Simple Filtering
```javascript
// Clear intent
for (let user of users) {
  if (user.isSuspended) continue;
  if (user.isDeleted) continue;
  
  // Process active users
  sendNotification(user);
}
```

### 3. Use Labels Sparingly
```javascript
// Labels can make code hard to follow
// Prefer restructuring over labels when possible

outer: for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    if (condition) break outer; // Sometimes necessary
  }
}
```

### 4. Document Intent
```javascript
// Explain why you're breaking or continuing
for (let item of shoppingCart) {
  if (item.quantity <= 0) {
    console.log(`Skipping invalid item: ${item.name}`);
    continue; // Document the reason
  }
  
  if (outOfStock.includes(item.id)) {
    break; // Stop processing - user must review cart
  }
  
  processOrder(item);
}
```

## Alternatives to `break`/`continue`

### Array Methods Instead of Loops
```javascript
// Instead of for loop with break
const users = [...];
const firstAdult = users.find(user => user.age >= 18);

// Instead of for loop with continue
const visiblePosts = posts.filter(post => !post.hidden);
```

### Early Returns
```javascript
function processUsers(users, maxCount) {
  if (!users.length) return []; // Early return instead of break
  
  const processed = [];
  
  for (let user of users) {
    if (processed.length >= maxCount) {
      return processed; // Early return instead of break
    }
    
    if (!shouldProcess(user)) continue; // Still useful for simple skips
    
    processed.push(processUser(user));
  }
  
  return processed;
}
```

## Key Takeaway
`break` exits the current loop or switch statement entirely, useful for early termination when a condition is met or to prevent unnecessary processing. `continue` skips the current iteration and moves to the next one, ideal for filtering items while continuing the loop's work. Both provide important control flow capabilities for efficient iteration, but should be used judiciously to maintain code readability. When possible, prefer cleaner alternatives like early returns or array methods for better code structure.
