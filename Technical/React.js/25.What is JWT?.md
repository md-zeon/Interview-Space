# What is JWT?

JSON Web Token (JWT) is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object. It is commonly used for authentication and information exchange in web applications, particularly single-page applications (SPAs) like those built with React.

## What is JWT?

JWT is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling digital signing or integrity protection of the contents.

## JWT Structure

A JWT consists of three parts separated by dots (`.`):

### 1. Header
Contains metadata about the type of token and signing algorithm:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- `alg`: The signing algorithm (HS256, RS256, ES256, etc.)
- `typ`: The token type (usually "JWT")

The header is Base64Url encoded.

### 2. Payload
Contains the claims or data being transmitted:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "role": "admin"
}
```

**Common JWT Claims:**
- `sub`: Subject (user ID) - REQUIRED
- `iss`: Issuer - where the JWT was created
- `exp`: Expiration time
- `nbf`: Not before time
- `iat`: Issued at time
- `aud`: Audience - who the token is intended for
- Custom claims: `role`, `permissions`, etc.

### 3. Signature
Used to verify the message wasn't changed along the way and, in the case of tokens signed with a private key, it can also verify the sender's identity:

```
HMAC-SHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

## How JWT Works

### Authentication Flow with JWT

```javascript
// 1. User logs in with credentials
const loginResponse = await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ email, password })
});

const { token } = await loginResponse.json();

// 2. Store token (in memory, localStorage, httpOnly cookie)
localStorage.setItem('auth_token', token);

// 3. Include token in subsequent requests
const protectedData = await fetch('/api/protected-data', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

### Server-Side JWT Verification

```javascript
const jwt = require('jsonwebtoken');

// Verify token
function verifyToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ message: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ message: 'Invalid token' });
  }
}

// Protected route
app.get('/api/protected', verifyToken, (req, res) => {
  res.json({ message: `Hello ${req.user.name}!`, user: req.user });
});
```

## JWT in React Applications

### Implementing JWT Authentication

```jsx
// AuthContext.jsx
import React, { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext();

// JWT token expiration check
function isTokenExpired(token) {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.exp * 1000 < Date.now();
  } catch (error) {
    return true;
  }
}

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Check for stored token on app load
  useEffect(() => {
    const token = localStorage.getItem('token');
    
    if (token && !isTokenExpired(token)) {
      // Decode user info from token (client-side only)
      try {
        const payload = JSON.parse(atob(token.split('.')[1]));
        setUser(payload);
      } catch (error) {
        localStorage.removeItem('token');
      }
    }
    
    setLoading(false);
  }, []);

  const login = async (credentials) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });

      if (!response.ok) throw new Error('Login failed');

      const { token, user } = await response.json();
      
      // Store JWT token
      localStorage.setItem('token', token);
      setUser(user);
      
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  const isAuthenticated = () => {
    const token = localStorage.getItem('token');
    return token && !isTokenExpired(token);
  };

  // Intercept API calls to handle token refresh
  const apiRequest = async (url, options = {}) => {
    const token = localStorage.getItem('token');
    
    if (token && isTokenExpired(token)) {
      // Token expired, attempt refresh
      try {
        const refreshResponse = await fetch('/api/auth/refresh', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (refreshResponse.ok) {
          const { token: newToken, user: newUser } = await refreshResponse.json();
          localStorage.setItem('token', newToken);
          setUser(newUser);
        } else {
          logout();
          throw new Error('Session expired');
        }
      } catch (error) {
        logout();
        throw error;
      }
    }

    // Make the actual API call
    const headers = {
      ...options.headers,
      ...(token && { 'Authorization': `Bearer ${token}` })
    };

    const response = await fetch(url, { ...options, headers });
    
    if (response.status === 401) {
      logout();
      throw new Error('Unauthorized');
    }
    
    return response;
  };

  return (
    <AuthContext.Provider value={{
      user,
      login,
      logout,
      isAuthenticated,
      apiRequest,
      loading
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export { AuthProvider, useAuth: () => useContext(AuthContext) };
```

### Using JWT in React Components

```jsx
// Login Component
function LoginForm() {
  const { login } = useAuth();
  const [credentials, setCredentials] = useState({ email: '', password: '' });

  const handleSubmit = async (e) => {
    e.preventDefault();
    const result = await login(credentials);
    if (result.success) {
      navigate('/dashboard');
    } else {
      alert(result.error);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        placeholder="Email"
        value={credentials.email}
        onChange={(e) => setCredentials({...credentials, email: e.target.value})}
      />
      <input
        type="password"
        placeholder="Password"
        value={credentials.password}
        onChange={(e) => setCredentials({...credentials, password: e.target.value})}
      />
      <button type="submit">Login</button>
    </form>
  );
}

// Protected Route Component
function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  
  if (loading) {
    return <div>Loading...</div>;
  }
  
  if (!isAuthenticated()) {
    return <Navigate to="/login" replace />;
  }
  
  return children;
}

// Usage
function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route path="/login" element={<LoginForm />} />
        <Route path="/dashboard" element={
          <ProtectedRoute>
            <Dashboard />
          </ProtectedRoute>
        } />
      </Routes>
    </AuthProvider>
  );
}
```

## Security Considerations

### JWT Pros
- **Stateless**: No server-side session storage needed
- **Self-contained**: Contains all necessary information
- **Cross-domain**: Works across different domain names
- **URL-safe**: Can be used in URLs (though not recommended)
- **Flexible**: Can contain custom claims

### JWT Cons & Security Risks

1. **Token Termination**: Difficult to invalidate tokens before expiration
2. **Payload Size**: JWTs can become large with many claims
3. **Storage Security**: localStorage vulnerable to XSS attacks
4. **Algorithm Confusion**: Signature verification skipping attacks
5. **Secret Management**: HMAC secrets must be properly secured

### Mitigating Security Risks

```javascript
// Proper token storage (use httpOnly cookies instead of localStorage)
document.cookie = `auth_token=${token}; path=/; secure; httpOnly; max-age=86400`;

// Token refresh strategy
class TokenManager {
  async refreshToken() {
    const refreshToken = localStorage.getItem('refresh_token');
    
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${refreshToken}` }
    });
    
    const { accessToken, refreshToken: newRefreshToken } = await response.json();
    
    localStorage.setItem('token', accessToken);
    localStorage.setItem('refresh_token', newRefreshToken);
    
    return accessToken;
  }
}

// Rate limiting and monitoring
const rateLimiter = new Map();

function isRateLimited(userId) {
  const now = Date.now();
  const userRequests = rateLimiter.get(userId) || [];
  
  // Remove requests older than 15 minutes
  const recentRequests = userRequests.filter(time => now - time < 15 * 60 * 1000);
  
  rateLimiter.set(userId, recentRequests);
  
  return recentRequests.length > 100; // 100 requests per 15 minutes
}
```

## JWT Best Practices

### 1. **Use Short Expiration Times**
```javascript
const token = jwt.sign(payload, secret, { expiresIn: '15m' }); // 15 minutes
```

### 2. **Implement Token Refresh**
```javascript
const TokenManager = {
  refreshInterval: null,
  
  startAutoRefresh(token) {
    this.refreshInterval = setInterval(async () => {
      try {
        const refreshedToken = await this.refreshToken(token);
        // Update in context/storage
      } catch (error) {
        console.log('Token refresh failed:', error);
        clearInterval(this.refreshInterval);
      }
    }, 12 * 60 * 1000); // Refresh every 12 minutes for 15-minute tokens
  },
  
  stopAutoRefresh() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
  }
};
```

### 3. **Validate Tokens Server-Side**
```javascript
// Middleware for token validation
const authenticateJWT = (req, res, next) => {
  const authHeader = req.headers.authorization;
  
  if (authHeader) {
    const token = authHeader.split(' ')[1];
    
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
      if (err) {
        return res.sendStatus(403); // Invalid token
      }
      
      req.user = user;
      next();
    });
  } else {
    res.sendStatus(401); // No token
  }
};
```

### 4. **Secure Token Storage in SPAs**
Prefer httpOnly cookies over localStorage:

```javascript
// Server sets httpOnly cookie
res.cookie('auth_token', token, {
  httpOnly: true, // Prevents XSS access
  secure: process.env.NODE_ENV === 'production', // HTTPS only in production
  sameSite: 'strict', // CSRF protection
  maxAge: 7 * 24 * 60 * 60 * 1000 // 1 week
});
```

## Comparison with Other Authentication Methods

| Feature | JWT | Sessions | Basic Auth | API Keys |
|---------|-----|----------|------------|----------|
| **Stateless** | ✅ | ❌ (server storage) | ✅ | ✅ |
| **Expires** | ✅ | ✅ | ❌ | ❌ |
| **Revocable** | ❌ (without refresh token strategy) | ✅ | ❌ | ✅ |
| **Cross-domain** | ✅ | ❌ (CORS issues) | ✅ | ✅ |
| **Custom claims** | ✅ | ❌ (limited to session) | ❌ | ✅ |
| **Client-side validation** | ✅ | ❌ | ❌ | ❌ |

## Alternatives to JWT

### 1. **Opaque Tokens**
Server stores session data, client receives reference:

```javascript
// Client receives session ID
const sessionId = 'abc123';

// Server stores user data by sessionId
const sessions = {
  'abc123': { userId: 123, expires: '2023-12-31' }
};
```

### 2. **PASETO (Platform-Agnostic Security Tokens)**
More secure alternative to JWT:

```javascript
// PASETO tokens are encrypted, not just signed
const token = paseto.sign({ userId: 123 }, secret);
```

### 3. **Session Cookies**
Traditional server-side sessions:

```javascript
// Server stores session
app.use(session({
  secret: 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  cookie: { secure: true, httpOnly: true }
}));
```

## Summary

JWT is a powerful tool for authentication and authorization in modern web applications, particularly SPAs. Its main advantages include:

- **Self-contained**: Contains all necessary user information
- **Stateless**: No server-side storage required
- **Flexible**: Can include custom claims and metadata
- **Scalable**: Works well with microservices and distributed systems
- **Cross-platform**: Works across different domains and technologies

When implementing JWT in React applications:

1. **Use secure token storage** (httpOnly cookies preferred)
2. **Implement short token expirations** with refresh mechanism  
3. **Validate tokens properly** on both client and server
4. **Implement robust error handling** for expired/invalid tokens
5. **Consider security implications** and follow best practices

JWT continues to be the de-facto standard for API authentication in modern web applications, but should be used in conjunction with proper security measures and not as a sole security mechanism.
