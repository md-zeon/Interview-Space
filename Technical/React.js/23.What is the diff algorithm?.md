# What is the diff algorithm?

React's diff algorithm, also known as the reconciliation algorithm, is the core optimization that makes React fast and efficient. It determines which parts of the virtual DOM have changed and need to be updated in the real DOM, minimizing costly DOM manipulations.

## What is Reconciliation?

Reconciliation is the process by which React updates the user interface to match the current component state. React maintains a virtual representation of the UI (Virtual DOM) and uses a diff algorithm to efficiently update only the parts that have actually changed.

### The Problem Being Solved
Direct DOM manipulation is slow and inefficient. Without reconciliation, updating a list item would require re-rendering the entire list. React's diff algorithm makes this process highly optimized.

## How the Diff Algorithm Works

### 1. Virtual DOM Creation
Every time a component re-renders, React creates a new Virtual DOM tree representing the desired state of the UI.

```jsx
// Component renders, creating Virtual DOM
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}
    </ul>
  );
}
```

### 2. Diffing Process
React compares the new Virtual DOM tree with a copy of the previous tree using its diff algorithm.

#### Tree Diffing Rules:

**Rule 1: Different Element Types**
When root elements have different types, React will tear down the old tree and build a new one.

```jsx
// Before
<div>Hello World</div>

// After
<span>Hello World</span>

// Result: Complete replacement (div ≠ span)
```

**Rule 2: Same Element Types**
When elements are the same type, React preserves the DOM node and only updates changed attributes.

```jsx
// Before
<div className="container">Hello</div>

// After
<div className="wrapper">Hello</div>

// Result: Only className attribute updated
```

**Rule 3: Component Elements**
When comparing components, React updates the component's props and state, triggering a re-render of the component subtree.

### 3. Reconciliation of Lists
Lists present a special challenge because elements can be reordered, added, or removed.

#### List Reconciliation Algorithm:

**Without Keys (Inefficient):**
```jsx
// Before
<ul>
  <li>Apple</li>
  <li>Banana</li>
  <li>Cherry</li>
</ul>

// After
<ul>
  <li>Apple</li>
  <li>Banana</li>
  <li>Date</li>
</ul>

// React checks each element by position:
// Apple == Apple (same, no change)
// Banana == Banana (same, no change)  
// Cherry != Date (different, replace content)
```

**With Keys (Efficient):**
```jsx
// Before
<ul>
  <li key="apple">Apple</li>
  <li key="banana">Banana</li>  
  <li key="cherry">Cherry</li>
</ul>

// After
<ul>
  <li key="apple">Apple</li>
  <li key="banana">Banana</li>
  <li key="date">Date</li> // key="date" ≠ key="cherry"
</ul>

// React can identify that "cherry" was removed and "date" was added
```

### 4. Component Updates
When a component re-renders, React uses shallow comparison to determine what changed.

#### Shallow Comparison Rules:
- **Primitive values**: Compared by value (`1 !== 2`)
- **Objects/Arrays**: Compared by reference (`{} !== {}`)
- **Functions**: Always treated as different

```jsx
// This will cause re-render on every parent update
function Child({ user }) {
  return <div>{user.name}</div>;
}

// Parent causes re-render
<Child user={{ name: 'John' }} /> {/* New object reference every time */

// Solution: Stabilize references
const user = { name: 'John' };
<Child user={user} />
```

### 5. Commit Phase
After diffing determines what changed, React "commits" these changes to the real DOM in a single batch operation.

## The Two-Phase Algorithm

### Phase 1: Render Phase (Can be Interrupted)
React can pause and resume work during this phase without committing partial results.

1. **Build work-in-progress tree** (virtual DOM mutation)
2. **Diffing** (comparing old/new trees)
3. **Scheduling updates**

### Phase 2: Commit Phase (Cannot be Interrupted)
Once started, this phase runs to completion.

1. **Apply DOM mutations**
2. **Call componentDidMount/Update/Unmount**
3. **Execute useLayoutEffect cleanup and effects**

## Performance Optimizations

### 1. Key-Based Reconciliation
Keys help React identify list items that have changed position or been deleted/added.

```jsx
// Poor: Array indices as keys (changes when order changes)
{todos.map((todo, index) => <TodoItem key={index} todo={todo} />)}

// Good: Stable unique identifiers
{todos.map(todo => <TodoItem key={todo.id} todo={todo} />)}
```

### 2. Component Memoization

```jsx
// React.memo prevents re-renders when props haven't changed
const TodoItem = React.memo(function TodoItem({ todo }) {
  return <li>{todo.text}</li>;
});
```

### 3. Selective Updates
React only re-renders components whose state or props have actually changed.

## Common Diffing Scenarios

### Scenario 1: Text Content Change
```jsx
// Before: <div>Hello World</div>
// After:  <div>Hello React</div>

// Result: Only text node updated
```

### Scenario 2: Attribute Change  
```jsx
// Before: <div className="container"></div>
// After:  <div className="wrapper"></div>

// Result: Only className attribute updated
```

### Scenario 3: Element Type Change
```jsx
// Before: <div><p>Hello</p></div>
// After:  <div><span>Hello</span></div>

// Result: p element completely replaced with span
```

### Scenario 4: List Reordering
```jsx
// Before: A, B, C
// After:  B, C, A

// With keys: Efficient reordering via DOM manipulation
// Without keys: Potentially expensive re-render of all items
```

## React Fiber (Modern Diffing)

React Fiber is a complete rewrite of React's reconciliation engine, introducing capabilities like:

### Concurrent Rendering
React can pause, resume, and abort rendering work:

```jsx
// High priority (urgent) - immediate
useState() // Synchronous

// Low priority (non-urgent) - can be interrupted  
useDeferredValue() // Asynchronous
```

### Time Slicing
Work can be spread across multiple frames:

```jsx
// Work spread over multiple browser frames
ReactDOM.unstable_createRoot(element).render(app);
```

### Error Boundaries
Catch errors in the component tree during reconciliation:

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    logErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

## Debugging Reconciliation

### 1. React DevTools Profiler
Shows which components re-render and why:

```jsx
import { Profiler } from 'react';

function onRenderCallback(
  id, // the "id" prop of the Profiler tree
  phase, // either "mount" (initial render) or "update" (re-render)
  actualDuration, // time spent rendering commit phase
  baseDuration, // estimated time to render entire subtree
  startTime, // when React began rendering this update
  commitTime, // when React committed this update
  interactions // the Set of interactions belonging to this update
) {
  console.log({ id, phase, actualDuration, baseDuration });
}
```

### 2. WhyDidYouRender
A library that shows unnecessary re-renders:

```bash
npm install @welldone-software/why-did-you-render --save
```

### 3. Strict Mode
Helps identify components that re-render unnecessarily:

```jsx
import React from 'react';

function App() {
  return (
    <React.StrictMode>
      <YourApp />
    </React.StrictMode>
  );
}
```

## Best Practices for Optimal Diffing

### 1. Use Stable Keys for Lists
```jsx
// ✅ Stable keys
const items = [{ id: 'a' }, { id: 'b' }];
{items.map(item => <li key={item.id}>{item.name}</li>)}

// ❌ Unstable keys
{items.map((item, index) => <li key={index}>{item.name}</li>)}
```

### 2. Avoid Inline Objects in JSX
```jsx
// ❌ New object every render (causes child re-render)
<Component style={{ color: 'red' }} />

// ✅ Stable reference
const style = { color: 'red' };
<Component style={style} />
```

### 3. Use React.memo for Expensive Components
```jsx
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  // Only re-render when data changes
  return <div>{computeExpensiveValue(data)}</div>;
});
```

### 4. Stabilize Function References
```jsx
// ✅ Stable function reference
const handleClick = useCallback(() => {
  console.log('clicked');
}, []); // Empty deps = never changes

// ❌ New function reference every render  
const handleClick = () => {
  console.log('clicked');
};
```

## Summary

React's diff algorithm is the secret to its performance and developer experience. By efficiently determining what actually changed between render cycles and minimizing DOM updates, React allows developers to write declarative, component-based code without worrying about imperative DOM manipulation.

The algorithm operates on a few key principles:
1. **Same type comparison**: Update attributes/content, don't destroy and recreate
2. **Key-based identification**: Efficiently track list item changes
3. **Component memoization**: Prevent unnecessary subtree renders
4. **Time-sliced computation**: Break work into manageable chunks

Understanding and working with the diff algorithm helps create more performant React applications with fewer unnecessary re-renders and better user experience.
