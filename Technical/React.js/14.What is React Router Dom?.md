# What is React Router Dom?

React Router DOM is the routing library for React web applications. It enables navigation between different components and views in a single-page application (SPA), allowing users to move between pages without triggering a full page reload.

## Core Concepts

### BrowserRouter, HashRouter, and MemoryRouter
These are the main router components:

- **BrowserRouter**: Uses regular URL paths (recommended for production)
- **HashRouter**: Uses hash portion of the URL (#/) for routing
- **MemoryRouter**: Keeps the URL in memory (useful for testing or non-browser environments)

### Routes and Route
`Routes` is a container for `Route` components:

```jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/products/:id" element={<Product />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </BrowserRouter>
  );
}
```

## Navigation Components

### Link Component
Creates links for navigation:

```jsx
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      <Link to="/">Home</Link>
      <Link to="/about">About</Link>
      <Link to="/products/123">Product 123</Link>
    </nav>
  );
}
```

### NavLink Component
Similar to Link but adds styling for the active route:

```jsx
import { NavLink } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      <NavLink to="/" className={({ isActive }) => isActive ? "active" : ""}>
        Home
      </NavLink>
      <NavLink to="/about" className={({ isActive }) => isActive ? "active" : ""}>
        About
      </NavLink>
    </nav>
  );
}
```

## Hooks for Navigation and Parameters

### useNavigate Hook
Programmatically navigate to different routes:

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();

  const handleLogin = () => {
    // Login logic...
    navigate('/dashboard'); // Redirect after login
  };

  const handleCancel = () => {
    navigate(-1); // Go back
  };

  return (
    <div>
      <button onClick={handleLogin}>Login</button>
      <button onClick={handleCancel}>Cancel</button>
    </div>
  );
}
```

### useParams Hook
Access URL parameters:

```jsx
import { useParams } from 'react-router-dom';

function Product() {
  const { id } = useParams(); // Gets :id from path="/products/:id"

  return (
    <div>
      <h2>Product Details</h2>
      <p>Product ID: {id}</p>
    </div>
  );
}
```

### useSearchParams Hook
Access and modify query parameters:

```jsx
import { useSearchParams } from 'react-router-dom';

function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  const sortBy = searchParams.get('sort'); // ?sort=price
  const category = searchParams.get('category'); // ?category=electronics

  const handleSort = (sortType) => {
    setSearchParams({ sort: sortType, category });
  };

  return (
    <div>
      <button onClick={() => handleSort('price')}>Sort by Price</button>
      <button onClick={() => handleSort('name')}>Sort by Name</button>
    </div>
  );
}
```

## Advanced Routing Patterns

### Nested Routes
Routes can be nested to create complex UI structures:

```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} /> {/* Default child route */}
          <Route path="dashboard" element={<Dashboard />} />
          <Route path="settings/*" element={<Settings />} />
        </Route>
      </Routes>
    </BrowserRouter>
  );
}

function Layout() {
  return (
    <div>
      <Header />
      <main>
        <Outlet /> {/* Renders nested routes */}
      </main>
      <Footer />
    </div>
  );
}
```

### Protected Routes
Create components that check authentication:

```jsx
import { Navigate, useLocation } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const { currentUser } = useAuth(); // Custom hook
  const location = useLocation();

  if (!currentUser) {
    // Redirect to login page, but save the attempted location
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

// Usage
<Route path="/dashboard" element={
  <ProtectedRoute>
    <Dashboard />
  </ProtectedRoute>
} />
```

### Dynamic Routing
Load routes dynamically based on data:

```jsx
function App() {
  const [categories, setCategories] = useState([]);

  useEffect(() => {
    fetchCategories().then(categories => setCategories(categories));
  }, []);

  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        {categories.map(category => (
          <Route
            key={category.id}
            path={`/category/${category.slug}`}
            element={<CategoryPage category={category} />}
          />
        ))}
      </Routes>
    </BrowserRouter>
  );
}
```

## Route Guards and Redirects

### Redirect Component
Automatically redirect from one route to another:

```jsx
import { Navigate } from 'react-router-dom';

// Redirect old URLs to new ones
<Route path="/old-path" element={<Navigate to="/new-path" replace />} />

// Alias routes
<Route path="/home" element={<Navigate to="/" replace />} />
```

### Route Guards with Custom Components
```jsx
function AdminRoute({ children }) {
  const { user } = useAuth();
  const location = useLocation();

  if (!user?.isAdmin) {
    return <Navigate to="/unauthorized" state={{ from: location }} replace />;
  }

  return children;
}

// Usage in routes
<Route path="/admin" element={
  <AdminRoute>
    <AdminPanel />
  </AdminRoute>
} />
```

## Performance Considerations

### Code Splitting with Lazy Loading
Load route components only when needed:

```jsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// Lazy load components
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Products = lazy(() => import('./pages/Products'));
const NotFound = lazy(() => import('./pages/NotFound'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/products" element={<Products />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

## Common Patterns and Best Practices

1. **Use BrowserRouter for production applications**
2. **Implement proper loading states with Suspense**
3. **Use index routes for default child routes**
4. **Validate route parameters and handle invalid IDs**
5. **Implement proper 404 pages for unmatched routes**
6. **Use useNavigate for programmatic navigation**
7. **Protect sensitive routes with authentication checks**
8. **Use query parameters for filtering and pagination**

React Router DOM essentially transforms your React application into a true multi-page app while maintaining the benefits of a single-page application architecture. It manages browser history, handles URL changes, and ensures the UI stays in sync with the current URL.
