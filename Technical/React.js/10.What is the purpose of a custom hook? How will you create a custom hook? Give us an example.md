# What is the purpose of a custom hook? How will you create a custom hook? Give us an example

Custom hooks are a powerful feature in React that allow you to extract and reuse stateful logic between multiple components. They enable you to share logic without sharing UI, making your code more modular and testable.

## Purpose of Custom Hooks

1. **Code Reusability**: Extract common logic that can be shared across multiple components
2. **Separation of Concerns**: Separate business logic from UI logic
3. **Reduces Duplication**: Avoid repeating the same logic in different components
4. **Improved Readability**: Make components more focused on rendering UI
5. **Easier Testing**: Logic can be tested independently of components
6. **Maintainability**: Changes to logic can be made in one place

## How to Create a Custom Hook

### Rules for Custom Hooks
1. **Naming Convention**: Must start with "use" (e.g., `useAuth`, `useLocalStorage`)
2. **Hooks Inside Hooks**: Can call other hooks (useState, useEffect, etc.)
3. **Return Values**: Can return anything - primitive values, objects, functions, or even other hooks
4. **No Conditional Calls**: Must be called consistently in the same order (top-level)

### Basic Structure
```jsx
import { useState, useEffect } from 'react';

function useCustomHook(initialValue, config) {
  // Use other hooks inside
  const [state, setState] = useState(initialValue);
  
  // Perform side effects
  useEffect(() => {
    // Logic here
  }, [config]);
  
  // Return whatever the hook should expose
  return {
    value: state,
    setValue: setState,
    // ... any other functions/values
  };
}
```

## Example: useLocalStorage Hook

A common custom hook for interacting with localStorage:

```jsx
import { useState, useEffect } from 'react';

// Custom hook for localStorage
function useLocalStorage(key, initialValue) {
  // Get stored value or use initial value
  const [storedValue, setStoredValue] = useState(() => {
    try {
      // Get from local storage by key
      const item = window.localStorage.getItem(key);
      // Parse stored JSON or return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // If error, return initial value
      console.error(`Error retrieving localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Update localStorage when state changes
  const setValue = (value) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      // Save state
      setStoredValue(valueToStore);
      // Save to local storage
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      // A more advanced implementation would handle the error case
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  // Return the current value and setter function
  return [storedValue, setValue];
}

// Usage in components
function App() {
  // Will persist user's name across sessions
  const [name, setName] = useLocalStorage('user-name', 'John Doe');
  
  // Will persist theme preference
  const [theme, setTheme] = useLocalStorage('theme', 'light');

  return (
    <div>
      <input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
        placeholder="Enter your name"
      />
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
      <p>Hello, {name}! Theme: {theme}</p>
    </div>
  );
}

export default App;
```

## Another Example: useAPI Hook

A custom hook for API calls with loading and error states:

```jsx
import { useState, useEffect } from 'react';

function useAPI(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (url) {
      fetchData();
    }
  }, [url, JSON.stringify(options)]); // Dependencies to re-run effect

  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useAPI(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>Welcome, {user?.name}!</div>;
}
```

Custom hooks are JavaScript functions that follow the `use` naming convention and can call existing hooks. They help make your components cleaner and your logic more reusable across your application.
