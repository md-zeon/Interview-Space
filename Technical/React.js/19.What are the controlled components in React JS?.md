# What are the controlled components in React JS?

Controlled components are form elements whose values are controlled by React state. Instead of the form elements managing their own internal state, React controls the values through props and event handlers, making the data flow predictable and enabling real-time validation and dynamic behavior.

## What are Controlled Components?

A controlled component is a form element where React state dictates the value of the input, and changes are handled through event handlers that update the state.

### Key Characteristics:
- **Value Controlled by State**: The component's value comes from React state
- **Event Handlers Update State**: Changes trigger functions that update state
- **Single Source of Truth**: Form data lives in React component state
- **Predictable Data Flow**: All changes go through React's state management
- **Real-time Validation**: Values can be validated and formatted as they change

## Basic Controlled Component Example

```jsx
import React, { useState } from 'react';

function ControlledInput() {
  const [inputValue, setInputValue] = useState('');
  
  const handleChange = (event) => {
    setInputValue(event.target.value);
  };
  
  return (
    <div>
      <input
        type="text"
        value={inputValue}        // Controlled by state
        onChange={handleChange}   // Updates state on change
        placeholder="Enter text..."
      />
      <p>You typed: {inputValue}</p>
    </div>
  );
}
```

Compare with uncontrolled component:
```jsx
function UncontrolledInput() {
  return (
    <input type="text" defaultValue="Hello" />
    // No state control, browser manages the value
  );
}
```

## Different Form Elements as Controlled Components

### Input Elements

```jsx
function FormExample() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  
  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData(prevData => ({
      ...prevData,
      [name]: value
    }));
  };
  
  return (
    <form>
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Username"
      />
      
      <input
        type="email"
        name="email"
        value={formData.email}
        onChange={handleChange}
        placeholder="Email"
      />
      
      <input
        type="password"
        name="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Password"
      />
      
      <button type="submit">Submit</button>
    </form>
  );
}
```

### Checkbox and Radio Buttons

```jsx
function PreferenceForm() {
  const [preferences, setPreferences] = useState({
    newsletter: false,
    notifications: true,
    theme: 'light'
  });
  
  const handleCheckboxChange = (event) => {
    const { name, checked } = event.target;
    setPreferences(prev => ({
      ...prev,
      [name]: checked
    }));
  };
  
  const handleRadioChange = (event) => {
    const { name, value } = event.target;
    setPreferences(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  return (
    <div>
      <label>
        <input
          type="checkbox"
          name="newsletter"
          checked={preferences.newsletter}
          onChange={handleCheckboxChange}
        />
        Subscribe to newsletter
      </label>
      
      <label>
        <input
          type="checkbox"
          name="notifications"
          checked={preferences.notifications}
          onChange={handleCheckboxChange}
        />
        Enable notifications
      </label>
      
      <div>
        <label>
          <input
            type="radio"
            name="theme"
            value="light"
            checked={preferences.theme === 'light'}
            onChange={handleRadioChange}
          />
          Light theme
        </label>
        
        <label>
          <input
            type="radio"
            name="theme"
            value="dark"
            checked={preferences.theme === 'dark'}
            onChange={handleRadioChange}
          />
          Dark theme
        </label>
      </div>
    </div>
  );
}
```

### Select Dropdown

```jsx
function CountrySelector() {
  const [selectedCountry, setSelectedCountry] = useState('');
  
  const countries = [
    { code: 'us', name: 'United States' },
    { code: 'ca', name: 'Canada' },
    { code: 'uk', name: 'United Kingdom' }
  ];
  
  return (
    <select
      value={selectedCountry}
      onChange={(e) => setSelectedCountry(e.target.value)}
    >
      <option value="">Select a country</option>
      {countries.map(country => (
        <option key={country.code} value={country.code}>
          {country.name}
        </option>
      ))}
    </select>
  );
}
```

### Textarea

```jsx
function CommentForm() {
  const [comment, setComment] = useState('');
  
  return (
    <div>
      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Enter your comment..."
        rows={4}
        cols={50}
      />
      <p>Character count: {comment.length}</p>
    </div>
  );
}
```

## Advantages of Controlled Components

### 1. **Predictable Data Flow**
All form data flows through React state, making it easy to track and debug.

```jsx
function DebugForm() {
  const [formData, setFormData] = useState({});
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    console.log('Form data updated:', { ...formData, [name]: value });
  };
  
  return (
    <input
      name="debugInput"
      value={formData.debugInput || ''}
      onChange={handleChange}
    />
  );
}
```

### 2. **Real-time Validation**
Validate input as the user types and provide immediate feedback.

```jsx
function ValidatedInput() {
  const [email, setEmail] = useState('');
  const [isValid, setIsValid] = useState(true);
  const [errorMessage, setErrorMessage] = useState('');
  
  const validateEmail = (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  };
  
  const handleChange = (e) => {
    const value = e.target.value;
    setEmail(value);
    
    const valid = validateEmail(value);
    setIsValid(valid);
    
    if (!valid && value) {
      setErrorMessage('Please enter a valid email address');
    } else {
      setErrorMessage('');
    }
  };
  
  return (
    <div>
      <input
        type="email"
        value={email}
        onChange={handleChange}
        className={isValid ? '' : 'error'}
        placeholder="Enter your email"
      />
      {!isValid && <span className="error-text">{errorMessage}</span>}
    </div>
  );
}
```

### 3. **Dynamic Behavior**
Easily enable/disable, show/hide, or modify form elements based on state.

```jsx
function DynamicForm() {
  const [userType, setUserType] = useState('');
  const [companyDetails, setCompanyDetails] = useState('');
  
  return (
    <form>
      <select
        value={userType}
        onChange={(e) => setUserType(e.target.value)}
      >
        <option value="">Select user type</option>
        <option value="individual">Individual</option>
        <option value="business">Business</option>
      </select>
      
      {userType === 'business' && (
        <input
          type="text"
          value={companyDetails}
          onChange={(e) => setCompanyDetails(e.target.value)}
          placeholder="Company details"
        />
      )}
      
      <button type="submit" disabled={!userType}>
        Submit
      </button>
    </form>
  );
}
```

### 4. **Programmatic Control**
Set values programmatically, useful for editing existing data.

```jsx
function EditUserForm({ user, onSave }) {
  const [formData, setFormData] = useState({
    name: user.name,
    email: user.email,
    role: user.role
  });
  
  const handleSubmit = (e) => {
    e.preventDefault();
    onSave(formData);
  };
  
  // Can also reset form programmatically
  const handleReset = () => {
    setFormData({
      name: user.name,
      email: user.email,
      role: user.role
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* Form inputs controlled by formData */}
      <button type="button" onClick={handleReset}>Reset</button>
      <button type="submit">Save Changes</button>
    </form>
  );
}
```

### 5. **Data Transformation**
Transform input data before storing in state.

```jsx
function CreditCardForm() {
  const [cardNumber, setCardNumber] = useState('');
  
  const handleCardNumberChange = (e) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
    value = value.substring(0, 16); // Limit to 16 digits
    
    // Format with spaces: XXXX XXXX XXXX XXXX
    value = value.replace(/(.{4})/g, '$1 ').trim();
    
    setCardNumber(value);
  };
  
  return (
    <input
      type="text"
      value={cardNumber}
      onChange={handleCardNumberChange}
      placeholder="1234 5678 9012 3456"
    />
  );
}
```

## Controlled vs Uncontrolled Components

| Aspect | Controlled Components | Uncontrolled Components |
|--------|----------------------|------------------------|
| **Value Management** | React state | DOM element's internal state |
| **Access to Value** | `state.value` | `ref.current.value` |
| **Validation** | Real-time, as user types | On form submission typically |
| **Performance** | Slightly lower (re-renders) | Higher (no re-renders) |
| **Testing** | Easier (predictable) | More complex (DOM refs) |
| **File Inputs** | Not ideal | Better for file uploads |

## Converting Uncontrolled to Controlled

Sometimes you start with uncontrolled and convert to controlled:

```jsx
// Uncontrolled (initial)
<input type="text" defaultValue="Hello" />

// Controlled (with state)
const [value, setValue] = useState('Hello');

<input
  type="text"
  value={value}
  onChange={(e) => setValue(e.target.value)}
/>
```

## Best Practices

### 1. **Use Controlled Components for Forms**
For user input that needs validation, formatting, or dynamic behavior.

### 2. **Group Form State**
Use an object for form state when dealing with multiple inputs:

```jsx
const [formState, setFormState] = useState({
  firstName: '',
  lastName: '',
  email: ''
});

const updateField = (field, value) => {
  setFormState(prev => ({ ...prev, [field]: value }));
};
```

### 3. **Extract Form Logic**
Use custom hooks for complex form logic:

```jsx
function useForm(initialValues) {
  const [values, setValues] = useState(initialValues);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setValues(prev => ({ ...prev, [name]: value }));
  };
  
  const reset = () => setValues(initialValues);
  
  return { values, handleChange, reset, setValues };
}
```

### 4. **Consider Performance**
For very large forms or performance-critical inputs, consider debouncing:

```jsx
function DebouncedInput({ value, onChange, delay = 300 }) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => onChange(debouncedValue), delay);
    return () => clearTimeout(timer);
  }, [debouncedValue, onChange, delay]);
  
  return (
    <input
      value={debouncedValue}
      onChange={(e) => setDebouncedValue(e.target.value)}
    />
  );
}
```

## Special Cases

### Controlled File Inputs

```jsx
function FileUpload() {
  const [file, setFile] = useState(null);
  
  const handleFileChange = (e) => {
    const selectedFile = e.target.files[0];
    // For controlled file inputs, you typically handle validation here
    if (selectedFile && selectedFile.size > 1000000) {
      alert('File too large');
      return;
    }
    setFile(selectedFile);
  };
  
  return (
    <input
      type="file"
      onChange={handleFileChange}
      accept="image/*"
    />
  );
}
```

## Summary

Controlled components in React give you complete control over form elements by connecting them to React state. They enable:

- **Real-time validation and formatting**
- **Predictable data flow**
- **Dynamic UI behavior**
- **Better testing capabilities**
- **Programmatic value control**

While they require more code than uncontrolled components, the benefits of predictability and control make them the preferred choice for most form implementations in React applications.
