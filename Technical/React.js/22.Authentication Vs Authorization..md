# Authentication Vs Authorization

Authentication and Authorization are two fundamental security concepts in web applications and identity management systems, yet they serve completely different purposes in the security architecture. While they are often used together and sometimes confused, they represent different layers of access control.

## What is Authentication?

Authentication is the process of verifying the identity of a user or entity. It answers the question: **"Who are you?"**

### Key Characteristics:
- **Identity Verification**: Confirms that the user is who they claim to be
- **Credentials-Based**: Typically uses username, password, biometrics, tokens, etc.
- **First Step in Security**: Must happen before any access decisions
- **User-Focused**: About identifying the person/entity trying to access the system

### Authentication Methods

#### 1. **Basic Authentication**
Username and password combination:
```javascript
// HTTP Basic Auth
Authorization: Basic dXNlcjpwYXNz
// where "dXNlcjpwYXNz" is base64 encoded "user:pass"
```

#### 2. **Token-Based Authentication**
Using JWT, OAuth tokens, API keys:
```javascript
// Bearer Token
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 3. **Multi-Factor Authentication (MFA)**
Requires multiple verification methods:
- Something you know (password)
- Something you have (phone, hardware key)
- Something you are (biometric)

#### 4. **OAuth / Social Login**
Delegating authentication to third parties:
- Login with Google
- Login with Facebook
- Login with GitHub

### Authentication Example in React/Web App

```jsx
// Authentication Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  const login = async (email, password) => {
    try {
      setLoading(true);
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      const { token, user } = await response.json();
      localStorage.setItem('token', token); // Store auth token
      setUser(user); // Set authenticated user
      return true;
    } catch (error) {
      console.error('Login failed:', error);
      return false;
    } finally {
      setLoading(false);
    }
  };
  
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };
  
  // Check if user is authenticated (token validation)
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (token) {
      // Validate token with server
      fetch('/api/auth/verify', {
        headers: { Authorization: `Bearer ${token}` }
      })
      .then(response => response.json())
      .then(user => setUser(user))
      .catch(() => logout()) // Token invalid
      .finally(() => setLoading(false));
    } else {
      setLoading(false);
    }
  }, []);
  
  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

// Usage in components
function LoginForm() {
  const { login } = useContext(AuthContext);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    const success = await login(email, password);
    if (success) {
      navigate('/dashboard');
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="email" placeholder="Email" />
      <input type="password" placeholder="Password" />
      <button type="submit">Login</button>
    </form>
  );
}
```

## What is Authorization?

Authorization is the process of determining whether an authenticated user has permission to perform a specific action or access a particular resource. It answers the question: **"What are you allowed to do?"**

### Key Characteristics:
- **Permissions Management**: Controls what actions/resources a user can access
- **After Authentication**: Can only happen after identity is verified
- **System/Resource-Focused**: About protecting assets and operations
- **Granular Control**: Can be very specific (read vs write, department access, etc.)

### Authorization Methods

#### 1. **Role-Based Access Control (RBAC)**

Users are assigned roles, roles have permissions:
```javascript
const roles = {
  admin: ['read', 'write', 'delete', 'manage_users'],
  editor: ['read', 'write'],
  viewer: ['read']
};

// Check if user can perform action
function hasPermission(user, action) {
  return user.roles.some(role => roles[role].includes(action));
}
```

#### 2. **Attribute-Based Access Control (ABAC)**

Permissions based on attributes of user, resource, action, and environment:
```javascript
function allowAccess(user, resource, action, environment) {
  // Check user department
  if (user.department !== resource.department) {
    return false;
  }
  
  // Check time of day
  if (action === 'delete' && environment.time > '18:00') {
    return false;
  }
  
  // Check user's clearance level
  return user.clearanceLevel >= resource.sensitivityLevel;
}
```

#### 3. **Claim-Based Authorization**

Using claims in tokens (JWT):

```javascript
// JWT payload with claims
const token = {
  userId: 123,
  roles: ['user'],
  permissions: ['read:posts', 'write:posts'],
  department: 'engineering',
  clearance: 'confidential'
};
```

### Authorization Implementation in React

```jsx
// Protected Route Component
function ProtectedRoute({ children, requiredPermissions = [] }) {
  const { user, logout } = useContext(AuthContext);
  
  // Check if user is authenticated
  if (!user) {
    return <Navigate to="/login" replace />;
  }
  
  // Check if user has required permissions
  const hasPermission = requiredPermissions.every(permission =>
    user.permissions.includes(permission)
  );
  
  if (!hasPermission) {
    return <Navigate to="/unauthorized" replace />;
  }
  
  return children;
}

// Role-based route guard
function AdminRoute({ children }) {
  return (
    <ProtectedRoute requiredPermissions={['manage:users']}>
      {children}
    </ProtectedRoute>
  );
}

// Component-level authorization
function DeleteButton({ item, onDelete }) {
  const { user } = useContext(AuthContext);
  
  // Check if user can delete this item
  const canDelete = user.id === item.authorId || user.role === 'admin';
  
  if (!canDelete) {
    return null; // Hide button
  }
  
  return <button onClick={() => onDelete(item.id)}>Delete</button>;
}

// Usage
function App() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/login" element={<Login />} />
      <Route path="/dashboard" element={
        <ProtectedRoute>
          <Dashboard />
        </ProtectedRoute>
      } />
      <Route path="/admin" element={
        <AdminRoute>
          <AdminPanel />
        </AdminRoute>
      } />
      <Route path="/posts/:id/edit" element={
        <ProtectedRoute requiredPermissions={['write:posts']}>
          <EditPost />
        </ProtectedRoute>
      } />
    </Routes>
  );
}
```

## Key Differences

| Aspect | Authentication | Authorization |
|--------|----------------|---------------|
| **Question Answered** | "Who are you?" | "What can you do?" |
| **Purpose** | Identity Verification | Access Control |
| **Timing** | First Step | After Authentication |
| **Methods** | Password, Tokens, MFA, Biometrics | Roles, Permissions, Claims, ABAC |
| **Example** | Login form | "Delete" button visibility |
| **Failure Result** | "Invalid credentials" | "Access denied" or "Forbidden" |
| **Data Type** | Identity information | Permissions/roles/policies |

## Common Authentication Types

### 1. **Session-Based Authentication**
- Server stores session data
- Client receives session ID (usually in cookie)
- Good for server-side rendering

### 2. **Token-Based Authentication**
- Self-contained tokens (JWT preferred)
- Stateless, scalable
- Client stores token (localStorage, httpOnly cookie)
- Good for SPA and microservices

### 3. **API Key Authentication**
- For machine-to-machine communication
- Simple but less secure for user-facing apps
- Often used in combination with other methods

## Common Authorization Models

### 1. **Discretionary Access Control (DAC)**
Resource owner controls access (files, documents)

### 2. **Mandatory Access Control (MAC)**
System-enforced policies (government, military)

### 3. **Role-Based Access Control (RBAC)**
Access based on user roles

### 4. **Attribute-Based Access Control (ABAC)**
Access based on attributes and policies

## Security Best Practices

### For Authentication:
1. Use HTTPS everywhere
2. Implement proper password policies
3. Use secure token storage (httpOnly cookies preferred)
4. Implement token expiration and refresh
5. Use cryptographically strong tokens
6. Implement proper logout mechanisms

### For Authorization:
1. Follow principle of least privilege
2. Implement defense in depth
3. Regularly review permissions
4. Use consistent permission naming
5. Implement proper error handling
6. Log access attempts and failures

## Implementation in Modern React Apps

```jsx
// Combined Auth + Authorization Context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [permissions, setPermissions] = useState([]);
  
  const login = async (credentials) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    
    const { token, user, permissions } = await response.json();
    localStorage.setItem('auth_token', token);
    setUser(user);
    setPermissions(permissions);
  };
  
  const hasPermission = (permission) => {
    return permissions.includes(permission);
  };
  
  const hasRole = (role) => {
    return user?.roles.includes(role);
  };
  
  return (
    <AuthContext.Provider value={{
      user,
      permissions,
      login,
      logout,
      hasPermission,
      hasRole
    }}>
      {children}
    </AuthContext.Provider>
  );
}

// Usage in components
function PostActions({ post }) {
  const { user, hasPermission } = useContext(AuthContext);
  
  const canEdit = user?.id === post.authorId || hasPermission('edit:all_posts');
  const canDelete = hasPermission('delete:posts');
  
  return (
    <div>
      {canEdit && <button>Edit</button>}
      {canDelete && <button>Delete</button>}
    </div>
  );
}
```

## Summary

**Authentication** and **Authorization** work together to create secure applications, but they solve different problems:

- **Authentication** establishes trust: "Are you who you say you are?"
- **Authorization** enforces boundaries: "Now that we know who you are, what can you access?"

In React applications, authentication typically involves login flows and token management, while authorization controls UI rendering, route access, and API permissions based on user roles and capabilities. Proper implementation of both is crucial for building secure, user-appropriate experiences.
