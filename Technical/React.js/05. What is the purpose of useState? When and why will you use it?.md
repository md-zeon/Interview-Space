# What is the purpose of useState? When and why will you use it?

`useState` is a React Hook introduced in React 16.8 that allows functional components to manage state. It enables functional components to have stateful behavior previously only available in class components. `useState` is fundamental to React's Hooks system and understanding it is essential for modern React development.

## Basic Usage of useState

### **Syntax**
```javascript
const [state, setState] = useState(initialValue);
```

### **Parameters**
- **initialValue**: The initial state value (can be any type: string, number, object, array, etc.)

### **Returns**
- **state**: The current state value
- **setState**: Function to update the state

```javascript
import { useState } from 'react';

function Counter() {
  // Declare state variable with initial value 0
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

## When to Use useState

### **1. Managing User Input**
```javascript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    // Submit form data
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### **2. Handling UI State**
```javascript
function Accordion() {
  const [isExpanded, setIsExpanded] = useState(false);

  return (
    <div>
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </button>
      {isExpanded && <div>Expanded content</div>}
    </div>
  );
}
```

### **3. Managing Loading States**
```javascript
function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/data');
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return { data, loading, error, fetchData };
}
```

### **4. Tracking Form Validation**
```javascript
function RegistrationForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: ''
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const updateFormData = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear field-specific error
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
  };

  // Form validation and submission logic...
}
```

## Why useState is Important

### **1. Enables State in Functional Components**
Before Hooks (React 16.8), only class components could have state:

```javascript
// Before Hooks - Class component required
class Counter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Increment
        </button>
      </div>
    );
  }
}

// With Hooks - Functional component can have state
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

### **2. Allows Multiple State Variables**
```javascript
function ComplexComponent() {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [theme, setTheme] = useState('light');

  // Each state variable is independent
  // Re-render only when specific state changes
}
```

### **3. Automatic Re-rendering**
Components automatically re-render when state changes:

```javascript
function AutoUpdate() {
  const [count, setCount] = useState(0);

  console.log('Component rendered, count:', count);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
// Click button ‚Üí setCount updates ‚Üí component re-renders ‚Üí new count displayed
```

## State Update Functions

### **1. Direct Value Updates**
```javascript
const [count, setCount] = useState(0);

// Direct value (replaces current state)
setCount(5);
setCount(count + 1); // Based on current value
```

### **2. Functional Updates**
```javascript
const [count, setCount] = useState(0);

// Function that receives current value (preferred for async updates)
setCount(prevCount => prevCount + 1);

// Good for multiple rapid updates
const increment = () => {
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
  setCount(prev => prev + 1);
};
// Result: count increases by 3 (each update sees the latest value)
```

### **3. Object State Updates**
```javascript
const [user, setUser] = useState({ name: '', email: '' });

// ‚ùå Don't mutate directly (won't trigger re-render)
user.name = 'John';

// ‚úÖ Use functional update
setUser(prevUser => ({
  ...prevUser,
  name: 'John'
}));

// ‚úÖ Or direct object update (but spread previous values)
setUser({
  ...user,
  name: 'John'
});
```

## Common Use Cases

### **1. Form Management**
```javascript
function ContactForm() {
  const [form, setForm] = useState({ name: '', email: '', message: '' });
  const [submitted, setSubmitted] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = () => {
    // Submit logic
    setSubmitted(true);
  };

  if (submitted) {
    return <div>Thank you for your message!</div>;
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" value={form.name} onChange={handleChange} />
      <input name="email" value={form.email} onChange={handleChange} />
      <textarea name="message" value={form.message} onChange={handleChange} />
      <button type="submit">Send</button>
    </form>
  );
}
```

### **2. Toggle States**
```javascript
function ThemeToggle() {
  const [isDark, setIsDark] = useState(false);

  return (
    <div className={isDark ? 'dark' : 'light'}>
      <button onClick={() => setIsDark(!isDark)}>
        {isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode'}
      </button>
      {/* Rest of UI adapts to theme */}
    </div>
  );
}
```

### **3. Managing Collections**
```javascript
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [newTodo, setNewTodo] = useState('');

  const addTodo = () => {
    if (newTodo.trim()) {
      setTodos(prev => [...prev, {
        id: Date.now(),
        text: newTodo.trim(),
        completed: false
      }]);
      setNewTodo('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const deleteTodo = (id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  };

  return (
    <div>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && addTodo()}
      />
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### **4. Modal/Dialog Management**
```javascript
function App() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);

  const openModal = (item) => {
    setSelectedItem(item);
    setIsModalOpen(true);
  };

  const closeModal = () => {
    setIsModalOpen(false);
    setSelectedItem(null);
  };

  return (
    <div>
      {/* List that can open modal */}
      {items.map(item => (
        <div key={item.id} onClick={() => openModal(item)}>
          {item.title}
        </div>
      ))}

      {/* Modal controlled by state */}
      {isModalOpen && (
        <Modal onClose={closeModal}>
          <ItemDetails item={selectedItem} />
        </Modal>
      )}
    </div>
  );
}
```

## Performance Considerations

### **1. State Colocation**
Keep state as close as possible to where it's used:

```javascript
function App() {
  return (
    <div>
      {/* State lifted to parent only when shared */}
      <Section1 />  {/* Has its own state */}
      <Section2 />  {/* Has its own state */}
    </div>
  );
}
```

### **2. State Initialization**
```javascript
// Lazy initialization (only runs once)
const [user, setUser] = useState(() => {
  // Expensive computation
  return loadUserFromStorage();
});

// Expensive initial calculation
const [data, setData] = useState(() => computeInitialData(props));
```

### **3. Avoiding Unnecessary State**
```javascript
function UserCard({ user, onSelect }) {
  // ‚ùå Don't duplicate prop in state
  // const [userData, setUserData] = useState(user);

  // ‚úÖ If you need to mutate, use local state for edits
  const [isEditing, setIsEditing] = useState(false);
  const [tempName, setTempName] = useState(user.name);

  return (
    <div onClick={() => onSelect(user.id)}>
      {isEditing ? (
        <input
          value={tempName}
          onChange={(e) => setTempName(e.target.value)}
        />
      ) : (
        user.name
      )}
    </div>
  );
}
```

## State vs Props

### **When to Use State vs Props**

#### **Use State When:**
‚úÖ **Data is local to component**
‚úÖ **Data changes over time**
‚úÖ **Data needs to persist across re-renders**
‚úÖ **User interactions modify data**
‚úÖ **UI state (visible/hidden, active/inactive)**

#### **Use Props When:**
‚úÖ **Parent provides the data**
‚úÖ **Data is shared between components**
‚úÖ **Component is configurable**
‚úÖ **Data flows from parent to child**

```javascript
// Mix of props and state
function EditableItem({ item, onSave }) {
  // Props: Data comes from parent
  const [isEditing, setIsEditing] = useState(false); // State: UI behavior
  const [text, setText] = useState(item.text);       // State: Temp edit data

  const handleSave = () => {
    onSave(item.id, text); // Props: Communicate to parent
    setIsEditing(false);   // State: Update local UI state
  };

  return (
    <div>
      {isEditing ? (
        <div>
          <input value={text} onChange={(e) => setText(e.target.value)} />
          <button onClick={handleSave}>Save</button>
        </div>
      ) : (
        <div onClick={() => setIsEditing(true)}>{item.text}</div>
      )}
    </div>
  );
}
```

## Interview Questions

### Q: What's the purpose of useState?
**A**: `useState` allows functional components to have state, enabling them to track data that changes over time and trigger re-renders when that data updates.

### Q: When should you use useState?
**A**: Use it when you need to store data that can change, should cause component re-renders, or needs to persist across component lifecycle events.

### Q: What's the difference between state and props?
**A**: Props are read-only data passed from parent components, while state is mutable data managed internally by the component.

### Q: How does state update work?
**A**: When you call a state setter function, React schedules a re-render with the new state value. The component re-renders and displays the new state.

### Q: Can you explain the functional update pattern?
**A**: `setState(prev => newValue)` ensures the update uses the most current state value, preventing issues with multiple rapid updates or asynchronous state changes.

`useState` is the cornerstone of stateful functional components in modern React. It enables the management of local component state, form handling, user interactions, and dynamic UI behavior, making functional components as powerful as class components.
