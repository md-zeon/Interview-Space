# Tell us about React Component Lifecycle

The React component lifecycle refers to the series of phases a component goes through from creation to removal from the DOM. Each phase has specific methods that allow you to hook into the component's behavior at different points. The lifecycle is divided into three main phases: Mounting, Updating, and Unmounting.

## Class Component Lifecycle Methods

### 1. Mounting Phase
These methods are called when an instance of a component is being created and inserted into the DOM:

- **`constructor(props)`**: Called when the component is initialized. Used for:
  - Initializing state (`this.state = {}`)
  - Binding methods (`this.method = this.method.bind(this)`)

- **`static getDerivedStateFromProps(props, state)`**: Rarely used. Called right before rendering. Returns an object to update the state based on props.

- **`render()`**: The only required method. Returns the JSX to be rendered. Should be pure (no side effects).

- **`componentDidMount()`**: Called after the component has been rendered to the DOM. Perfect for:
  - API calls to fetch data
  - Setting up subscriptions or timers
  - Adding event listeners

### 2. Updating Phase
These methods are called when a component is being re-rendered due to changes in props, state, or context:

- **`static getDerivedStateFromProps(props, state)`**: Same as in mounting phase.

- **`shouldComponentUpdate(nextProps, nextState)`**: Optimization method. Returns boolean indicating whether component should re-render. Defaults to `true`.

- **`render()`**: Re-renders the component with updated props/state.

- **`getSnapshotBeforeUpdate(prevProps, prevState)`**: Called right before the changes are applied to DOM. Returns a snapshot value passed to `componentDidUpdate`.

- **`componentDidUpdate(prevProps, prevState, snapshot)`**: Called after the component has updated. Good for:
  - Making additional API calls when props change
  - DOM operations based on prop changes
  - Scrolling or adjusting UI after updates

### 3. Unmounting Phase
- **`componentWillUnmount()`**: Called just before the component is destroyed and removed from DOM. Used for cleanup:
  - Cancelling pending API requests
  - Removing event listeners
  - Clearing timers and subscriptions

### 4. Error Handling Phase
- **`static getDerivedStateFromError(error)`**: Called when an error occurs in a child component. Returns error state.
- **`componentDidCatch(error, info)`**: Catches JavaScript errors in the component tree. Used for error reporting.

## Example Class Component with Lifecycle
```jsx
class LifecycleExample extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    console.log('constructor');
  }
  
  static getDerivedStateFromProps(props, state) {
    console.log('getDerivedStateFromProps');
    return null;
  }
  
  componentDidMount() {
    console.log('componentDidMount');
    // Good place for API calls
  }
  
  componentDidUpdate(prevProps, prevState) {
    console.log('componentDidUpdate');
    if (prevState.count !== this.state.count) {
      // React to state changes
    }
  }
  
  componentWillUnmount() {
    console.log('componentWillUnmount');
    // Clean up resources
  }
  
  render() {
    return <div>Count: {this.state.count}</div>;
  }
}
```

## Functional Component Lifecycle with Hooks
Functional components use hooks to manage lifecycle:
- `useState`: Replaces `this.state` and `setState`
- `useEffect`: Replaces `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`
- `useLayoutEffect`: Similar to `useEffect` but runs synchronously after DOM mutations

### Example Functional Component
```jsx
function LifecycleHook({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    console.log('Effect ran');
    fetchUser(userId);
    
    // Cleanup function (componentWillUnmount)
    return () => {
      console.log('Cleanup');
    };
  }, [userId]); // Dependencies: runs when userId changes
  
  const fetchUser = async (id) => {
    const data = await fetch(`/api/user/${id}`);
    setUser(data);
  };
  
  return user ? <div>{user.name}</div> : <div>Loading...</div>;
}
```

**Note**: Hooks (introduced in React 16.8) are now the preferred way to manage component lifecycle in functional components, largely replacing the need for class components. Lifecycle methods in class components are considered legacy for most use cases.
