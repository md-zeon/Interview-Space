# How would you optimize a React js application?

Optimizing a React application involves improving performance, reducing bundle size, and ensuring efficient re-renders. Here are key optimization techniques and best practices:

## 1. Component Optimization

### React.memo for Functional Components
Prevents unnecessary re-renders by memoizing components based on prop comparisons:

```jsx
import React from 'react';

const MemoizedItem = React.memo(({ title, onClick }) => {
  console.log('Item re-rendered'); // Won't log if props unchanged
  return <li onClick={onClick}>{title}</li>;
});

// Usage
<MemoizedItem title={item.title} onClick={() => handleItemClick(item.id)} />
```

### shouldComponentUpdate for Class Components
Control when class components re-render:

```jsx
class ItemComponent extends React.Component {
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.id !== this.props.id;
  }
  
  render() {
    return <div>{this.props.title}</div>;
  }
}
```

## 2. Hook Optimization

### useMemo for Expensive Calculations
Memoizes the result of expensive computations:

```jsx
import { useMemo } from 'react';

function ExpensiveCalculation({ data }) {
  const processedData = useMemo(() => {
    // Expensive computation
    return data.map(item => ({ ...item, computedValue: heavyCompute(item.raw) }));
  }, [data]); // Only recomputes when data changes
  
  return <div>Processed {processedData.length} items</div>;
}
```

### useCallback for Function Stability
Prevents unnecessary re-renders in child components that depend on function props:

```jsx
import { useCallback } from 'react';

function TodoList({ todos }) {
  const handleTodoClick = useCallback((id) => {
    console.log('Todo clicked:', id);
  }, []); // Empty dependency array = function never changes
  
  return (
    <ul>
      {todos.map(todo => (
        <MemoizedTodoItem key={todo.id} todo={todo} onClick={handleTodoClick} />
      ))}
    </ul>
  );
}
```

## 3. List Optimization

### Keys and Virtual Scrolling
Use stable, unique keys and consider virtual scrolling for large lists:

```jsx
// Good: stable keys
{todos.map(todo => <Todo key={todo.id} {...todo} />)}

// Virtual scrolling with react-window
import { FixedSizeList as List } from 'react-window';

function LargeList({ items }) {
  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={35}
      width={300}
    >
      {({ index, style }) => (
        <div style={style}>
          Item {items[index].name}
        </div>
      )}
    </List>
  );
}
```

## 4. Code Splitting and Lazy Loading

### React.lazy for Route-based Splitting
Split code at the route level:

```jsx
import React, { Suspense, lazy } from 'react';
import { Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./screens/Home'));
const About = lazy(() => import('./screens/About'));
const Dashboard = lazy(() => import('./screens/Dashboard'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Suspense>
  );
}
```

### Component-based Splitting
Lazy load heavy components:

```jsx
const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  const [showHeavy, setShowHeavy] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowHeavy(true)}>Load Heavy Component</button>
      {showHeavy && (
        <Suspense fallback={<div>Loading...</div>}>
          <HeavyComponent />
        </Suspense>
      )}
    </div>
  );
}
```

## 5. Bundle Size Optimization

### Tree Shaking
Import only what you need:

```jsx
// Good: specific imports
import { useState, useEffect } from 'react';
import debounce from 'lodash/debounce';

// Avoid: importing entire libraries
import React from 'react';
import _ from 'lodash';
```

### Image and Asset Optimization
Use proper formats and compression:

```jsx
// WebP with fallbacks
<picture>
  <source srcset="hero.webp" type="image/webp">
  <img src="hero.jpg" alt="Hero image">
</picture>

// Lazy load images
import { useState, useRef, useEffect } from 'react';

function LazyImage({ src, alt }) {
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => setIsInView(entry.isIntersecting)
    );
    observer.observe(imgRef.current);
    return () => observer.disconnect();
  }, []);
  
  return <img ref={imgRef} src={isInView ? src : ''} alt={alt} />;
}
```

## 6. State Management Optimization

### Avoid Unnecessary State Updates
Use functional updates for setState to avoid stale closure issues:

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  // Good: Avoids depending on current count in closure
  const increment = () => setCount(count => count + 1);
  
  // Avoid: Might use stale closure
  // const increment = () => setCount(count + 1);
}
```

### Context Splitting
Split context to avoid unnecessary re-renders:

```jsx
const ThemeContext = createContext();
const UserContext = createContext();

// Rather than one big context object
const AppContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value={theme}>
      <UserContext.Provider value={user}>
        <Component />
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}
```

## 7. Performance Monitoring

### React DevTools Profiler
Use the React Profiler to identify performance bottlenecks:

```jsx
import { Profiler } from 'react';

// Wrap components you want to profile
<Profiler id="TodoList" onRender={onRenderCallback}>
  <TodoList todos={todos} />
</Profiler>
```

### Web Vitals
Monitor Core Web Vitals (CLS, FID, LCP) using libraries like web-vitals.

## Best Practices Summary

1. Use React.memo, useMemo, and useCallback to prevent unnecessary re-renders
2. Implement code splitting with React.lazy and Suspense
3. Optimize images and assets
4. Use proper keys in lists
5. Avoid object literals in JSX props
6. Debounce expensive operations
7. Consider virtualization for large lists
8. Use production builds for deployment
9. Monitor performance with tools like React DevTools and Web Vitals

These optimizations should be applied strategically after identifying actual performance issues rather than preemptively, as premature optimization can make code more complex.
