# What is the best way to send 4 or more props to a child component?

When a component requires many props (4 or more), passing them individually can become cumbersome, error-prone, and harder to maintain. Here are the best practices for handling multiple props effectively.

## Best Practice: Group Related Props into Objects

### Using Configuration Objects

The recommended approach is to group related props into objects that represent conceptual units:

```jsx
// Instead of individual props
<Comment
  authorName="John Doe"
  authorAvatar="john-avatar.jpg"
  authorBio="Software Engineer"
  commentText="Great article!"
  timestamp="2023-11-23T10:00:00Z"
  isEdited={false}
  likesCount={15}
  repliesCount={3}
  onEdit={handleEdit}
  onDelete={handleDelete}
  onReply={handleReply}
  onLike={handleLike}
/>

// Group related props into objects
<Comment
  user={{
    name: "John Doe",
    avatar: "john-avatar.jpg",
    bio: "Software Engineer"
  }}
  content={{
    text: "Great article!",
    timestamp: "2023-11-23T10:00:00Z",
    isEdited: false
  }}
  stats={{
    likesCount: 15,
    repliesCount: 3
  }}
  actions={{
    onEdit: handleEdit,
    onDelete: handleDelete,
    onReply: handleReply,
    onLike: handleLike
  }}
/>
```

### Component Implementation

```jsx
function Comment({ user, content, stats, actions }) {
  const { name, avatar, bio } = user;
  const { text, timestamp, isEdited } = content;
  const { likesCount, repliesCount } = stats;
  const { onEdit, onDelete, onReply, onLike } = actions;

  return (
    <div className="comment">
      <div className="comment-header">
        <img src={avatar} alt={`${name}'s avatar`} />
        <div>
          <strong>{name}</strong>
          <span>{bio}</span>
        </div>
        <span>{formatTimestamp(timestamp)}</span>
      </div>
      
      <div className="comment-content">
        {text}
        {isEdited && <em>(edited)</em>}
      </div>
      
      <div className="comment-footer">
        <span>{likesCount} likes â€¢ {repliesCount} replies</span>
        <div className="comment-actions">
          <button onClick={onEdit}>Edit</button>
          <button onClick={onDelete}>Delete</button>
          <button onClick={onReply}>Reply</button>
          <button onClick={onLike}>Like</button>
        </div>
      </div>
    </div>
  );
}
```

## Alternative Approach: Spread Operators

### Object Spread for Configuration

Use the spread operator to pass all properties of a configuration object:

```jsx
const buttonConfig = {
  size: 'large',
  variant: 'primary',
  disabled: false,
  loading: true
};

<Button {...buttonConfig} onClick={handleClick}>
  Submit
</Button>

// In Button component
function Button({ children, onClick, size = 'medium', variant = 'default', ...otherProps }) {
  const { disabled, loading, ...passthroughProps } = otherProps;
  
  return (
    <button
      className={`button ${size} ${variant}`}
      disabled={disabled || loading}
      onClick={onClick}
      {...passthroughProps} // Passes any remaining props
    >
      {loading ? 'Loading...' : children}
    </button>
  );
}
```

## Component Composition Pattern

For complex components, consider using render props or component composition to avoid prop drilling:

```jsx
function Panel({ children, ...panelProps }) {
  return (
    <div className="panel" {...panelProps}>
      {children}
    </div>
  );
}

// Usage
<Panel title="User Settings" collapsible>
  <Panel.Header>
    <Panel.Title>Settings</Panel.Title>
    <Panel.Actions>
      <Button>Save</Button>
      <Button variant="secondary">Cancel</Button>
    </Panel.Actions>
  </Panel.Header>
  <Panel.Body>
    <Form>...</Form>
  </Panel.Body>
</Panel>
```

## When to Group Props

### DO Group When:
- Props are related to the same concept (e.g., all styling props, all user data props)
- The component API becomes cleaner and more semantic
- Prop names become shorter and self-documenting
- Props are often passed together

### DON'T Group When:
- Props are completely unrelated
- Grouping would make the code less clear
- Individual props need to be overridden frequently

## Advanced Patterns: Higher-Order Components

For props that are used across many components, consider Higher-Order Components (HOCs) or custom hooks:

```jsx
// HOC example
function withUserData(WrappedComponent) {
  return function WithUserDataComponent(props) {
    const user = useCurrentUser();
    
For props that are used across many components, consider Higher-Order Components (HOCs) or custom hooks:

```jsx
// HOC example
function withUserData(WrappedComponent) {
  return function WithUserDataComponent(props) {
    const user = useCurrentUser();
    
    // Separate user props from other props
    const { userId, ...otherProps } = props;
    const userData = userId ? users.find(u => u.id === userId) : null;
    
    return (
      <WrappedComponent
        {...otherProps}
        user={userData}
        currentUser={user}
      />
    );
  };
}

// Usage
const EnhancedProfile = withUserData(ProfileComponent);
```

## Best Practices Summary

