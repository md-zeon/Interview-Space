# What is React.memo()? And why will you use it?

`React.memo` is a higher-order component (HOC) that memoizes functional components, preventing unnecessary re-renders when props haven't changed. It optimizes performance by allowing React to skip rendering components that haven't received new or changed props.

## What is React.memo?

`React.memo` is a performance optimization tool that works like `React.PureComponent` but for functional components. It performs a shallow comparison of props to determine if the component should re-render.

### Basic Usage

```jsx
import React from 'react';

const MyComponent = React.memo(function MyComponent({ name, age }) {
  console.log('MyComponent rendered');
  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
    </div>
  );
});

// Or as arrow function
const MyArrowComponent = React.memo(({ title }) => {
  return <h1>{title}</h1>;
});
```

### Without React.memo (Default Behavior)

```jsx
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
      {/* ChildComponent will re-render even if its props don't change */}
      <ChildComponent name="John" />
    </div>
  );
}

function ChildComponent({ name }) {
  console.log('ChildComponent re-rendered'); // Logs on every count change
  return <p>Hello, {name}!</p>;
}
```

### With React.memo (Optimized Behavior)

```jsx
const ChildComponent = React.memo(function ChildComponent({ name }) {
  console.log('ChildComponent re-rendered'); // Only logs on first render or name change
  return <p>Hello, {name}!</p>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
      {/* ChildComponent only renders once since name never changes */}
      <ChildComponent name="John" />
    </div>
  );
}
```

## Why Use React.memo?

### 1. Preventing Unnecessary Re-renders

When a parent component re-renders, all child components re-render by default. This can cause performance issues in large applications:

```jsx
function TodoList({ todos, filter }) {
  const filteredTodos = useMemo(() => {
    return todos.filter(todo => todo.text.includes(filter));
  }, [todos, filter]);

  return (
    <ul>
      {filteredTodos.map(todo => (
        <TodoItem key={todo.id} todo={todo} /> // Each item would re-render unnecessarily
      ))}
    </ul>
  );
}
```

Memoizing `TodoItem` prevents re-renders when the todo object hasn't changed:

```jsx
const TodoItem = React.memo(function TodoItem({ todo }) {
  return (
    <li>
      <input type="checkbox" checked={todo.completed} readOnly />
      <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
        {todo.text}
      </span>
    </li>
  );
});
```

### 2. Reference Stability

Memoized components help prevent cascading re-renders in complex component trees:

```jsx
const UserAvatar = React.memo(function UserAvatar({ user }) {
  return <img src={user.avatarUrl} alt={`${user.name}'s avatar`} />;
});

function UserCard({ user, onUpdate }) {
  return (
    <div>
      <UserAvatar user={user} /> {/* Won't re-render if user props are same */}
      <button onClick={() => onUpdate(user.id)}>Edit</button>
    </div>
  );
}
```

### 3. Expensive Computational Components

For components that perform expensive operations:

```jsx
const ExpensiveChart = React.memo(function ExpensiveChart({ data, width, height }) {
  // Heavy calculation or rendering logic
  const chartData = useMemo(() => {
    return processChartData(data); // Expensive computation
  }, [data]);

  return (
    <div style={{ width, height }}>
      {/* Chart rendering code */}
      {chartData.points.map(point => renderPoint(point))}
    </div>
  );
});
```

## Custom Comparison Function

By default, `React.memo` does shallow comparison. For more control, provide a custom comparison function:

```jsx
const CustomMemoComponent = React.memo(
  function CustomMemoComponent({ user, count }) {
    return (
      <div>
        <p>{user.name}</p>
        <p>Count: {count}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison logic
    // Return true if props are equal (component should not re-render)
    return prevProps.user.id === nextProps.user.id && prevProps.count === nextProps.count;
  }
);
```

### When to Use Custom Comparison

```jsx
// For deep object comparison
const DeepCompareComponent = React.memo(
  function DeepCompareComponent({ items }) {
    return (
      <ul>
        {items.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>
    );
  },
  (prevProps, nextProps) => {
    // Custom deep comparison
    if (prevProps.items.length !== nextProps.items.length) return false;
    
    return prevProps.items.every((item, index) => 
      item.id === nextProps.items[index].id && item.name === nextProps.items[index].name
    );
  }
);
```

## Common Use Cases

### 1. List Items

```jsx
const TodoItem = React.memo(function TodoItem({ todo, onToggle, onDelete }) {
  return (
    <li>
      <input 
        type="checkbox" 
        checked={todo.completed} 
        onChange={() => onToggle(todo.id)} 
      />
      <span>{todo.text}</span>
      <button onClick={() => onDelete(todo.id)}>Delete</button>
    </li>
  );
});

function TodoList({ todos, onToggleTodo, onDeleteTodo }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem 
          key={todo.id} 
          todo={todo} 
          onToggle={onToggleTodo} 
          onDelete={onDeleteTodo} 
        />
      ))}
    </ul>
  );
}
```

### 2. UI Components that Receive Frequent Parent Updates

```jsx
const SearchBar = React.memo(function SearchBar({ query, onChange, placeholder }) {
  return (
    <input
      type="text"
      value={query}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
    />
  );
});

function App() {
  const [query, setQuery] = useState('');
  const [someOtherState, setSomeOtherState] = useState(0);
  
  return (
    <div>
      <button onClick={() => setSomeOtherState(s => s + 1)}>
        Update State: {someOtherState}
      </button>
      {/* SearchBar won't re-render when someOtherState changes */}
      <SearchBar 
        query={query} 
        onChange={setQuery}
        placeholder="Search..." 
      />
    </div>
  );
}
```

### 3. Components with Expensive Rendering

```jsx
const DataTable = React.memo(function DataTable({ data, columns, sortBy }) {
  const sortedData = useMemo(() => {
    return [...data].sort((a, b) => a[sortBy].localeCompare(b[sortBy]));
  }, [data, sortBy]);

  return (
    <table>
      <thead>
        <tr>
          {columns.map(column => <th key={column.key}>{column.title}</th>)}
        </tr>
      </thead>
      <tbody>
        {sortedData.map(row => (
          <tr key={row.id}>
            {columns.map(column => <td key={column.key}>{row[column.key]}</td>)}
          </tr>
        ))}
      </tbody>
    </table>
  );
});
```

## When NOT to Use React.memo

### 1. Simple Components

Don't memoize simple components that render quickly:

```jsx
// No benefit - component is very simple
const Greeting = React.memo(function Greeting({ name }) {
  return <p>Hello, {name}!</p>;
});
```

### 2. Components That Always Receive New Props

```jsx
function TimeDisplay({ time }) {
  return <div>Current time: {time.toLocaleTimeString()}</div>;
}

// Assuming time is always new Date() in parent
<TimeDisplay time={new Date()} /> // Bad - new reference every render

// Instead, handle it in the parent
const timeString = new Date().toLocaleTimeString();
<TimeDisplay time={timeString} /> // Good - primitive type
```

### 3. When Props Change Frequently

If a component's props change on every render, memoizing offers no benefit and adds overhead.

## Performance Considerations

### Benefits:
- Reduces unnecessary re-renders
- Improves performance in large component trees
- Prevents cascade re-renders when parent updates

### Costs:
- Shallow comparison adds overhead
- Memory usage for memoization
- Custom comparison functions add complexity

### Best Practice:
```jsx
// Start simple, add memoization when needed
function MyComponent({ prop1, prop2 }) {
  // Component logic...
}

// Add React.memo only after identifying performance issues
export default React.memo(MyComponent);
```

## Alternatives to React.memo

### useMemo for Expensive Operations within Components

```jsx
function ExpensiveComponent({ items, filter }) {
  const filteredItems = useMemo(() => {
    console.log('Filtering items...');
    return items.filter(item => item.includes(filter));
  }, [items, filter]); // Only recalculates when dependencies change

  return <div>Found {filteredItems.length} items</div>;
}
```

### useCallback for Stable Function References

```jsx
const handleClick = useCallback(() => {
  setCount(c => c + 1);
}, []); // Function reference stays stable across renders

return <button onClick={handleClick}>Increment</button>;
```

### React.PureComponent for Class Components

```jsx
class PureComponentClass extends React.PureComponent {
  render() {
    return <div>{this.props.name}</div>;
  }
}
```

## Debugging Memoized Components

Add display names for better debugging:

```jsx
const UserList = React.memo(function UserList({ users }) {
  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
});

UserList.displayName = 'UserList'; // Helps with debugging
```

## Summary

`React.memo` optimizes performance by memoizing functional components and preventing re-renders when props haven't changed. Use it when:

- Components re-render frequently with unchanged props
- Components contain expensive rendering logic
- Preventing cascade re-renders in large component trees

However, don't overuse it on simple components. Profile your application first to identify actual performance bottlenecks before applying `React.memo`.
