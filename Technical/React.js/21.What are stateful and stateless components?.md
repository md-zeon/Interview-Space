# What are stateful and stateless components?

In React, components can be categorized based on whether they manage their own state. Stateful components maintain internal state data, while stateless components are pure functions that receive all their data through props and don't manage any internal state.

## Stateful Components

Stateful components are components that:
- Manage their own state using `useState`, `useReducer`, or class component `this.state`
- Can modify their own data internally
- May have lifecycle methods (in class components) or effects (in functional components)
- Are responsible for managing interactive behavior and data mutations

### Functional Stateful Component (Modern Approach)

```jsx
import React, { useState, useEffect } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  const [isVisible, setIsVisible] = useState(true);
  
  useEffect(() => {
    console.log('Counter mounted or count changed:', count);
  }, [count]);
  
  return (
    <div>
      {isVisible && <p>Count: {count}</p>}
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? 'Hide' : 'Show'} Count
      </button>
    </div>
  );
}
```

### Class Stateful Component (Legacy Approach)

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
      isVisible: true
    };
  }
  
  componentDidMount() {
    console.log('Counter mounted');
  }
  
  componentDidUpdate(prevProps, prevState) {
    if (prevState.count !== this.state.count) {
      console.log('Count changed:', this.state.count);
    }
  }
  
  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };
  
  toggleVisibility = () => {
    this.setState({ isVisible: !this.state.isVisible });
  };
  
  render() {
    const { count, isVisible } = this.state;
    
    return (
      <div>
        {isVisible && <p>Count: {count}</p>}
        <button onClick={this.increment}>Increment</button>
        <button onClick={this.toggleVisibility}>
          {isVisible ? 'Hide' : 'Show'} Count
        </button>
      </div>
    );
  }
}
```

### Stateful Container Components

```jsx
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [filter, setFilter] = useState('');
  
  useEffect(() => {
    fetchUsers();
  }, []);
  
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(filter.toLowerCase()) ||
    user.email.toLowerCase().includes(filter.toLowerCase())
  );
  
  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <UserList
      users={filteredUsers}
      filter={filter}
      onFilterChange={setFilter}
      onRefresh={fetchUsers}
    />
  );
}
```

## Stateless Components

Stateless components (also called functional or presentational components) are:
- Pure functions that receive data only through props
- Have no internal state management
- Return the same output for the same props input
- Focus on presentation/UI rendering
- Easy to test and reason about

### Functional Stateless Component

```jsx
import React from 'react';

function UserCard({ user, onClick, isSelected }) {
  return (
    <div
      className={`user-card ${isSelected ? 'selected' : ''}`}
      onClick={() => onClick(user.id)}
    >
      <img src={user.avatar} alt={`${user.name}'s avatar`} />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
        <span className="user-role">{user.role}</span>
      </div>
    </div>
  );
}

// Usage
<UserCard
  user={userData}
  onClick={handleUserClick}
  isSelected={selectedUserId === userData.id}
/>
```

### Stateless Component with Hooks (but no state)

```jsx
import React from 'react';

function SearchInput({ value, onChange, placeholder }) {
  // No state here - just pure props to UI mapping
  return (
    <div className="search-input-container">
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="search-input"
      />
      <span className="search-icon">üîç</span>
    </div>
  );
}
```

## Key Differences

| Feature | Stateful Components | Stateless Components |
|---------|---------------------|---------------------|
| **State Management** | Yes - `useState`, `this.state` | No - receives data via props |
| **Side Effects** | Yes - API calls, subscriptions | No - pure functions |
| **Reusability** | Less reusable (stateful logic) | More reusable (pure logic) |
| **Testing** | Harder (side effects, state) | Easier (pure functions) |
| **Performance** | May cause more re-renders | Better performance (easier optimization) |
| **Data Flow** | Can modify own state | Unidirectional data flow |

## When to Use Each Type

### Use Stateful Components When:
- Managing form inputs and validation
- Fetching and displaying dynamic data
- Implementing interactive UI elements (modals, dropdowns, etc.)
- Managing component lifecycle and side effects
- Creating container components that orchestrate data flow

### Use Stateless Components When:
- Displaying data (cards, lists, layouts)
- Pure presentation logic
- Reusable UI elements (buttons, inputs, icons)
- Maximizing testability and reusability
- Creating small, focused components

## Best Practices

### 1. Prefer Stateless When Possible

```jsx
// Bad: Button managing its own state
function BadButton() {
  const [loading, setLoading] = useState(false);
  
  const handleClick = async () => {
    setLoading(true);
    await someAsyncAction();
    setLoading(false);
  };
  
  return (
    <button disabled={loading} onClick={handleClick}>
      {loading ? 'Loading...' : 'Click me'}
    </button>
  );
}

// Good: State managed by parent
function GoodButton({ loading, onClick }) {
  return (
    <button disabled={loading} onClick={onClick}>
      {loading ? 'Loading...' : 'Click me'}
    </button>
  );
}

// Parent manages state
function App() {
  const [loading, setLoading] = useState(false);
  
  const handleClick = async () => {
    setLoading(true);
    await someAsyncAction();
    setLoading(false);
  };
  
  return <GoodButton loading={loading} onClick={handleClick} />;
}
```

### 2. Separate Concerns with Container/Presentational Pattern

```jsx
// Container Component (Stateful)
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [filter, setFilter] = useState('');
  
  // State management logic...
  
  return (
    <UserList
      users={users}
      filter={filter}
      onFilterChange={setFilter}
    />
  );
}

// Presentation Component (Stateless)
function UserList({ users, filter, onFilterChange }) {
  const filteredUsers = users.filter(user =>
    user.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  return (
    <div>
      <input
        type="text"
        value={filter}
        onChange={(e) => onFilterChange(e.target.value)}
        placeholder="Filter users..."
      />
      {filteredUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// Pure Presentation Component (Stateless)
function UserCard({ user }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}
```

### 3. Memoize Stateless Components When Necessary

```jsx
const UserCard = React.memo(function UserCard({ user }) {
  console.log('UserCard rendered:', user.name);
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});
```

### 4. Use Custom Hooks for Shared State Logic

```jsx
// Custom hook to share stateful behavior
function useUsers() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data);
    } finally {
      setLoading(false);
    }
  };
  
  return {
    users,
    loading,
    fetchUsers,
    setUsers
  };
}

// Multiple components can share the same stateful logic
function UsersPage() {
  const { users, loading, fetchUsers } = useUsers();
  
  // Component focuses on presentation
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      <button onClick={fetchUsers}>Refresh</button>
      <UserList users={users} />
    </div>
  );
}
```

## Migration from Class to Functional Components

With React Hooks, class components can be converted to functional components:

```jsx
// Before: Class Component
class Profile extends Component {
  constructor(props) {
    super(props);
    this.state = { editing: false, name: props.user.name };
  }
  
  toggleEdit = () => {
    this.setState({ editing: !this.state.editing });
  };
  
  render() {
    // render logic...
  }
}

// After: Functional Component
function Profile({ user }) {
  const [editing, setEditing] = useState(false);
  const [name, setName] = useState(user.name);
  
  const toggleEdit = () => setEditing(!editing);
  
  // render logic...
}
```

## Performance Considerations

### Stateful Components:
- May cause more re-renders if state changes frequently
- Side effects can impact performance
- Generally heavier than stateless components

### Stateless Components:
- Easier to optimize (React.memo, useMemo, useCallback)
- Better tree-shaking potential
- Faster to test and reason about

## Summary

**Stateful components** manage internal state and side effects, handling complex interactions and data management. They're essential for container components and interactive features.

**Stateless components** are pure presentation components that receive data through props and render consistently. They promote reusability, testability, and performance optimization.

The modern React approach encourages using functional components with hooks for state management while keeping most components stateless. This creates a clear separation between data/logic (stateful) and presentation (stateless) concerns.
