# What is props drilling?

Props drilling refers to the repetitive process of passing data (props) down through multiple layers of components, when intermediate components don't actually need that data and are only passing it along to reach deeply nested child components.

## What is Props Drilling?

Props drilling occurs when you have a component tree where data needs to be passed from a high-level component to a low-level component, but requires traveling through multiple intermediate components that don't use the data themselves.

### Example of Props Drilling

```jsx
// App.jsx
function App() {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState({ name: 'John' });

  return (
    <div>
      <Header theme={theme} user={user} setTheme={setTheme} />
    </div>
  );
}

// Header.jsx
function Header({ theme, user, setTheme }) {
  return (
    <div>
      <Navbar theme={theme} user={user} /> {/* Navbar doesn't need user */}
      <ThemeToggle setTheme={setTheme} /> {/* ThemeToggle doesn't need theme directly */}
    </div>
  );
}

// Navbar.jsx
function Navbar({ theme, user }) {
  return (
    <nav style={{ backgroundColor: theme === 'light' ? 'white' : 'black' }}>
      <UserProfile user={user} /> {/* UserProfile needs user */}
    </nav>
  );
}

// UserProfile.jsx
function UserProfile({ user }) {
  return (
    <div>
      <span>Welcome, {user.name}!</span>
    </div>
  );
}

// ThemeToggle.jsx
function ThemeToggle({ setTheme }) {
  return (
    <button onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}>
      Toggle Theme
    </button>
  );
}
```

In this example:
- `App` passes `theme`, `user`, and `setTheme` to `Header`
- `Header` receives all props but only passes them down, doesn't use them
- `Navbar` receives `theme` and `user` but only uses `theme`, passes `user` to `UserProfile`
- `ThemeToggle` only needs `setTheme`
- `UserProfile` finally uses `user`

This creates "prop pollution" where components receive props they don't need.

## Problems with Props Drilling

1. **Code Clutter**: Components become bloated with props they're just passing through
2. **Coupling**: Components become tightly coupled to their ancestors' data
3. **Maintenance**: Refactoring becomes difficult - changing data flow requires updates to many components
4. **Readability**: Hard to understand which component actually uses which data
5. **Debugging**: Tracing the source of props becomes challenging

## Solutions to Props Drilling

### 1. React Context API
The most common solution for global state or deeply nested data:

```jsx
// ThemeContext.jsx
import { createContext, useContext } from 'react';

const ThemeContext = createContext();
const UserContext = createContext();

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function UserProvider({ children }) {
  const [user, setUser] = useState({ name: 'John' });
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// Hooks for consuming context
export const useTheme = () => useContext(ThemeContext);
export const useUser = () => useContext(UserContext);

// Clean component usage
function Navbar() {
  const { theme } = useTheme();
  
  return (
    <nav style={{ backgroundColor: theme === 'light' ? 'white' : 'black' }}>
      <UserProfile />
    </nav>
  );
}

function UserProfile() {
  const { user } = useUser();
  
  return <span>Welcome, {user.name}!</span>;
}

function ThemeToggle() {
  const { setTheme } = useTheme();
  
  return (
    <button onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}>
      Toggle Theme
    </button>
  );
}
```

### 2. Component Composition and Children Props
Pass components as children instead of props:

```jsx
// Render Props Pattern
function Header({ children, theme }) {
  return (
    <div className="header">
      {/* Header owns theme, passes it to children that need it */}
      {React.Children.map(children, child => 
        React.cloneElement(child, { theme })
      )}
    </div>
  );
}

function App() {
  return (
    <Header theme="light">
      <Navbar />  {/* Navbar will receive theme prop */}
      <ThemeToggle />
    </Header>
  );
}
```

### 3. State Management Libraries
For complex applications, use Redux, Zustand, or other state management solutions:

```jsx
// With Zustand
import create from 'zustand';

const useAppStore = create(set => ({
  theme: 'light',
  user: { name: 'John' },
  setTheme: (theme) => set({ theme }),
  setUser: (user) => set({ user })
}));

function Navbar() {
  const theme = useAppStore(state => state.theme);
  
  return (
    <nav style={{ backgroundColor: theme === 'light' ? 'white' : 'black' }}>
      <UserProfile />
    </nav>
  );
}

function UserProfile() {
  const user = useAppStore(state => state.user);
  
  return <span>Welcome, {user.name}!</span>;
}
```

### 4. Props Propagation with Object Spread
When drilling can't be avoided, use object spread to make it cleaner:

```jsx
// Instead of passing individual props
function Header({ theme, user, setTheme, setUser, appSettings }) {
  return <Navbar {..arguments} />;
}

// Use object spread
function Header(props) {
  return <Navbar {...props} />;
}
```

## When is Props Drilling Acceptable?

Props drilling is usually fine in small applications or when:
1. The component tree is shallow (only 2-3 levels deep)
2. The intermediate components aren't receiving many unrelated props
3. The data flow is predictable and unlikely to change

## Best Practices

1. **Avoid premature optimization**: Don't implement Context for every prop
2. **Group related props**: When drilling can't be avoided, group related props into objects
3. **Use Context strategically**: Reserve Context for truly global data
4. **Consider component architecture**: Sometimes restructuring components can eliminate drilling
5. **Use custom hooks**: Create hooks that encapsulate both state and related operations

Props drilling becomes a problem when it makes code maintenance difficult. The key is recognizing when the complexity of drilling outweighs the benefit of each component being self-contained. Context API and state management libraries provide elegant solutions for most common scenarios.
