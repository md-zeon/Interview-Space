# Why do we inject dependency inside a useEffect hook?

The dependency array (second parameter) of `useEffect` is crucial for controlling when the effect runs. It's React's way of optimizing performance and preventing unnecessary side effects by specifying what values from the component scope the effect depends on.

## What is the useEffect Dependency Array?

The dependency array is the second argument passed to `useEffect`:

```jsx
useEffect(() => {
  // Side effect logic here
  console.log('Effect ran');
}, [dependency1, dependency2]); // Dependency array
```

## Why We Need Dependencies

### Without Dependencies (Runs on Every Render)

```jsx
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Effect runs on every render');
    document.title = `Count: ${count}`;
  }); // No dependency array = runs after every render
  
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

This runs the effect after every single render, which can cause:
- Performance issues
- Unnecessary API calls
- UI glitches
- Infinite loops if the effect updates state

### With Empty Dependencies (Runs Only on Mount)

```jsx
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Effect runs only on mount');
    fetchUserData(); // API call that should only happen once
  }, []); // Empty array = runs only when component mounts
  
  return <div>Display data</div>;
}
```

This runs the effect only once, when the component first mounts.

### With Dependencies (Runs When Dependencies Change)

```jsx
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    console.log('Effect runs when userId changes');
    fetchUser(userId).then(setUser);
  }, [userId]); // Effect runs when userId changes
  
  return <div>{user?.name}</div>;
}
```

This runs the effect initially and whenever `userId` changes.

## How Dependencies Work

### 1. Shallow Comparison
React uses Object.is() to compare dependencies between renders:

```jsx
const [count, setCount] = useState(0);
const [user, setUser] = useState({ id: 1, name: 'John' });

useEffect(() => {
  console.log('Count changed:', count);
}, [count]); // âœ… Works - primitives are compared by value

useEffect(() => {
  console.log('User changed');
}, [user]); // âœ… Works - objects are compared by reference

useEffect(() => {
  console.log('User name changed:', user.name);
}, [user.name]); // âœ… Better - depends on specific property
```

### 2. Stale Closures Issue

```jsx
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    // This creates a closure capturing the initial count (0)
    const interval = setInterval(() => {
      console.log(count); // Always logs 0, never the updated count
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Empty dependencies = closure captures initial count
  
  return <button onClick={() => setCount(count + 1)}>+</button>;
}
```

To fix this, include the dependency:

```jsx
useEffect(() => {
  const interval = setInterval(() => {
    console.log(count); // Now logs the current count value
  }, 1000);
  
  return () => clearInterval(interval);
}, [count]); // Include count to update the closure
```

### 3. Dependency Array Rules

#### Include External Dependencies
```jsx
function Component() {
  const [count, setCount] = useState(0);
  const multiplier = 2; // External function
  
  useEffect(() => {
    console.log(count * multiplier); // Uses multiplier
  }, [count, multiplier]); // Include both!
}
```

#### Functions from Props
```jsx
function Component({ onUpdate }) {
  useEffect(() => {
    onUpdate();
  }, [onUpdate]); // Include prop functions
}
```

#### State from useState
```jsx
const [state, setState] = useState(initialValue);

useEffect(() => {
  // Effect that uses state
  doSomething(state);
}, [state]); // Include state variables
```

## Common Pitfalls and Best Practices

### Pitfall: Missing Dependencies (React Hook Lint Warnings)

```jsx
// âŒ ESLint: React Hook useEffect has missing dependencies
useEffect(() => {
  console.log(count); // Uses count
  // Missing: , [count]
});

// âœ”ï¸ Correct
useEffect(() => {
  console.log(count);
}, [count]);
```

### Pitfall: Incorrect Dependencies

```jsx
// âŒ This will run the effect every time (count changed)
const [count, setCount] = useState(0);

useEffect(() => {
  console.log('API call for count:', count);
  fetchData(count);
}, [count]); // Effect runs whenever count changes

// âŒ Worse - missing count dependency
useEffect(() => {
  console.log('API call for count:', count);
  fetchData(count);
}, []); // Effect runs once, but uses stale count
```

### Pitfall: Object Dependencies

```jsx
// âŒ This will run every render
useEffect(() => {
  console.log(user.name);
}, [user]); // New object reference every render

// âœ… Fix: Depend on specific values
useEffect(() => {
  console.log(user.name);
}, [user.name, user.id]);
```

### Best Practice: Function Dependencies with useCallback

```jsx
const handleUserUpdate = useCallback((userId) => {
  updateUser(userId);
}, []); // Memoized function

useEffect(() => {
  handleUserUpdate(userId);
}, [handleUserUpdate, userId]); // Include the memoized function
```

### Best Practice: useMemo for Expensive Computations

```jsx
const processedData = useMemo(() => {
  return rawData.map(item => expensiveTransform(item));
}, [rawData]); // Only recalculate when rawData changes

useEffect(() => {
  saveToDatabase(processedData);
}, [processedData]); // Only save when data actually changes
```

## Different Dependency Patterns

### On Mount Only (Cleanup on Unmount)

```jsx
useEffect(() => {
  const subscription = subscribeToUpdates();
  
  return () => {
    // Cleanup function runs on unmount
    subscription.unsubscribe();
  };
}, []); // Empty array
```

### On Every Render (Rare - Usually Not Needed)

```jsx
useEffect(() => {
  // This runs after every render (not recommended without good reason)
  console.log('Component re-rendered');
});
// No second parameter
```

### On Specific Value Changes

```jsx
useEffect(() => {
  if (userId) {
    fetchUser(userId);
  }
}, [userId]); // Only when userId changes
```

### Conditional Effects

```jsx
useEffect(() => {
  if (isLoggedIn) {
    loadUserPreferences();
  }
}, [isLoggedIn]); // Only when login status changes
```

## Linting and Performance

React's ESLint rules (`eslint-plugin-react-hooks`) will warn you about:
- Missing dependencies in effect arrays
- Unnecessary dependencies
- Incorrect dependency arrays

These warnings help catch bugs and performance issues early.

## When to Add Dependencies

### âœ… Include:
- Any reactive values used inside the effect (state, props)
- Functions from props
- Context values consumed
- Values returned by other hooks

### ðŸš« Don't Include:
- Built-in functions (console.log, setTimeout, etc.)
- Functions defined inside the effect
- Constants and primitives that never change
- React's built-in functions (useState returns, etc.)

## Summary

The dependency array controls when `useEffect` runs:
- No array â†’ Every render
- Empty array â†’ Only on mount (and cleanup on unmount)
- With values â†’ When any dependency changes

Correct dependencies prevent stale closures, unnecessary effects, and performance issues. They ensure effects run at the right time with the correct values, making your React components more predictable and efficient.
