# How will you send data from a Child Component to the parent component?

In React, data flows downward from parent to child components through props. However, sometimes you need to pass data back up from child to parent. This is achieved by passing callback functions as props to the child component.

## Method 1: Callback Functions as Props

The most common and recommended way to send data from child to parent is to pass a callback function as a prop.

### Basic Example

```jsx
import React, { useState } from 'react';

function ParentComponent() {
  const [childData, setChildData] = useState('');

  const handleChildData = (data) => {
    setChildData(data);
  };

  return (
    <div>
      <h2>Parent Component</h2>
      <p>Data from child: {childData}</p>
      <ChildComponent onSendData={handleChildData} />
    </div>
  );
}

function ChildComponent({ onSendData }) {
  const [inputValue, setInputValue] = useState('');

  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };

  const handleSendData = () => {
    if (onSendData) {
      onSendData(inputValue); // Send data to parent
    }
  };

  return (
    <div>
      <h3>Child Component</h3>
      <input
        type="text"
        value={inputValue}
        onChange={handleInputChange}
        placeholder="Enter some data"
      />
      <button onClick={handleSendData}>Send to Parent</button>
    </div>
  );
}
```

### Multiple Data Points

```jsx
function ParentComponent() {
  const handleFormData = (formData) => {
    console.log('Received data:', formData);
    // Process the form data...
  };

  return (
    <div>
      <h2>Parent Component</h2>
      <FormComponent onSubmit={handleFormData} />
    </div>
  );
}

function FormComponent({ onSubmit }) {
  const [formState, setFormState] = useState({
    name: '',
    email: '',
    age: ''
  });

  const handleChange = (field, value) => {
    setFormState(prev => ({ ...prev, [field]: value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit(formState); // Send entire object to parent
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Name"
        onChange={(e) => handleChange('name', e.target.value)}
      />
      <input
        type="email"
        placeholder="Email"
        onChange={(e) => handleChange('email', e.target.value)}
      />
      <input
        type="number"
        placeholder="Age"
        onChange={(e) => handleChange('age', e.target.value)}
      />
      <button type="submit">Submit</button>
    </form>
  );
}
```

## Method 2: Using useImperativeHandle (Advanced)

For more complex scenarios where you need direct access to child methods:

```jsx
import React, { useRef, forwardRef, useImperativeHandle } from 'react';

function ParentComponent() {
  const childRef = useRef();

  const handleGetChildData = () => {
    const childData = childRef.current.getData();
    console.log('Child data:', childData);
  };

  return (
    <div>
      <button onClick={handleGetChildData}>Get Child Data</button>
      <ChildComponent ref={childRef} />
    </div>
  );
}

const ChildComponent = forwardRef((props, ref) => {
  const [data, setData] = useState('Some child data');

  useImperativeHandle(ref, () => ({
    getData: () => data,
    setData: (newData) => setData(newData)
  }));

  return (
    <div>
      <p>Child component has data: {data}</p>
    </div>
  );
});
```

## Method 3: Using Context (For Complex Hierarchies)

For deeply nested components, you can use Context API:

```jsx
import React, { createContext, useContext, useState } from 'react';

// Create context
const FormContext = createContext();

function FormProvider({ children }) {
  const [formData, setFormData] = useState({});

  const updateFormData = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <FormContext.Provider value={{ formData, updateFormData }}>
      {children}
    </FormContext.Provider>
  );
}

function useForm() {
  return useContext(FormContext);
}

// Parent component
function ParentForm() {
  return (
    <FormProvider>
      <h2>Form</h2>
      <InputField fieldName="name" />
      <InputField fieldName="email" />
      <SubmitButton />
    </FormProvider>
  );
}

// Child components
function InputField({ fieldName }) {
  const { formData, updateFormData } = useForm();

  return (
    <input
      type="text"
      value={formData[fieldName] || ''}
      onChange={(e) => updateFormData(fieldName, e.target.value)}
      placeholder={fieldName}
    />
  );
}

function SubmitButton() {
  const { formData } = useForm();

  const handleSubmit = () => {
    console.log('Form data:', formData);
  };

  return <button onClick={handleSubmit}>Submit Form</button>;
}
```

## Method 4: Lifting State Up

Move state to the common parent of the components that need it:

```jsx
function ParentComponent() {
  const [selectedItem, setSelectedItem] = useState(null);

  return (
    <div>
      <ItemList onSelectItem={setSelectedItem} />
      <ItemDetails item={selectedItem} />
    </div>
  );
}

function ItemList({ onSelectItem }) {
  const handleClick = (item) => {
    onSelectItem(item);
  };

  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => handleClick(item)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}

function ItemDetails({ item }) {
  return (
    <div>
      {item ? <p>Selected: {item.name}</p> : <p>No item selected</p>}
    </div>
  );
}
```

## Best Practices

1. **Callback Props**: The most common and React-recommended pattern
2. **Lift State Up**: When multiple components need access to the same data
3. **Context**: For deeply nested components (avoid overusing)
4. **Refs**: Only when imperative access is absolutely necessary
5. **Event Emitter or PubSub**: Rarely recommended in React; callback props usually suffice
6. **Custom Hooks**: To share stateful logic without duplicating data

The callback prop approach is generally preferred because it maintains React's unidirectional data flow while allowing communication between parent and child components. Always consider whether the state truly belongs in the parent component - sometimes restructuring the component hierarchy can make state management simpler.
