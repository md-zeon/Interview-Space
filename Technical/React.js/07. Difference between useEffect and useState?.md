# Difference between useEffect and useState

`useState` and `useEffect` are two of the most commonly used React hooks, but they serve completely different purposes in a React application.

## useState
- **Purpose**: Manages local component state in functional components
- **How it works**: Returns an array with two elements: the current state value and a function to update that state
- **Triggers re-render**: When the state is updated using the setter function, it causes the component to re-render
- **Usage**: Store values that can change over time, such as user inputs, API responses, or UI states like showing/hiding elements

### Example:
```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

## useEffect
- **Purpose**: Performs side effects in functional components, such as data fetching, DOM manipulation, or setting up subscriptions
- **How it works**: Runs after every completed render, unless a dependency array is provided to control when it runs
- **Triggers re-render**: Does not directly trigger re-renders, but can cause them if it updates state or context
- **Usage**: For operations that need to happen outside the normal component render cycle, like:
  - Fetching data from APIs
  - Setting up timers or intervals
  - Adding event listeners
  - Cleaning up resources

### Example:
```jsx
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      const response = await fetch(`/api/user/${userId}`);
      const data = await response.json();
      setUser(data);
    };
    
    fetchUser();
  }, [userId]); // Runs when userId changes
  
  if (!user) return <div>Loading...</div>;
  
  return <div>{user.name}</div>;
}
```

## Key Differences
1. **Purpose**:
   - useState manages state
   - useEffect manages side effects
   
2. **Return Value**:
   - useState returns [value, setterFunction]
   - useEffect doesn't return anything (or returns cleanup function)
   
3. **Re-rendering Trigger**:
   - useState triggers re-render when updated
   - useEffect runs after render is complete
   
4. **Timing**:
   - useState is synchronous
   - useEffect is asynchronous (runs after render)
   
5. **Dependencies**:
   - useEffect accepts an optional dependency array to control when it runs
   - useState dependencies are managed internally
