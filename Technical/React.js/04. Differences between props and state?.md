# Differences between props and state?

Props (properties) and state are two fundamental concepts in React that handle data within components. While both manage component data, they serve different purposes, have different characteristics, and are used in different scenarios. Understanding their differences is crucial for building maintainable React applications.

## Props (Properties)

### **Definition**
Props are read-only data passed from parent components to child components. They are similar to function arguments in JavaScript.

```javascript
// Parent component
function App() {
  const user = { name: 'John', age: 30 };
  return <UserProfile user={user} theme="dark" />;
}

// Child component receives props
function UserProfile(props) {
  return (
    <div>
      <h1>{props.user.name}</h1>
      <p>Age: {props.age}</p>
      <div className={props.theme}>Profile content</div>
    </div>
  );
}
```

### **Characteristics**

#### **1. Read-Only**
```javascript
function UserCard({ user, onEdit }) {
  // ❌ Cannot modify props directly
  user.name = 'Jane'; // This won't work (and is bad practice)

  // ✅ Use props to trigger parent actions
  const handleEdit = () => {
    onEdit(user.id); // Parent handles the actual update
  };

  return (
    <div>
      <h2>{user.name}</h2>
      <button onClick={handleEdit}>Edit</button>
    </div>
  );
}
```

#### **2. Passed Downward**
```javascript
// Props flow from parent to child (one-way data flow)
function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      {/* Props passed down */}
      <CounterDisplay count={count} />
      <CounterControls onIncrement={() => setCount(count + 1)} />
    </div>
  );
}

function CounterDisplay({ count }) {
  return <h1>Count: {count}</h1>;
}

function CounterControls({ onIncrement }) {
  return <button onClick={onIncrement}>Increment</button>;
}
```

#### **3. Can Be Any Type**
```javascript
function FlexibleComponent({ data, callback, config }) {
  return (
    <div>
      {/* Props can be: */}
      {/* Primitives: string, number, boolean */}
      <h1>{data.title}</h1>  {/* string */}
      <p>Items: {data.count}</p>  {/* number */}
      {data.isActive && <span>Active</span>}  {/* boolean */}

      {/* Objects */}
      <UserInfo user={data.user} />  {/* object */}

      {/* Arrays */}
      {data.items.map(item => <li key={item.id}>{item.name}</li>)}  {/* array */}

      {/* Functions */}
      <button onClick={callback}>Click me</button>  {/* function */}

      {/* React elements */}
      {config.customHeader}  {/* React element */}
    </div>
  );
}
```

## State

### **Definition**
State is mutable data that belongs to a component. It's used to track information that can change over time and affect the component's rendering.

```javascript
import { useState } from 'react';

function Counter() {
  // State is managed internally by the component
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

### **Characteristics**

#### **1. Mutable and Internal**
```javascript
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleSearch = (searchTerm) => {
    // State can be updated within the component
    setQuery(searchTerm);

    // State changes trigger re-renders
    performSearch(searchTerm).then(setResults);
  };

  return (
    <div>
      <input
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="Search..."
      />
      {results.map(result => <div key={result.id}>{result.title}</div>)}
    </div>
  );
}
```

#### **2. Component-Specific**
```javascript
function App() {
  // State is encapsulated within each component
  return (
    <div>
      <Counter1 />  {/* Has its own state */}
      <Counter2 />  {/* Has separate state */}
    </div>
  );
}

function Counter1() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>Counter1: {count}</button>;
}

function Counter2() {
  const [count, setCount] = useState(10);
  return <button onClick={() => setCount(count + 1)}>Counter2: {count}</button>;
}
```

## Key Differences

### **1. Ownership and Modification**

| Aspect | Props | State |
|--------|-------|-------|
| **Owner** | Parent component | Component itself |
| **Modification** | Read-only (children can't modify) | Can be modified by component |
| **Purpose** | Receive data | Manage internal data |
| **Changes trigger** | Parent changes | Component interactions |

### **2. Data Flow and Communication**

#### **Props: Unidirectional Flow**
```javascript
// Data flows down from parent to child
function Parent() {
  const [message, setMessage] = useState('Hello');

  return (
    <div>
      {/* Props sent down */}
      <Child message={message} onMessageChange={setMessage} />
    </div>
  );
}

function Child({ message, onMessageChange }) {
  return (
    <div>
      <p>{message}</p>
      {/* Use callback prop to communicate up */}
      <button onClick={() => onMessageChange('Goodbye')}>
        Change Message
      </button>
    </div>
  );
}
```

#### **State: Component Encapsulation**
```javascript
// State is internal to component
function TodoItem({ todo, onToggle }) {
  // Local state for UI interactions
  const [isEditing, setIsEditing] = useState(false);

  return (
    <div>
      {isEditing ? (
        <input
          value={todo.text}
          onChange={(e) => {/* update local state */}}
        />
      ) : (
        <span onClick={() => setIsEditing(true)}>{todo.text}</span>
      )}

      {/* Props used for parent communication */}
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
    </div>
  );
}
```

### **3. When to Use Each**

#### **Use Props When:**
✅ **Parent needs to pass data to child**
✅ **Child needs to communicate back to parent**
✅ **Data is computed or transformed by parent**
✅ **Several components share the same data**
✅ **Component behavior is configured from outside**

```javascript
function Dashboard({ user, theme, onLogout }) {
  return (
    <div className={theme}>
      <Header user={user} onLogout={onLogout} />
      <Sidebar theme={theme} />
      <MainContent user={user} />
    </div>
  );
}
```

#### **Use State When:**
✅ **Data changes over time within component**
✅ **Component needs to remember user interactions**
✅ **Component manages its own behavior internally**
✅ **Data doesn't need to be shared with siblings**
✅ **Local form inputs, UI state, animations**

```javascript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState({});

  // State manages form behavior internally
  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    setErrors({});

    try {
      await login({ email, password });
      // Success state might be handled by parent via props
    } catch (error) {
      setErrors({ general: 'Login failed' });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Local state drives UI */}
      <input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        disabled={isSubmitting}
      />
      {/* ... */}
    </form>
  );
}
```

### **4. Performance Implications**

#### **Props Changes**
```javascript
// When props change, component re-renders
function ExpensiveComponent({ data, onUpdate }) {
  // If 'data' changes frequently, component re-renders every time
  // Use memoization if needed
  return <ExpensiveCalculation data={data} />;
}

// Memo prevents unnecessary re-renders
const MemoizedComponent = React.memo(ExpensiveComponent);
```

#### **State Changes**
```javascript
// State changes always trigger re-render of that component
function Counter() {
  const [count, setCount] = useState(0);

  // Each click re-renders the component
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>Click</button>
    </div>
  );
}
```

### **5. Testing Considerations**

#### **Props Testing**
```javascript
// Test component with different prop combinations
test('renders user name', () => {
  render(<UserCard user={{ name: 'John' }} />);
  expect(screen.getByText('John')).toBeInTheDocument();
});

test('calls onClick when button clicked', () => {
  const mockFn = jest.fn();
  render(<Button onClick={mockFn}>Click Me</Button>);

  fireEvent.click(screen.getByText('Click Me'));
  expect(mockFn).toHaveBeenCalled();
});
```

#### **State Testing**
```javascript
// Test state changes and interactions
test('counter increments when clicked', () => {
  render(<Counter />);

  const button = screen.getByRole('button');
  const display = screen.getByText(/count:/i);

  expect(display).toHaveTextContent('Count: 0');

  fireEvent.click(button);
  expect(display).toHaveTextContent('Count: 1');
});
```

## Advanced Patterns

### **1. Props with State**
```javascript
function ControlledInput({ value, onChange, placeholder }) {
  // Props control the value (controlled component)
  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
      placeholder={placeholder}
    />
  );
}

function Form() {
  // Parent uses state to control child props
  const [email, setEmail] = useState('');

  return (
    <ControlledInput
      value={email}
      onChange={setEmail}
      placeholder="Enter email"
    />
  );
}
```

### **2. State with Props**
```javascript
function UserProfile({ user, initialExpanded = false }) {
  // Component can have its own state alongside props
  const [isExpanded, setIsExpanded] = useState(initialExpanded);

  return (
    <div>
      <h3>{user.name}</h3>
      {isExpanded && <p>{user.bio}</p>}
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </button>
    </div>
  );
}
```

### **3. Prop Types and Validation**
```javascript
import PropTypes from 'prop-types';

function UserCard({ user, onEdit }) {
  return (
    <div>
      <h3>{user.name}</h3>
      <button onClick={() => onEdit(user.id)}>Edit</button>
    </div>
  );
}

UserCard.propTypes = {
  user: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
  }).isRequired,
  onEdit: PropTypes.func.isRequired,
};
```

## Common Patterns and Best Practices

### **1. Lifting State Up**
When multiple components need to share state, move it up to a common ancestor:

```javascript
function App() {
  // State lifted to common ancestor
  const [user, setUser] = useState({ name: '', email: '' });
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  return (
    <div>
      <LoginForm user={user} setUser={setUser} setIsLoggedIn={setIsLoggedIn} />
      <Profile user={user} isLoggedIn={isLoggedIn} />
    </div>
  );
}
```

### **2. Props vs State Decision Tree**
- **Does data come from parent?** → Props
- **Does data change over time?** → Probably State
- **Do siblings need this data?** → Lift to parent → Props
- **Is it computed from other props/state?** → Computed value

### **3. Readability and Maintainability**
```javascript
// Clear separation of concerns
function TodoList({ todos, onToggle, onDelete }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={() => onToggle(todo.id)}
          onDelete={() => onDelete(todo.id)}
        />
      ))}
    </ul>
  );
}

// TodoItem manages its own editing state
function TodoItem({ todo, onToggle, onDelete }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);

  // Component manages internal editing state
  // Props handle communication with parent
}
```

## Interview Questions

### Q: What's the main difference between props and state?
**A**: Props are read-only data passed to components from their parents, while state is mutable data managed within the component itself.

### Q: Should you modify props directly?
**A**: No, props should never be modified directly. Components should use props to trigger parent callbacks for data changes.

### Q: When should you use props vs state?
**A**: Use props when parent components need to pass data to children or configure child behavior. Use state when the component needs to manage data that changes over time from user interactions.

### Q: Can a component have both props and state?
**A**: Yes, most real components have both. Props provide external configuration, state manages internal behavior.

### Q: What happens if you change props directly?
**A**: It doesn't change the parent's data and can cause unexpected bugs. The component might not re-render correctly, and data synchronization issues can occur.

Props and state work together to create reactive, maintainable React applications. Props handle parent-child communication, while state manages component-specific behavior. Understanding when to use each is fundamental to React development.
