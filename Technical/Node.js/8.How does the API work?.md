# How does the API work?

APIs (Application Programming Interfaces) enable communication between different software systems. In Node.js, APIs are typically HTTP-based services that allow clients (web browsers, mobile apps, other servers) to interact with server-side functionality.

## What is an API?

An API is a set of rules and protocols that allows one software application to interact with another. APIs define how requests and responses should be formatted, what operations are available, and how to authenticate and authorize access.

## HTTP API Fundamentals

### Request-Response Cycle

```javascript
// Client makes a request
fetch('/api/users', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  }
})
.then(response => response.json())
.then(data => console.log(data));

// Server processes request and sends response
{
  "status": 200,
  "data": [
    { "id": 1, "name": "John Doe", "email": "john@example.com" },
    { "id": 2, "name": "Jane Smith", "email": "jane@example.com" }
  ]
}
```

## HTTP Methods (CRUD Operations)

### GET - Retrieve Data
```javascript
app.get('/api/users', async (req, res) => {
  const users = await User.find();
  res.json({ success: true, data: users });
});

// Usage: GET /api/users
// Returns: List of all users
```

### POST - Create New Resource
```javascript
app.post('/api/users', async (req, res) => {
  const newUser = new User(req.body);
  await newUser.save();
  res.status(201).json({ success: true, data: newUser });
});

// Usage: POST /api/users { "name": "John", "email": "john@example.com" }
// Returns: Created user object
```

### PUT - Update Entire Resource
```javascript
app.put('/api/users/:id', async (req, res) => {
  const updatedUser = await User.findByIdAndUpdate(req.params.id, req.body, { new: true });
  res.json({ success: true, data: updatedUser });
});

// Usage: PUT /api/users/123 { "name": "Updated Name", "email": "new@example.com" }
// Returns: Updated user object
```

### PATCH - Partial Update
```javascript
app.patch('/api/users/:id', async (req, res) => {
  const updatedUser = await User.findByIdAndUpdate(req.params.id, { $set: req.body }, { new: true });
  res.json({ success: true, data: updatedUser });
});

// Usage: PATCH /api/users/123 { "email": "updated@example.com" }
// Returns: Partially updated user object
```

### DELETE - Remove Resource
```javascript
app.delete('/api/users/:id', async (req, res) => {
  await User.findByIdAndDelete(req.params.id);
  res.status(204).send(); // No content
});

// Usage: DELETE /api/users/123
// Returns: 204 No Content
```

## API Architecture Patterns

### RESTful API Design

```javascript
// Resource-based routing
GET    /api/users       // List all users
GET    /api/users/:id   // Get user by ID
POST   /api/users       // Create new user
PUT    /api/users/:id   // Update user completely  
PATCH  /api/users/:id   // Update user partially
DELETE /api/users/:id   // Delete user

// Nested resources
GET    /api/users/:id/posts     // Get user's posts
POST   /api/users/:id/posts     // Create post for user
GET    /api/posts/:id/comments  // Get post's comments
```

### REST API Implementation

```javascript
const express = require('express');
const router = express.Router();

// Middleware
router.use(express.json());

// Routes
router.get('/users', async (req, res) => {
  try {
    const { page = 1, limit = 10, search } = req.query;
    const query = search ? { name: new RegExp(search, 'i') } : {};
    
    const users = await User.find(query)
      .limit(limit * 1)
      .skip((page - 1) * limit);
      
    const total = await User.countDocuments(query);
    
    res.json({
      success: true,
      data: users,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

router.post('/users', async (req, res) => {
  try {
    const user = new User(req.body);
    await user.save();
    
    res.status(201).json({
      success: true,
      data: user,
      message: 'User created successfully'
    });
  } catch (error) {
    if (error.name === 'ValidationError') {
      return res.status(400).json({ 
        success: false, 
        error: 'Validation error', 
        details: error.errors 
      });
    }
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
```

## API Authentication and Security

### JWT Token Authentication
```javascript
const jwt = require('jsonwebtoken');

// Generate token
function generateToken(user) {
  return jwt.sign(
    { id: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
}

// Verify token middleware
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
}

// Protected route
app.get('/api/profile', authenticateToken, async (req, res) => {
  const user = await User.findById(req.user.id);
  res.json({ success: true, data: user });
});
```

### API Key Authentication
```javascript
// API key middleware
function authenticateApiKey(req, res, next) {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey || !validApiKeys.includes(apiKey)) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  next();
}

app.use('/api/v1/', authenticateApiKey);
```

## Error Handling

### Standardized Error Responses
```javascript
class ApiError extends Error {
  constructor(message, statusCode = 500, details = null) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
  }
}

// Global error handler
app.use((error, req, res, next) => {
  console.error(error);
  
  if (error instanceof ApiError) {
    return res.status(error.statusCode).json({
      success: false,
      error: error.message,
      ...(error.details && { details: error.details })
    });
  }
  
  res.status(500).json({
    success: false,
    error: 'Internal server error'
  });
});

// Usage in routes
app.post('/api/users', async (req, res, next) => {
  try {
    const { email } = req.body;
    const existingUser = await User.findOne({ email });
    
    if (existingUser) {
      throw new ApiError('Email already exists', 409);
    }
    
    const user = new User(req.body);
    await user.save();
    res.status(201).json({ success: true, data: user });
  } catch (error) {
    next(error);
  }
});
```

## Input Validation

### Request Validation with Joi
```javascript
const Joi = require('joi');

// Validation schemas
const userSchema = Joi.object({
  name: Joi.string().min(2).max(50).required(),
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(18).max(120).optional()
});

// Validation middleware
function validateRequest(schema) {
  return (req, res, next) => {
    const { error } = schema.validate(req.body, { abortEarly: false });
    
    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }));
      
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors
      });
    }
    
    next();
  };
}

// Usage
app.post('/api/users', validateRequest(userSchema), async (req, res) => {
  const user = new User(req.body);
  await user.save();
  res.status(201).json({ success: true, data: user });
});
```

## Rate Limiting

### Basic Rate Limiting
```javascript
const rateLimit = require('express-rate-limit');

// General API rate limit
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  }
});

app.use('/api/', apiLimiter);

// Stricter limits for sensitive endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: {
    success: false,
    error: 'Too many login attempts, please try again later.'
  }
});

app.use('/api/auth/login', authLimiter);
```

## API Versioning

### URL Path Versioning
```javascript
// v1 routes
app.use('/api/v1/users', require('./routes/v1/users'));
app.use('/api/v1/posts', require('./routes/v1/posts'));

// v2 routes
app.use('/api/v2/users', require('./routes/v2/users'));
app.use('/api/v2/posts', require('./routes/v2/posts'));
```

### Header-Based Versioning
```javascript
app.use((req, res, next) => {
  const version = req.headers['accept-version'] || 'v1';
  
  if (version === 'v2') {
    // Use v2 handlers
    return require('./routes/v2/users')(req, res, next);
  }
  
  // Default to v1
  require('./routes/v1/users')(req, res, next);
});
```

## Caching

### Response Caching
```javascript
const nodeCache = require('node-cache');
const cache = new nodeCache({ stdTTL: 100, checkperiod: 120 });

// Cache middleware
function cacheMiddleware(duration) {
  return (req, res, next) => {
    const key = `__express__${req.originalUrl}`;
    const cachedResponse = cache.get(key);
    
    if (cachedResponse) {
      res.send(cachedResponse);
      return;
    }
    
    res.originalSend = res.send;
    res.send = (body) => {
      cache.set(key, body, duration);
      res.originalSend(body);
    };
    
    next();
  };
}

// Usage
app.get('/api/users', cacheMiddleware(300), async (req, res) => {
  const users = await User.find();
  res.json({ success: true, data: users });
});
```

## Documentation

### API Documentation with Swagger/OpenAPI
```javascript
// swagger.js
const swaggerJsdoc = require('swagger-jsdoc');
const swaggerUi = require('swagger-ui-express');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'User API',
      version: '1.0.0',
      description: 'A simple user management API'
    },
    servers: [
      {
        url: 'http://localhost:3000/api',
        description: 'Development server'
      }
    ]
  },
  apis: ['./routes/*.js']
};

const specs = swaggerJsdoc(options);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

// Document routes
/**
 * @swagger
 * /users:
 *   get:
 *     summary: Get all users
 *     responses:
 *       200:
 *         description: List of users
 */
app.get('/users', ...);
```

## Testing APIs

### Unit Tests with Jest
```javascript
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('User API', () => {
  beforeEach(async () => {
    await User.deleteMany({});
  });

  describe('GET /api/users', () => {
    it('should return all users', async () => {
      const users = [
        { name: 'John', email: 'john@example.com' },
        { name: 'Jane', email: 'jane@example.com' }
      ];
      
      await User.insertMany(users);
      
      const response = await request(app)
        .get('/api/users')
        .expect(200);
      
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveLength(2);
    });
  });

  describe('POST /api/users', () => {
    it('should create a new user', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      expect(response.body.success).toBe(true);
      expect(response.body.data.name).toBe(userData.name);
    });
  });
});
```

## API Best Practices Summary

1. **Use RESTful conventions** for resource-based URLs
2. **Implement proper HTTP status codes** (200, 201, 400, 404, 500)
3. **Validate all inputs** to prevent security vulnerabilities
4. **Use authentication and authorization** for protected endpoints
5. **Implement rate limiting** to prevent abuse
6. **Handle errors gracefully** with consistent error responses
7. **Add comprehensive logging** for debugging and monitoring
8. **Write API documentation** (Swagger/OpenAPI)
9. **Implement caching** where appropriate
10. **Add correlation IDs** for request tracing across services

## Summary

APIs in Node.js work by establishing contracts between clients and servers:
- **HTTP methods** define operations (GET, POST, PUT, DELETE)
- **URLs** specify resources and actions
- **Request/Response bodies** contain data in JSON format
- **Headers** provide metadata and authentication
- **Status codes** indicate operation results
- **Middleware** handles cross-cutting concerns (auth, validation, logging)

A robust API implementation requires attention to security, performance, documentation, and maintainability. The combination of Express.js, proper middleware, and testing ensures reliable API services that other applications can depend on.
