# What is CRUD?

CRUD represents the four basic operations that can be performed on data in any database or data storage system. The acronym stands for Create, Read, Update, and Delete - the fundamental operations used to manipulate data.

## What is CRUD?

CRUD is a fundamental concept in database operations and API design. It defines the core operations needed to manage data throughout its lifecycle.

## The Four CRUD Operations

### 1. **Create** - Adding New Data
Create operations add new data to the database or storage system.

**SQL Examples:**
```sql
INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
INSERT INTO products (name, price) VALUES ('Widget', 29.99);
```

**MongoDB Examples:**
```javascript
// Insert single document
db.users.insertOne({
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date()
});

// Insert multiple documents
db.products.insertMany([
  { name: 'Widget', price: 29.99 },
  { name: 'Gadget', price: 19.99 }
]);
```

**REST API Example:**
```
POST /api/users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}
```

**Node.js Implementation:**
```javascript
// Express.js route for creating users
app.post('/api/users', async (req, res) => {
  try {
    const newUser = new User(req.body);
    await newUser.save();
    res.status(201).json({ success: true, data: newUser });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### 2. **Read** (Retrieve) - Getting Existing Data
Read operations retrieve data from the database without modifying it.

**SQL Examples:**
```sql
-- Get all users
SELECT * FROM users;

-- Get specific user
SELECT * FROM users WHERE id = 1;

-- Get users with conditions
SELECT name, email FROM users WHERE active = true ORDER BY created_at DESC LIMIT 10;
```

**MongoDB Examples:**
```javascript
// Find all documents
db.users.find();

// Find documents with conditions
db.users.find({ active: true });

// Find specific document
db.users.findOne({ email: 'john@example.com' });

// Find with projection (select specific fields)
db.users.find({}, { name: 1, email: 1, _id: 0 });
```

**REST API Examples:**
```
GET /api/users             # Get all users
GET /api/users/123         # Get user with ID 123
GET /api/users?name=john   # Search users by name
GET /api/users?page=1&limit=10 # Paginated results
```

**Node.js Implementation:**
```javascript
// Get all users
app.get('/api/users', async (req, res) => {
  try {
    const { page = 1, limit = 10, search } = req.query;
    
    let query = {};
    if (search) {
      query = { 
        $or: [
          { name: new RegExp(search, 'i') },
          { email: new RegExp(search, 'i') }
        ]
      };
    }
    
    const users = await User.find(query)
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .sort({ createdAt: -1 });
      
    const total = await User.countDocuments(query);
    
    res.json({
      success: true,
      data: users,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get user by ID
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    res.json({ success: true, data: user });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### 3. **Update** - Modifying Existing Data
Update operations modify existing data in the database.

**SQL Examples:**
```sql
-- Update single field
UPDATE users SET email = 'newemail@example.com' WHERE id = 1;

-- Update multiple fields
UPDATE users SET 
  name = 'Jane Doe',
  email = 'jane@example.com',
  updated_at = NOW()
WHERE id = 1;
```

**MongoDB Examples:**
```javascript
// Update single document
db.users.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439011") },
  { 
    $set: { 
      name: 'Jane Doe',
      email: 'jane@example.com',
      updatedAt: new Date()
    }
  }
);

// Update multiple documents
db.users.updateMany(
  { lastLogin: { $lt: new Date('2020-01-01') } },
  { 
    $set: { status: 'inactive' },
    $unset: { sessionToken: 1 }
  }
);
```

**REST API Examples:**
```
PUT /api/users/123
Content-Type: application/json

{
  "name": "Jane Doe",
  "email": "jane@example.com"
}

// PATCH for partial updates
PATCH /api/users/123
Content-Type: application/json

{
  "email": "jane@example.com"
}
```

**Node.js Implementation:**
```javascript
// PUT - Full update
app.put('/api/users/:id', async (req, res) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );
    
    if (!updatedUser) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    res.json({ success: true, data: updatedUser });
  } catch (error) {
    if (error.name === 'ValidationError') {
      return res.status(400).json({ success: false, error: 'Validation error' });
    }
    res.status(500).json({ success: false, error: error.message });
  }
});

// PATCH - Partial update
app.patch('/api/users/:id', async (req, res) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id,
      { $set: req.body, updatedAt: new Date() },
      { new: true }
    );
    
    if (!updatedUser) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    res.json({ success: true, data: updatedUser });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### 4. **Delete** - Removing Data
Delete operations remove data from the database.

**SQL Examples:**
```sql
-- Delete specific user
DELETE FROM users WHERE id = 1;

-- Delete with conditions
DELETE FROM users WHERE last_login < '2020-01-01';

-- Soft delete (deactivate instead of delete)
UPDATE users SET active = false WHERE id = 1;
```

**MongoDB Examples:**
```javascript
// Delete single document
db.users.deleteOne({ _id: ObjectId("507f1f77bcf86cd799439011") });

// Delete multiple documents
db.users.deleteMany({ lastLogin: { $lt: new Date('2020-01-01') } });

// Soft delete
db.users.updateOne(
  { _id: ObjectId("507f1f77bcf86cd799439011") },
  { $set: { isDeleted: true, deletedAt: new Date() } }
);
```

**REST API Examples:**
```
DELETE /api/users/123
```

**Node.js Implementation:**
```javascript
// Hard delete
app.delete('/api/users/:id', async (req, res) => {
  try {
    const deletedUser = await User.findByIdAndDelete(req.params.id);
    
    if (!deletedUser) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    res.json({ 
      success: true, 
      message: 'User deleted successfully',
      data: deletedUser
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Soft delete
app.patch('/api/users/:id/deactivate', async (req, res) => {
  try {
    const deactivatedUser = await User.findByIdAndUpdate(
      req.params.id,
      { 
        $set: { 
          isActive: false, 
          deactivatedAt: new Date() 
        }
      },
      { new: true }
    );
    
    if (!deactivatedUser) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    res.json({ success: true, data: deactivatedUser });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

## CRUD in Different Contexts

### Database CRUD Operations
- **Relational Databases**: INSERT, SELECT, UPDATE, DELETE
- **NoSQL Databases**: insertOne, find, updateOne, deleteOne
- **ORM Operations**: create(), findAll(), update(), destroy()

### HTTP CRUD Mapping
| Operation | HTTP Method | Endpoint | Description |
|-----------|-------------|----------|-------------|
| Create | POST | `/api/resources` | Create new resource |
| Read | GET | `/api/resources` | Get all resources |
| Read | GET | `/api/resources/:id` | Get single resource |
| Update | PUT | `/api/resources/:id` | Update entire resource |
| Update | PATCH | `/api/resources/:id` | Update partial resource |
| Delete | DELETE | `/api/resources/:id` | Delete resource |

## Best Practices

### 1. **Transaction Support**
```javascript
// SQL transaction
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;

// MongoDB transaction
const session = db.getMongo().startSession();

session.withTransaction(async () => {
  await db.accounts.updateOne(
    { _id: 1 }, 
    { $inc: { balance: -100 } },
    { session }
  );
  
  await db.accounts.updateOne(
    { _id: 2 }, 
    { $inc: { balance: 100 } },
    { session }
  );
});
```

### 2. **Validation**
```javascript
const Joi = require('joi');

// Create schema validation
const createUserSchema = Joi.object({
  name: Joi.string().min(2).max(50).required(),
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(18).max(120)
});

// Update schema validation
const updateUserSchema = Joi.object({
  name: Joi.string().min(2).max(50),
  email: Joi.string().email(),
  age: Joi.number().integer().min(18).max(120)
}).min(1); // At least one field required

// Middleware for validation
function validateCreate(req, res, next) {
  const { error } = createUserSchema.validate(req.body);
  if (error) {
    return res.status(400).json({ success: false, error: error.details[0].message });
  }
  next();
}
```

### 3. **Error Handling**
```javascript
// Comprehensive error handling
app.post('/api/users', validateCreate, async (req, res) => {
  try {
    // Check for duplicate email
    const existingUser = await User.findOne({ email: req.body.email });
    if (existingUser) {
      return res.status(409).json({ 
        success: false, 
        error: 'User with this email already exists' 
      });
    }
    
    const user = new User(req.body);
    await user.save();
    
    res.status(201).json({ success: true, data: user });
  } catch (error) {
    // Handle different types of errors
    if (error.name === 'ValidationError') {
      return res.status(400).json({ 
        success: false, 
        error: 'Validation failed', 
        details: error.errors 
      });
    }
    
    if (error.name === 'MongoError' && error.code === 11000) {
      return res.status(409).json({ 
        success: false, 
        error: 'Duplicate key error' 
      });
    }
    
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});
```

### 4. **Soft Deletes**
```javascript
// Model with soft delete support
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  isDeleted: { type: Boolean, default: false },
  deletedAt: Date
});

// Query middleware to exclude soft deleted records
userSchema.pre('find', function() {
  this.where({ isDeleted: { $ne: true } });
});

userSchema.pre('findOne', function() {
  this.where({ isDeleted: { $ne: true } });
});

// Soft delete method
userSchema.methods.softDelete = function() {
  this.isDeleted = true;
  this.deletedAt = new Date();
  return this.save();
};
```

## CRUD Operations in Frontend

### React Example with API
```javascript
// CRUD operations in a React component
function UserManager() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  
  // CREATE
  const createUser = async (userData) => {
    setLoading(true);
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      const newUser = await response.json();
      setUsers(prev => [...prev, newUser.data]);
    } finally {
      setLoading(false);
    }
  };
  
  // READ
  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/users');
      const data = await response.json();
      setUsers(data.data);
    } finally {
      setLoading(false);
    }
  };
  
  // UPDATE
  const updateUser = async (userId, userData) => {
    setLoading(true);
    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      const updatedUser = await response.json();
      setUsers(prev => prev.map(user => 
        user.id === userId ? updatedUser.data : user
      ));
    } finally {
      setLoading(false);
    }
  };
  
  // DELETE
  const deleteUser = async (userId) => {
    setLoading(true);
    try {
      await fetch(`/api/users/${userId}`, { method: 'DELETE' });
      setUsers(prev => prev.filter(user => user.id !== userId));
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchUsers();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div>
      {/* UI for CRUD operations */}
    </div>
  );
}
```

## Performance Considerations

### Indexing for Read Operations
```sql
-- SQL indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at);

-- MongoDB indexes
db.users.createIndex({ email: 1 });
db.users.createIndex({ createdAt: -1 });
```

### Caching Strategies
```javascript
// Redis caching for read operations
const redis = require('redis');
const client = redis.createClient();

// Cache read operations
app.get('/api/users', async (req, res) => {
  const cacheKey = 'users';
  const cachedUsers = await client.get(cacheKey);
  
  if (cachedUsers) {
    return res.json(JSON.parse(cachedUsers));
  }
  
  const users = await User.find();
  await client.setex(cacheKey, 300, JSON.stringify(users)); // Cache for 5 minutes
  
  res.json(users);
});

// Invalidate cache on updates
app.post('/api/users', async (req, res) => {
  const user = new User(req.body);
  await user.save();
  
  // Clear cache
  await client.del('users');
  
  res.status(201).json(user);
});
```

## Summary

CRUD operations form the foundation of data manipulation in any application:

- **Create**: Adding new data (INSERT/insertOne/POST)
- **Read**: Retrieving data (SELECT/find/GET) 
- **Update**: Modifying data (UPDATE/updateOne/PUT/PATCH)
- **Delete**: Removing data (DELETE/deleteOne/DELETE)

These operations map directly to HTTP methods in REST APIs and form the basis for building complete database-driven applications. Proper implementation requires attention to validation, error handling, performance, and security.
