# What is the difference between PUT and Patch?

PUT and PATCH are both HTTP methods used for updating resources in RESTful APIs, but they serve different purposes and have distinct semantics for how they handle updates. Understanding their differences ensures you use the appropriate method for your API design.

## HTTP Method Comparison

| Feature | PUT | PATCH |
|---------|-----|-------|
| **Purpose** | Complete resource replacement | Partial resource modification |
| **Idempotent** | Yes | Yes |
| **Safe** | No | No |
| **Data Required** | All fields mandatory | Only modified fields |
| **Server Processing** | Replace entire resource | Apply patch to resource |
| **Client Knowledge** | Must know full resource | Can know partial resource |
| **Error Handling** | Complete replacement | Applied to existing resource |

## PUT Method

### Purpose
PUT replaces the entire resource with the data provided in the request. It requires the client to send a complete representation of the resource.

### Characteristics
- **Idempotent**: Multiple identical PUT requests have the same effect as a single request
- **Complete Replacement**: The entire resource is replaced, not just modified
- **Full Data Required**: Client must provide all fields of the resource
- **Resource Creation**: Some APIs allow PUT for resource creation if the client specifies the ID

### Syntax and Examples
```http
PUT /api/users/123 HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 74

{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30,
  "role": "admin"
}
```

### Node.js Implementation
```javascript
// PUT - Complete resource replacement
app.put('/api/users/:id', async (req, res) => {
  try {
    // PUT expects the complete resource representation
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id,
      req.body, // Complete resource data
      { 
        new: true,           // Return updated document
        runValidators: true // Run validation
      }
    );

    if (!updatedUser) {
      return res.status(404).json({ 
        success: false, 
        error: 'User not found' 
      });
    }

    res.json({
      success: true,
      data: updatedUser,
      message: 'User completely updated'
    });
  } catch (error) {
    // Validation errors if required fields are missing
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: Object.values(error.errors).map(err => err.message)
      });
    }

    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// PUT can create resources if client provides ID
app.put('/api/users/:id', async (req, res) => {
  try {
    // Check if resource exists
    const existingUser = await User.findById(req.params.id);
    
    if (existingUser) {
      // Update existing
      const updatedUser = await User.findByIdAndUpdate(
        req.params.id,
        req.body,
        { new: true, runValidators: true, upsert: false }
      );
      return res.json({ success: true, data: updatedUser });
    } else {
      // Create new resource with provided ID
      const newUser = new User({ ...req.body, _id: req.params.id });
      await newUser.save();
      return res.status(201).json({ success: true, data: newUser });
    }
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### Frontend Usage
```javascript
// PUT requires complete resource data
const updateUser = async (userId, userData) => {
  // userData must contain ALL fields for the user
  const response = await fetch(`/api/users/${userId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      id: userId,
      name: userData.name,
      email: userData.email,
      age: userData.age,
      role: userData.role,
      // ALL other fields must be included
      address: userData.address,
      phone: userData.phone,
      preferences: userData.preferences
    })
  });

  return response.json();
};
```

## PATCH Method

### Purpose
PATCH applies partial modifications to a resource. It allows the client to send only the fields that need to be changed, reducing bandwidth and improving performance.

### Characteristics
- **Idempotent**: Multiple identical PATCH requests have the same effect
- **Partial Updates**: Only specified fields are modified
- **Flexible**: Client can send any valid subset of fields
- **More Efficient**: Smarter for bandwidth and processing

### Syntax and Examples
```http
PATCH /api/users/123 HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 33

{
  "email": "john.doe@example.com"
}
```

### PATCH Media Types

#### JSON Patch (RFC 6902)
```http
PATCH /api/users/123 HTTP/1.1
Content-Type: application/json-patch+json

[
  { "op": "replace", "path": "/email", "value": "new@example.com" },
  { "op": "remove", "path": "/oldField" },
  { "op": "add", "path": "/preferences/theme", "value": "dark" }
]
```

#### JSON Merge Patch (RFC 7396)
```http
PATCH /api/users/123 HTTP/1.1
Content-Type: application/merge-patch+json

{
  "email": "new@example.com",
  "preferences": { "theme": "dark" }
}
```

### Node.js Implementation
```javascript
// PATCH - Partial resource modification
app.patch('/api/users/:id', async (req, res) => {
  try {
    // PATCH allows partial updates - only sent fields are updated
    const updateData = { ...req.body };
    
    // Add updated timestamp
    updateData.updatedAt = new Date();
    
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id,
      { $set: updateData }, // Only update provided fields
      { 
        new: true,          // Return updated document
        runValidators: true // Validate updated fields
      }
    );

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    res.json({
      success: true,
      data: updatedUser,
      message: 'User partially updated'
    });
  } catch (error) {
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: Object.values(error.errors).map(err => err.message)
      });
    }

    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// PATCH with JSON Patch support
const jsonpatch = require('fast-json-patch');

app.patch('/api/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }

    // Apply JSON Patch operations
    const updatedUser = jsonpatch.applyPatch(user, req.body).newDocument;

    // Save the modified document
    await updatedUser.save();

    res.json({ success: true, data: updatedUser });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### Frontend Usage
```javascript
// PATCH sends only modified fields
const updateUserEmail = async (userId, newEmail) => {
  const response = await fetch(`/api/users/${userId}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      email: newEmail  // Only the field being changed
    })
  });

  return response.json();
};

// Batch updates with PATCH
const updateUserPreferences = async (userId, preferences) => {
  const response = await fetch(`/api/users/${userId}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      preferences: preferences  // Only preferences object
    })
  });

  return response.json();
};
```

## When to Use Each Method

### Use PUT When:
- **Complete Resource Updates**: You have all the data and want to replace the entire resource
- **Idempotent Operations**: Multiple identical requests should have the same result
- **Resource Creation**: Creating resources with client-specified IDs
- **Small Resources**: The resource is small enough that sending complete data is efficient

### Use PATCH When:
- **Partial Updates**: Only some fields need to be changed
- **Bandwidth Conservation**: Reducing payload size is important
- **Large Resources**: The complete resource is large and complex
- **Real-time Updates**: Making small, frequent modifications
- **Optimistic UI**: Updating individual fields as users type

## Real-World Examples

### E-commerce Product Updates
```javascript
// PUT - Complete product replacement
// Requires ALL product fields
PUT /api/products/456
{
  "name": "Wireless Headphones",
  "price": 99.99,
  "description": "...",
  "category": "Electronics",
  "inStock": true,
  "weight": 0.25,
  "dimensions": { ... },
  "reviews": [...],
  "specifications": { ... }
}

// PATCH - Price update only
PATCH /api/products/456
{
  "price": 89.99
}
```

### User Profile Management
```javascript
// PUT - Full profile update
PUT /api/users/123
{
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30,
  "address": { "street": "...", "city": "..." },
  "phone": "555-0123",
  "preferences": { "theme": "dark", "notifications": true }
}

// PATCH - Change email only
PATCH /api/users/123
{
  "email": "john.doe@example.com"
}

// PATCH - Update nested preferences
PATCH /api/users/123
{
  "preferences": {
    "theme": "light"
  }
}
```

## Database Operations

### SQL Differences
```sql
-- PUT equivalent (complete replacement)
UPDATE users 
SET name = 'John', 
    email = 'john@example.com',
    age = 30,
    phone = '555-0123',
    updated_at = NOW()
WHERE id = 123;

-- PATCH equivalent (partial update)
UPDATE users 
SET email = 'john.doe@example.com',
    updated_at = NOW()
WHERE id = 123;
```

### MongoDB Differences
```javascript
// PUT equivalent
db.users.updateOne(
  { _id: ObjectId('...') },
  {
    $set: {
      name: 'John',
      email: 'john@example.com',
      age: 30,
      phone: '555-0123',
      updatedAt: new Date()
    }
  }
);

// PATCH equivalent
db.users.updateOne(
  { _id: ObjectId('...') },
  {
    $set: {
      email: 'john.doe@example.com',
      updatedAt: new Date()
    }
  }
);
```

## Error Handling Differences

### PUT Error Responses
- **400 Bad Request**: Missing required fields or invalid data
- **404 Not Found**: Resource doesn't exist
- **409 Conflict**: Trying to create resource that already exists
- **422 Unprocessable Entity**: Validation errors on complete data

### PATCH Error Responses
- **400 Bad Request**: Invalid patch format or unsupported operations
- **404 Not Found**: Resource doesn't exist
- **409 Conflict**: Patch conflicts with current state
- **422 Unprocessable Entity**: Validation errors on partial data

## Performance Considerations

### PUT Performance
- **Bulk Updates**: Can update multiple fields in one operation
- **Complete Replacement**: Database can perform complete document replacement
- **Validation**: Full validation can be more resource-intensive
- **Network**: Larger payloads increase network overhead

### PATCH Performance
- **Selective Updates**: Only specific fields are processed and validated
- **Reduced Bandwidth**: Smaller payloads reduce network transfer time
- **Database Efficiency**: Field-level updates are more efficient
- **Client Flexibility**: Enables finer-grained update operations

## Best Practices

### Choosing the Right Method
```javascript
// Use PUT for complete replacements
// e.g., replacing entire user profile from a form
app.put('/api/profiles/:userId', async (req, res) => {
  // Complete profile replacement
});

// Use PATCH for specific field updates
// e.g., changing password, updating status
app.patch('/api/users/:userId/password', async (req, res) => {
  // Partial update: password only
});

app.patch('/api/posts/:postId/status', async (req, res) => {
  // Partial update: status only
});
```

### API Documentation
```javascript
// Swagger/OpenAPI documentation

/**
 * @swagger
 * /api/users/{id}:
 *   put:
 *     summary: Replace entire user
 *     description: Replaces the complete user resource with provided data
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name: { type: string }
 *               email: { type: string }
 *               age: { type: integer }
 *               role: { type: string }
 *   patch:
 *     summary: Update user partially
 *     description: Applies partial modifications to user resource
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name: { type: string }
 *               email: { type: string }
 *               age: { type: integer }
 *               role: { type: string }
 */
```

## Summary

**PUT** and **PATCH** both update resources but serve different purposes:

- **PUT** replaces the entire resource and requires complete data from the client. Use when you need to ensure data consistency or perform complete replacements.

- **PATCH** modifies specific parts of a resource and accepts partial data. Use for efficient updates where only certain fields need to change.

The choice between PUT and PATCH affects:
- **Client complexity**: PUT requires more data preparation
- **Network efficiency**: PATCH reduces bandwidth usage
- **Server processing**: PATCH enables more granular validation and processing
- **API design**: Different semantic meanings for different operations

Understanding these differences ensures you design APIs that are efficient, maintainable, and follow RESTful principles appropriately.
