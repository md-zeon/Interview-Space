# How will you secure an API?

Securing APIs is crucial for protecting sensitive data, preventing unauthorized access, and ensuring the integrity of your application. A comprehensive API security strategy involves multiple layers of protection at different levels of the technology stack.

## Authentication vs Authorization

### Authentication (Who you are)
- Verifying user identity
- Login mechanisms, tokens, certificates
- Answers "Are you who you say you are?"

### Authorization (What you can do)
- Controlling access to resources
- Role-based permissions, policies
- Answers "What are you allowed to access?"

## Authentication Methods

### 1. **Token-Based Authentication (JWT)**
Most common modern approach for API security.

```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

// User registration
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 12);
    const user = new User({ email, password: hashedPassword });
    await user.save();
    
    // Generate JWT
    const token = jwt.sign(
      { userId: user._id, email: user.email },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.status(201).json({ token, user: { id: user._id, email: user.email } });
  } catch (error) {
    res.status(500).json({ error: 'Registration failed' });
  }
});

// User login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Verify password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Generate JWT
    const token = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    res.json({ token, user: { id: user._id, email: user.email, role: user.role } });
  } catch (error) {
    res.status(500).json({ error: 'Login failed' });
  }
});

// JWT verification middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};
```

### 2. **API Key Authentication**
Simpler authentication for service-to-service communication.

```javascript
// API Key middleware
const validApiKeys = process.env.VALID_API_KEYS.split(',');

const authenticateApiKey = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey || !validApiKeys.includes(apiKey)) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  // Find associated user/service
  req.apiUser = { apiKey, role: 'service' };
  next();
};

// Rate limiting per API key
const clientLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each API key to 100 requests per windowMs
  keyGenerator: (req) => {
    return req.headers['x-api-key'] || req.ip;
  }
});
```

### 3. **OAuth 2.0**
Delegating authentication to trusted identity providers.

```javascript
// Google OAuth example
const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: '/auth/google/callback'
  },
  async (accessToken, refreshToken, profile, done) => {
    // Find or create user
    let user = await User.findOne({ googleId: profile.id });
    if (!user) {
      user = await User.create({
        googleId: profile.id,
        name: profile.displayName,
        email: profile.emails[0].value
      });
    }
    return done(null, user);
  }
));

// OAuth routes
app.get('/auth/google', passport.authenticate('google', { scope: ['profile', 'email'] }));

app.get('/auth/google/callback', 
  passport.authenticate('google', { failureRedirect: '/login' }),
  (req, res) => {
    // Redirect with JWT token
    const token = jwt.sign({ userId: req.user._id }, process.env.JWT_SECRET);
    res.redirect(`/?token=${token}`);
  }
);
```

## Authorization Controls

### 1. **Role-Based Access Control (RBAC)**

```javascript
const roles = {
  admin: ['read', 'write', 'delete', 'manage_users'],
  editor: ['read', 'write'],
  viewer: ['read']
};

// Authorization middleware
const authorize = (requiredPermissions) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const userPermissions = roles[req.user.role] || [];
    const hasPermission = requiredPermissions.every(permission => 
      userPermissions.includes(permission)
    );
    
    if (!hasPermission) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
};

// Protected routes
app.get('/api/users', authenticateToken, authorize(['read']), (req, res) => {
  // Users can read user data
});

app.delete('/api/users/:id', authenticateToken, authorize(['manage_users']), (req, res) => {
  // Only admins can delete users
});
```

### 2. **Resource-Based Authorization**

```javascript
// Check if user owns the resource
const checkResourceOwnership = (resourceType) => {
  return async (req, res, next) => {
    try {
      const resourceId = req.params.id;
      const resource = await getResourceById(resourceType, resourceId);
      
      if (!resource) {
        return res.status(404).json({ error: 'Resource not found' });
      }
      
      // Check ownership or admin rights
      if (resource.ownerId !== req.user.userId && req.user.role !== 'admin') {
        return res.status(403).json({ error: 'Access denied' });
      }
      
      req.resource = resource;
      next();
    } catch (error) {
      res.status(500).json({ error: 'Authorization check failed' });
    }
  };
};

// Usage
app.put('/api/posts/:id', 
  authenticateToken, 
  checkResourceOwnership('post'), 
  async (req, res) => {
    // User can update their own post
    const updatedPost = await updatePost(req.params.id, req.body);
    res.json(updatedPost);
  }
);
```

## Input Validation and Sanitization

### 1. **Request Validation**

```javascript
const Joi = require('joi');

// Input validation schemas
const createUserSchema = Joi.object({
  name: Joi.string().min(2).max(50).required().trim(),
  email: Joi.string().email().required().lowercase().trim(),
  password: Joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/).required(),
  role: Joi.string().valid('user', 'admin').default('user')
});

const validateRequest = (schema) => {
  return (req, res, next) => {
    const { error, value } = schema.validate(req.body, { 
      abortEarly: false,
      stripUnknown: true 
    });
    
    if (error) {
      const errors = error.details.map(detail => ({
        field: detail.path.join('.'),
        message: detail.message
      }));
      
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors
      });
    }
    
    req.body = value; // Use sanitized values
    next();
  };
};

// Usage
app.post('/api/users', 
  validateRequest(createUserSchema), 
  async (req, res) => {
    const user = new User(req.body);
    await user.save();
    res.status(201).json(user);
  }
);
```

### 2. **SQL Injection Prevention**
Always use parameterized queries or ORM methods.

```javascript
// Safe: Parameterized query
const user = await db.query(
  'SELECT * FROM users WHERE email = ? AND active = ?',
  [email, true]
);

// Safe: ORM methods
const user = await User.findOne({ 
  email: email, 
  active: true 
});
```

## Rate Limiting

```javascript
const rateLimit = require('express-rate-limit');

// General API rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true, // Return rate limit info in `RateLimit-*` headers
  legacyHeaders: false, // Disable `X-RateLimit-*` headers
});

// Stricter limits for sensitive operations
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // Only 5 attempts per 15 minutes
  message: {
    success: false,
    error: 'Too many login attempts, please try again later.'
  }
});

const passwordResetLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // Only 3 reset requests per hour
  message: {
    success: false,
    error: 'Too many password reset attempts, please try again later.'
  }
});

// Apply rate limiting
app.use('/api/', apiLimiter);
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/password-reset', passwordResetLimiter);
```

## CORS (Cross-Origin Resource Sharing)

```javascript
const cors = require('cors');

// Basic CORS configuration
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://yourdomain.com', 'https://app.yourdomain.com'] 
    : ['http://localhost:3000'], // React dev server
  credentials: true, // Allow cookies/authorization headers
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key']
}));

// Pre-flight requests are handled automatically by cors middleware
```

## Data Encryption

### 1. **Password Hashing**
Always hash passwords before storing.

```javascript
const bcrypt = require('bcrypt');

// Hash password during registration
const saltRounds = 12;
const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);
await User.create({ email, password: hashedPassword });

// Verify password during login
const isValidPassword = await bcrypt.compare(plainPassword, hashedPassword);
```

### 2. **Data Encryption**
```javascript
const crypto = require('crypto');

// Encrypt sensitive data
function encryptData(data) {
  const algorithm = 'aes-256-cbc';
  const key = crypto.scryptSync(process.env.ENCRYPTION_KEY, 'salt', 32);
  const iv = crypto.randomBytes(16);
  
  const cipher = crypto.createCipher(algorithm, key);
  let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  return { 
    encryptedData: encrypted, 
    iv: iv.toString('hex') 
  };
}

// API route that handles encrypted data
app.post('/api/sensitive-data', 
  authenticateToken, 
  (req, res) => {
    const encrypted = encryptData(req.body);
    // Store encrypted data...
    res.json({ success: true, id: storedId });
  }
);
```

## HTTPS and Transport Security

### 1. **Always Use HTTPS in Production**
```javascript
// HTTPS configuration
const https = require('https');
const fs = require('fs');

// SSL certificates
const privateKey = fs.readFileSync('ssl/private.key', 'utf8');
const certificate = fs.readFileSync('ssl/certificate.crt', 'utf8');
const caBundle = fs.readFileSync('ssl/ca-bundle.crt', 'utf8');

const credentials = {
  key: privateKey,
  cert: certificate,
  ca: caBundle
};

// Redirect HTTP to HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https') {
    res.redirect(`https://${req.header('host')}${req.url}`);
  } else {
    next();
  }
});

// Start HTTPS server
const httpsServer = https.createServer(credentials, app);
httpsServer.listen(443);
```

### 2. **Security Headers**

```javascript
const helmet = require('helmet');

// Apply security headers
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"],
      styleSrc: ["'self'", 'https://fonts.googleapis.com'],
      // ... more directives
    }
  },
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubdomains: true
  },
  noSniff: true,
  xssFilter: true
}));
```

## Logging and Monitoring

### 1. **Request Logging**
```javascript
const morgan = require('morgan');

// Request logging middleware
app.use(morgan('combined', {
  stream: fs.createWriteStream('./logs/access.log', { flags: 'a' })
}));

// Custom security logging
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${req.method} ${req.url} ${res.statusCode} - ${duration}ms`);
    
    // Log suspicious activities
    if (res.statusCode >= 400) {
      console.warn(`Suspicious activity: ${req.ip} ${req.method} ${req.url}`);
    }
  });
  
  next();
});
```

### 2. **Error Tracking**
```javascript
const Sentry = require('@sentry/node');

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  // Capture specific error types
  beforeSend: (event, hint) => {
    // Don't send sensitive user data
    if (event.user) {
      event.user = { ...event.user, password: undefined };
    }
    return event;
  }
});

// Global error handler with error tracking
app.use((error, req, res, next) => {
  // Log to Sentry
  Sentry.captureException(error);
  
  // Log locally
  console.error(error);
  
  // Don't expose internal errors
  res.status(500).json({ 
    success: false, 
    error: 'Internal server error' 
  });
});
```

## Testing Security

```javascript
// Security test framework example
describe('API Security', () => {
  it('should reject requests without authentication', async () => {
    const response = await request(app)
      .get('/api/protected')
      .expect(401);
  });
  
  it('should reject expired tokens', async () => {
    const expiredToken = jwt.sign({ userId: 1 }, 'secret', { expiresIn: '-1h' });
    const response = await request(app)
      .get('/api/protected')
      .set('Authorization', `Bearer ${expiredToken}`)
      .expect(403);
  });
  
  it('should respect rate limits', async () => {
    // Make multiple rapid requests
    const promises = [];
    for (let i = 0; i < 110; i++) {
      promises.push(
        request(app).get('/api/public').expect(429)
      );
    }
    await Promise.all(promises);
  });
});
```

## API Security Best Practices Summary

### 1. **Authentication**
   - Use JWT or secure API keys
   - Implement proper password policies
   - Use HTTPS only

### 2. **Authorization** 
   - Implement RBAC or ABAC
   - Validate resource ownership
   - Use least privilege principle

### 3. **Input Validation**
   - Validate and sanitize all inputs
   - Use whitelist validation
   - Prevent injection attacks

### 4. **Rate Limiting**
   - Implement per-user/per-IP limits
   - Different limits for different endpoints
   - Monitor for abuse patterns

### 5. **Transport Security**
   - Always use HTTPS
   - Implement proper SSL/TLS certificates
   - Enable security headers

### 6. **Monitoring & Logging**
   - Log authentication attempts
   - Monitor for suspicious activities
   - Use error tracking services

### 7. **Regular Updates**
   - Keep dependencies updated
   - Regularly review security patches
   - Audit third-party packages

### Key Security Headers to Implement

```javascript
// Security headers middleware
app.use((req, res, next) => {
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY');
  
  // Prevent MIME sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');
  
  // Enable XSS filter
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  // Content Security Policy
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  
  // HSTS (HTTP Strict Transport Security)
  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubdomains');
  
  next();
});
```

## Summary

Securing an API requires a defense-in-depth approach with multiple layers of protection:

- **Network Level**: HTTPS, CORS, rate limiting
- **Transport Level**: Encryption, secure headers  
- **Application Level**: Authentication, authorization, input validation
- **Data Level**: Parameterized queries, data encryption
- **Monitoring Level**: Logging, error tracking, alerts

A secure API not only protects sensitive data but also ensures the reliability and performance of your application. Regular security audits, keeping dependencies updated, and staying informed about emerging threats are essential for maintaining API security over time.
