# What is the difference between a Docker image and a Docker container?

## Docker Image vs Docker Container

While often used interchangeably in casual conversation, Docker images and containers are fundamentally different concepts with distinct roles in the containerization ecosystem.

## Docker Image

A Docker image is a **static, immutable template** or blueprint that contains all the instructions and dependencies needed to create a runnable instance of an application.

### Characteristics of a Docker Image:

- **Read-only**: Images cannot be modified once created
- **Template-based**: Serves as a blueprint for containers
- **Layered structure**: Built from multiple read-only layers
- **Stored in registries**: Can be shared and distributed via registries like Docker Hub
- **Versionable**: Different tags represent different versions of the same image

### Creating a Docker Image:

Images are built using a `Dockerfile` through the `docker build` command:

```dockerfile
# Example Dockerfile
FROM node:14-alpine
WORKDIR /app
COPY package.json .
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

```bash
docker build -t my-node-app .
```

## Docker Container

A Docker container is a **running instance of a Docker image**. It's the actual execution environment where your application code runs.

### Characteristics of a Docker Container:

- **Read-write**: Containers have a thin read-write layer on top of the image
- **Runnable**: Active process executing your application
- **Isolated**: Each container runs in its own namespace, isolated from the host and other containers
- **Ephemeral**: Containers can be started, stopped, and destroyed
- **Derived from images**: Always created from an image

### Running a Container:

```bash
# Run a container from an image
docker run -p 3000:3000 my-node-app

# List running containers
docker ps

# List all containers (including stopped)
docker ps -a
```

## Key Differences

### 1. Mutability

- **Image**: Immutable - cannot be changed
- **Container**: Mutable - can be modified during runtime

### 2. Persistence

- **Image**: Persists until deleted from registry/local storage
- **Container**: Ephemeral - data is lost when container is removed

### 3. Purpose

- **Image**: Used for building and distributing applications
- **Container**: Used for running and executing applications

### 4. Storage

- **Image**: Stored in Docker registry or local image cache
- **Container**: Has its own filesystem layer plus the image layers beneath

### 5. Lifecycle

- **Image**: Created via `docker build`, can be pushed/pulled from registries
- **Container**: Created via `docker run`, can be started/stopped/removed

## Analogy

Think of it like this:

- **Image** = Class definition in programming (static, unchanging)
- **Container** = Instance of a class (active, running object)

Or in cooking terms:

- **Image** = Recipe (instructions and ingredients)
- **Container** = Baked cake (actual result of following the recipe)

## Practical Example

```bash
# Create/build an image (recipe)
docker build -t web-app:v1.0 .

# Run container instances (baked cakes from the recipe)
docker run -d -p 8080:80 --name web1 web-app:v1.0
docker run -d -p 8081:80 --name web2 web-app:v1.0

# You can have multiple containers from the same image
# But only one image remains (can be updated/tagged differently)
```

## Image Layers and Container Filesystem

When a container is created from an image:

```
Container Layers:
┌─────────────────────────────────┐
│ Container Layer (Read-Write)    │ ← Changes made during container runtime
├─────────────────────────────────┤
│ ┌─────────────────────────────┐ │
│ │     Application Layer       │ │
│ ├─────────────────────────────┤ │
│ │     Dependencies Layer      │ │
│ ├─────────────────────────────┤ │
│ │     OS Layer / Runtime      │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

The image layers are shared across all containers created from the same image, making containers lightweight.

## Container States

Containers can exist in different states:

- **Created**: Container is created but not running
- **Running**: Container is active and executing
- **Paused**: Container execution is suspended
- **Stopped**: Container is stopped but retains its state
- **Dead**: Container has issues and cannot be restarted

```bash
# Check container state
docker ps -a

# Container state transitions
docker stop container_name     # Running → Stopped
docker start container_name    # Stopped → Running
docker pause container_name    # Running → Paused
docker unpause container_name  # Paused → Running
docker rm container_name       # Any state → Removed
```

## Summary

| Aspect          | Docker Image            | Docker Container              |
| --------------- | ----------------------- | ----------------------------- |
| **Nature**      | Static template         | Running instance              |
| **Mutability**  | Read-only               | Read-write capable            |
| **Purpose**     | Build & distribute      | Execute & run                 |
| **Persistence** | Long-term               | Short-term                    |
| **Storage**     | Registry/cache          | Host filesystem + image       |
| **Commands**    | `build`, `push`, `pull` | `run`, `start`, `stop`        |
| **Lifecyle**    | Versioned & shared      | Created → Run → Stop → Remove |

Understanding this distinction is crucial for effective container management and deployment strategies. Images are your application "blueprints," while containers are the actual "running applications."
