# How do you run a Docker container?

## Running Docker Containers

Running a Docker container means creating an instance of a Docker image and executing it. This is accomplished using the `docker run` command, which is one of the most frequently used Docker commands.

## The docker run Command

The basic syntax for running a container is:

```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

### Common Options:

- `-d, --detach`: Run container in background
- `-i, --interactive`: Keep STDIN open even if not attached
- `-t, --tty`: Allocate a pseudo-TTY
- `-p, --publish`: Publish container's port to host
- `--name`: Assign a name to container
- `-e, --env`: Set environment variables
- `-v, --volume`: Bind mount a volume
- `--rm`: Automatically remove the container when it exits
- `--network`: Connect container to a network
- `--restart`: Restart policy for container

## Basic Container Run Examples

### Running a Simple Container

```bash
# Run a hello-world container (will exit after printing)
docker run hello-world

# Run an interactive Ubuntu container
docker run -it ubuntu bash

# Run a container in background
docker run -d nginx
```

### Port Mapping

```bash
# Map container port 80 to host port 8080
docker run -d -p 8080:80 nginx

# Map multiple ports
docker run -d -p 3000:3000 -p 3001:3001 myapp

# Map all exposed ports randomly
docker run -d -P nginx
```

### Environment Variables

```bash
# Set single environment variable
docker run -e NODE_ENV=production -d myapp

# Set multiple environment variables
docker run -e DATABASE_URL=mysql://... -e REDIS_URL=redis://... -d myapp

# Load environment variables from file
docker run --env-file .env -d myapp
```

### Interactive Mode

```bash
# Run bash in Ubuntu container
docker run -it ubuntu bash

# Run Python interactive shell
docker run -it python:3.9 python

# Attach to running container
docker exec -it container_name bash
```

## Container Lifecycle

### Starting a Container

```bash
# Create and start container
docker run -d --name myapp myimage

# Start a stopped container
docker start myapp
```

### Stopping a Container

```bash
# Stop running container gracefully
docker stop myapp

# Stop immediately (force)
docker kill myapp
```

### Removing Containers

```bash
# Remove stopped container
docker rm myapp

# Remove running container (force)
docker rm -f myapp

# Remove all stopped containers
docker container prune
```

## Volume Mounting

### Bind Mounts

```bash
# Mount host directory to container
docker run -v /host/path:/container/path -d myapp

# Mount with specific permissions (read-only)
docker run -v /host/path:/container/path:ro -d myapp

# Named volumes
docker run -v mydata:/container/path -d myapp
```

### Volumes

```bash
# Create a volume
docker volume create mydata

# Use the volume
docker run -v mydata:/app/data -d myapp

# List volumes
docker volume ls

# Inspect volume
docker volume inspect mydata

# Remove volume
docker volume rm mydata
```

## Networking

### Network Modes

```bash
# Default bridge network
docker run --network bridge -d myapp

# Host network (no isolation)
docker run --network host -d myapp

# None network (isolated)
docker run --network none -d myapp

# Custom network
docker network create mynetwork
docker run --network mynetwork -d myapp
```

### Container Linking

```bash
# Link containers (deprecated, use networks instead)
docker run --link db:db -d myapp
```

## Resource Limits

### CPU Limits

```bash
# Limit to half a core
docker run --cpus="0.5" -d myapp

# Limit to specific CPUs
docker run --cpuset-cpus="0-3" -d myapp
```

### Memory Limits

```bash
# Limit memory to 512MB
docker run -m 512m -d myapp

# Memory and swap
docker run -m 512m --memory-swap 1g -d myapp
```

## Restart Policies

```bash
# No restart
docker run --restart no -d myapp

# Restart always
docker run --restart always -d myapp

# Restart on failure
docker run --restart on-failure:3 -d myapp

# Restart unless stopped manually
docker run --restart unless-stopped -d myapp
```

## Overriding Default Commands

```bash
# Override CMD from Dockerfile
docker run myimage echo "Hello World"

# Override ENTRYPOINT and CMD
docker run --entrypoint /bin/bash myimage -c "ls -la"
```

## Inspecting Running Containers

```bash
# List running containers
docker ps

# List all containers (including stopped)
docker ps -a

# Show container logs
docker logs myapp

# Follow logs in real-time
docker logs -f myapp

# Show last 50 lines
docker logs --tail 50 myapp

# Show logs since timestamp
docker logs --since 2023-01-01T00:00:00 myapp
```

## Container Management

### Executing Commands in Running Containers

```bash
# Execute command in running container (non-interactive)
docker exec myapp ls -la /app

# Execute interactive shell
docker exec -it myapp bash

# Execute as different user
docker exec -it --user root myapp bash
```

### Container Information

```bash
# Show container configuration
docker inspect myapp

# Show processes running in container
docker top myapp

# Show container stats
docker stats myapp

# Show container resource usage
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
```

## Common Run Scenarios

### Web Application

```bash
docker run -d \
  --name webapp \
  -p 8080:3000 \
  -e NODE_ENV=production \
  -v /home/user/appdata:/app/data \
  --restart unless-stopped \
  myapp:latest
```

### Database Container

```bash
docker run -d \
  --name postgres \
  -p 5432:5432 \
  -e POSTGRES_PASSWORD=mypassword \
  -e POSTGRES_DB=myapp \
  -v postgres_data:/var/lib/postgresql/data \
  --restart unless-stopped \
  postgres:13
```

### Development Environment

```bash
docker run -it \
  --rm \
  -v $(pwd):/app \
  -p 3000:3000 \
  -e DEBUG=1 \
  node:16-alpine bash
```

## Docker Compose

For running multiple containers, use Docker Compose:

```yaml
version: "3.8"
services:
  web:
    image: myapp
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db
  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=password
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

```bash
# Run with docker-compose
docker-compose up -d

# Build and run
docker-compose up --build -d
```

## Troubleshooting Common Issues

### Container Exits Immediately

**Cause**: No foreground process or error in startup command
**Solution**: Check logs with `docker logs container_name`

### Port Already in Use

**Cause**: Another process using the host port
**Solution**: Change host port or stop conflicting service

### Permission Denied

**Cause**: File permission issues with mounted volumes
**Solution**: Adjust file permissions or use correct user

### No Space Left on Device

**Cause**: Docker images/containers consuming disk space
**Solution**: Clean up with `docker system prune`

### Network Issues

**Cause**: Containers can't communicate
**Solution**: Use custom networks or correct service names

## Best Practices

1. **Use Descriptive Names**: Give containers meaningful names
2. **Always Specify Versions**: Avoid using `latest` tag in production
3. **Use Environment Files**: Keep sensitive data out of Docker commands
4. **Limit Resources**: Set CPU and memory limits for production
5. **Use Volumes for Data**: Mount volumes for persistent data
6. **Clean Up Regularly**: Remove stopped containers and unused images
7. **Document Exposed Ports**: Use clear port mappings
8. **Use Appropriate Restart Policies**: Choose based on application requirements

## Security Considerations

- Run containers with non-root users when possible
- Use trusted base images
- Regularly update base images and dependencies
- Use secrets management for sensitive data
- Implement resource limits to prevent DoS attacks

Running containers effectively requires understanding the various options and their implications for different use cases. Practice with simple examples and gradually move to more complex production scenarios.
