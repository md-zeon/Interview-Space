# What is a Dockerfile?

## Introduction to Dockerfile

A Dockerfile is a text file that contains a series of instructions and commands used to automatically build a Docker image. It serves as a blueprint that defines how a container image should be constructed.

## Dockerfile Structure

A Dockerfile follows a specific format where each instruction is written on a new line and begins with a capital letter. The basic structure includes:

```dockerfile
# Comment line
INSTRUCTION argument
```

### Example Dockerfile

```dockerfile
# Use official Node.js runtime as the base image
FROM node:16-alpine

# Set working directory inside container
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install application dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Change ownership of app directory
RUN chown -R nextjs:nodejs /app

# Switch to non-root user
USER nextjs

# Expose port 3000
EXPOSE 3000

# Define environment variable
ENV NODE_ENV=production

# Command to run the application
CMD ["npm", "start"]
```

## Core Dockerfile Instructions

### FROM

Sets the base image for subsequent instructions. Every Dockerfile must start with a FROM instruction.

```dockerfile
FROM ubuntu:20.04
FROM node:16-alpine
FROM python:3.9-slim
```

### WORKDIR

Sets the working directory for RUN, CMD, ENTRYPOINT, COPY, and ADD instructions.

```dockerfile
WORKDIR /app
WORKDIR /usr/src/app
```

### COPY

Copies files or directories from the source path on the host to the destination path in the container.

```dockerfile
COPY package.json .
COPY src/ /app/src/
COPY ["src/", "dest/"]
```

### ADD

Similar to COPY but can handle URLs and automatically extracts tar archives.

```dockerfile
ADD https://example.com/file.tar.gz /tmp/
ADD source.tar.gz /app/
```

### RUN

Executes commands in a new layer during the build process.

```dockerfile
RUN apt-get update && apt-get install -y curl
RUN npm install
```

### CMD

Specifies the default command to run when a container starts. There can only be one CMD instruction.

```dockerfile
CMD ["npm", "start"]
CMD ["python", "app.py"]
CMD echo "Hello World"
```

### ENTRYPOINT

Configures the container to run as an executable. Similar to CMD but cannot be overridden easily.

```dockerfile
ENTRYPOINT ["python", "app.py"]
ENTRYPOINT ["docker-entrypoint.sh"]
```

### EXPOSE

Documents which ports the container listens on at runtime.

```dockerfile
EXPOSE 3000
EXPOSE 8080 8443
```

### ENV

Sets environment variables that persist in the container.

```dockerfile
ENV NODE_ENV=production
ENV PATH=/app/node_modules/.bin:$PATH
```

### ARG

Defines variables that can be passed at build-time using --build-arg.

```dockerfile
ARG VERSION=latest
FROM node:${VERSION}
ARG ENVIRONMENT
ENV NODE_ENV=${ENVIRONMENT}
```

### USER

Sets the user name or UID to use when running the image.

```dockerfile
USER nobody
USER 1000:1000
```

### VOLUME

Creates mount points and marks them as holding externally mounted volumes.

```dockerfile
VOLUME ["/data"]
VOLUME /app/logs
```

### LABEL

Adds metadata to the image as key-value pairs.

```dockerfile
LABEL maintainer="team@example.com"
LABEL version="1.0"
LABEL description="A sample web application"
```

### ONBUILD

Adds a trigger instruction to be executed later when the image is used as a base for another build.

```dockerfile
ONBUILD COPY . /app/src/
ONBUILD RUN cd /app/src && npm install
```

## Dockerfile Best Practices

### 1. Use Official Base Images

Always prefer official images for better security and reliability.

```dockerfile
FROM ubuntu:20.04  # Good
FROM myregistry/ubuntu  # Risky
```

### 2. Minimize Layer Count

Combine related commands to reduce the number of layers.

```dockerfile
# Bad - Creates multiple layers
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y wget

# Good - Single layer
RUN apt-get update && \
    apt-get install -y curl wget && \
    rm -rf /var/lib/apt/lists/*
```

### 3. Use .dockerignore

Create a `.dockerignore` file to exclude unnecessary files from the build context.

```dockerignore
node_modules
.git
README.md
.env
*.log
```

### 4. Order Instructions for Caching

Place instructions that change frequently at the end to leverage Docker's layer caching.

```dockerfile
FROM node:16-alpine
COPY package*.json ./
RUN npm ci  # Dependencies rarely change, cache this layer
COPY . .    # Source code changes frequently
```

### 5. Non-Root User

Run containers with a non-root user for security.

```dockerfile
RUN useradd -m myuser
USER myuser
```

### 6. Clean Up After Yourself

Remove temporary files and package managers cache to reduce image size.

```dockerfile
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*
```

## Dockerfile Context

The build context is the set of files that can be referenced by the ADD and COPY instructions. By default, it's the current directory.

```bash
docker build -f Dockerfile .       # Current directory as context
docker build -f Dockerfile ./src   # ./src as context
```

## Multi-Stage Builds

Multi-stage builds allow you to use multiple FROM instructions in a single Dockerfile to create a final image that only contains the runtime artifacts.

```dockerfile
# Build stage
FROM node:16-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime stage
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Benefits of Multi-Stage Builds:

- Smaller final image size
- Better security (no build tools in final image)
- Faster deployments
- Cleaner Docker cache

## Common Dockerfile Patterns

### Node.js Application

```dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

### Python Application

```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8000
CMD ["python", "app.py"]
```

### Java Application

```dockerfile
FROM maven:3-jdk-11 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

FROM openjdk:11-jre-slim
COPY --from=builder /app/target/*.jar /app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

## Testing Dockerfile Builds

Build and test your Dockerfile locally before deploying:

```bash
# Build the image
docker build -t myapp .

# Run a container to test
docker run -p 3000:3000 myapp

# Check image layers
docker history myapp

# Check image size
docker images myapp
```

## Conclusion

Dockerfiles are essential for defining how your application containers are built. Following best practices ensures your images are secure, efficient, and repeatable. Multi-stage builds and proper layer ordering can significantly optimize your Docker images for production deployment.
