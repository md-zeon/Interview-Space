# What is Docker networking?

## Introduction to Docker Networking

Docker networking allows containers to communicate with each other and with external networks. Docker provides several built-in network drivers that handle different networking scenarios, from simple container isolation to complex multi-host networks.

## Docker Network Types

### Bridge Network (Default)

The bridge network is Docker's default networking driver. Each container connected to a bridge network gets its own IP address from the bridge's subnet.

#### Creating and Using Bridge Networks

```bash
# Create a custom bridge network
docker network create --driver bridge my-bridge-network

# Run containers on the same bridge network
docker run -d --name web --network my-bridge-network -p 8080:80 nginx
docker run -d --name api --network my-bridge-network my-api-app

# Inspect network
docker network inspect my-bridge-network
```

#### Benefits:

- Container isolation
- Automatic DNS resolution between containers on the same network
- External access through port mapping

### Host Network

Containers use the host's network stack directly. No network isolation - the container shares the host's IP address.

```bash
# Run container with host networking
docker run -d --network host --name web nginx

# Container uses host's IP and ports
curl localhost:80  # Accesses Nginx directly
```

#### Use Cases:

- Maximum network performance
- Need to bind directly to host ports
- Legacy applications expecting specific ports

#### Security Considerations:

- No network isolation
- Potential port conflicts
- Less secure than container networking

### None Network

Containers have no external network access. Completely isolated from all networks.

```bash
# Run container with no networking
docker run -d --network none --name isolated-app my-app

# Container cannot reach external networks or other containers
```

#### Use Cases:

- Security-critical applications
- Batch processing jobs
- Testing network-independent code

### Overlay Network

Allows containers running on different Docker hosts to communicate securely. Used by Docker Swarm for multi-host networking.

```bash
# Create overlay network (requires Swarm mode)
docker network create --driver overlay my-overlay-network

# Works across multiple Docker hosts in Swarm
```

### Macvlan Network

Allows containers to appear as physical devices on the network with their own MAC address.

```bash
# Create macvlan network
docker network create --driver macvlan \
  --subnet=192.168.1.0/24 \
  --gateway=192.168.1.1 \
  -o parent=eth0 \
  my-macvlan-network
```

#### Use Cases:

- Legacy applications requiring MAC address
- Network monitoring tools
- Applications needing direct layer 2 access

## Docker Network Commands

### Network Management

```bash
# List all networks
docker network ls

# Inspect a network
docker network inspect bridge

# Remove a network
docker network rm my-network

# Prune unused networks
docker network prune
```

### Connecting Containers to Networks

```bash
# Connect running container to network
docker network connect my-network my-container

# Disconnect container from network
docker network disconnect bridge my-container

# Run container on multiple networks
docker run -d --network net1 --network-alias app net2 my-app
```

## Network Communication

### Container to Container Communication

Containers on the same network can communicate using container names:

```bash
# Create network
docker network create app-network

# Run database
docker run -d --name db --network app-network postgres

# Run app (can connect to 'db')
docker run -d --name web --network app-network -e DB_HOST=db my-web-app
```

### Container to Host Communication

Containers can communicate with the host using the special `host.docker.internal` address:

```bash
# From inside container
curl host.docker.internal:3000
```

### Host to Container Communication

Use port mapping to expose container ports on the host:

```bash
# Map container port 3000 to host port 8080
docker run -d -p 8080:3000 --name web my-web-app

# Map with specific IP
docker run -d -p 192.168.1.100:8080:3000 my-web-app

# Map UDP port
docker run -d -p 53:53/udp my-dns-server
```

## Network Drivers Deep Dive

### Bridge Driver

The bridge driver creates a virtual bridge device that connects containers to the host's network stack.

```
Host Network Stack
        │
    docker0 (bridge)
    ├── container1 (eth0: 172.17.0.2)
    ├── container2 (eth0: 172.17.0.3)
    └── container3 (eth0: 172.17.0.4)
```

### Host Driver

Containers share the host's network namespace directly.

```
Host Network Stack (eth0: 192.168.1.100)
    ├── container1 (shares host eth0)
    ├── container2 (shares host eth0)
    └── container3 (shares host eth0)
```

### None Driver

Containers have only a loopback interface.

```
container1
└── lo (127.0.0.1)
```

## DNS and Service Discovery

### Embedded DNS Server

Docker provides an embedded DNS server that allows containers to resolve each other by name:

```bash
docker network create my-network
docker run -d --name web --network my-network nginx
docker run -d --name api --network my-network my-api

# Inside api container
ping web  # Resolves to web container's IP
curl http://web  # Works with service name
```

### Network Aliases

Provide multiple names for the same container:

```bash
# Create container with multiple aliases
docker run -d --network my-network \
  --network-alias web \
  --network-alias app \
  --name myapp \
  my-web-app

# Other containers can access as 'web' or 'app' or 'myapp'
```

## Advanced Networking Features

### Network Scopes

Networks can be local (single host) or swarm (multi-host):

```bash
# Local network (default)
docker network create my-local-net

# Swarm network (requires Swarm mode)
docker network create --driver overlay --scope swarm my-swarm-net
```

### Network Configuration Options

```bash
# Create network with custom subnet
docker network create \
  --driver bridge \
  --subnet 10.0.0.0/24 \
  --gateway 10.0.0.1 \
  --opt "com.docker.network.bridge.name"="mybridge" \
  my-custom-network
```

### IPv6 Support

```bash
# Enable IPv6 on network
docker network create \
  --driver bridge \
  --ipv6 \
  --subnet 2001:db8::/32 \
  my-ipv6-network
```

## Docker Compose Networking

Docker Compose automatically creates networks for multi-container applications:

```yaml
version: "3.8"
services:
  web:
    image: nginx
    networks:
      - frontend
      - backend

  api:
    image: my-api
    networks:
      - backend

  db:
    image: postgres
    networks:
      - backend

networks:
  frontend:
  backend:
```

## Troubleshooting Network Issues

### Container Can't Resolve Names

```bash
# Check container's /etc/resolv.conf
docker exec mycontainer cat /etc/resolv.conf

# Restart container with different DNS
docker run --dns 8.8.8.8 --dns 8.8.4.4 --name mycontainer myimage
```

### Port Conflicts

```bash
# Check what's using port 80
sudo lsof -i :80

# Use different host port
docker run -p 8080:80 nginx
```

### Network Inspection

```bash
# Show container network info
docker inspect mycontainer | jq .NetworkSettings

# Show network connections
docker network inspect my-network

# List all container IPs on network
docker network inspect my-network | jq .Containers
```

### Reset Network Settings

```bash
# Stop all containers
docker stop $(docker ps -q)

# Remove all networks except default
docker network prune

# Restart Docker daemon
sudo systemctl restart docker
```

## Security Considerations

### Network Isolation

```bash
# Use internal network (no external access)
docker network create --internal my-internal-net

# Restrict inter-container communication
docker network create --driver bridge --opt "com.docker.network.bridge.enable_icc"="false" isolated-net
```

### Firewall Configuration

```bash
# Configure iptables for Docker networks
# Docker automatically manages iptables rules
sudo iptables -L DOCKER-USER
```

## Best Practices

### 1. Use Custom Networks

```bash
# Don't rely on default bridge
docker network create app-network
```

### 2. Plan Network Topology

```bash
# Group services by access patterns
docker network create web-tier
docker network create app-tier
docker network create data-tier
```

### 3. Use Consistent Naming

```bash
# Use predictable container names
docker run --name web01 --network web-tier nginx
docker run --name db01 --network data-tier postgres
```

### 4. Monitor Network Usage

```bash
# Check network traffic
docker stats --format "table {{.Name}}\t{{.NetIO}}"

# Inspect network usage
docker network inspect my-network | jq .Containers
```

### 5. Clean Up Unused Networks

```bash
# Regular cleanup
docker network prune -f
```

## Common Network Scenarios

### Web Application with Database

```yaml
version: "3.8"
services:
  web:
    image: nginx
    ports:
      - "80:80"
    networks:
      - public

  app:
    image: my-app
    networks:
      - public
      - private

  db:
    image: postgres
    networks:
      - private

networks:
  public:
  private:
    internal: true # No external access
```

### Microservices Architecture

```yaml
version: "3.8"
services:
  api-gateway:
    ports:
      - "80:80"
    networks:
      - ingress

  user-service:
    networks:
      - ingress
      - services

  order-service:
    networks:
      - services

  payment-service:
    networks:
      - services

networks:
  ingress:
  services:
    internal: true
```

## Summary

Docker networking provides flexible options for different architectural needs:

- **Bridge networks** for development and small applications
- **Overlay networks** for multi-host Docker Swarm deployments
- **Host networks** when maximum performance is needed
- **Macvlan networks** for legacy application compatibility

Key concepts include:

- Container-to-container communication via DNS resolution
- Port mapping for external access
- Network isolation for security
- Service discovery through embedded DNS

Understanding Docker networking is crucial for designing secure, scalable, and maintainable containerized applications. Choose the appropriate network driver based on your architecture requirements and security constraints.
