# What is Docker Compose?

## Introduction to Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications. It uses a YAML file (docker-compose.yml) to configure application services, networks, and volumes, allowing you to start, stop, and manage entire application stacks with simple commands.

## Why Docker Compose?

### Before Docker Compose

Running multi-container applications required:

- Multiple `docker run` commands
- Manual network configuration
- Complex dependency management
- Error-prone orchestration

```bash
# Manual setup (complex and error-prone)
docker network create mynetwork
docker run -d --name db --network mynetwork -e POSTGRES_PASSWORD=password postgres:13
docker run -d --name redis --network mynetwork redis:alpine
docker run -d --name web --network mynetwork -p 3000:3000 --depends-on db myapp
```

### With Docker Compose

All configuration in a single file, one command to start everything:

```bash
docker-compose up -d
```

## Docker Compose File Structure

### Basic docker-compose.yml

```yaml
version: "3.8"
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"
  db:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: password
```

### Complete Example

```yaml
version: "3.8"
services:
  web:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
    networks:
      - frontend
      - backend

  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - backend
    restart: unless-stopped

  redis:
    image: redis:alpine
    networks:
      - backend

volumes:
  db_data:

networks:
  frontend:
  backend:
```

## Core Components

### Services

Each service represents a container that will be run. Services can be:

- Built from Dockerfiles (`build` property)
- Based on existing images (`image` property)

```yaml
services:
  web:
    # Build from Dockerfile
    build: .
    # Or use existing image
    image: nginx:latest
```

### Networks

Define how services communicate with each other:

```yaml
networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
```

### Volumes

Named volumes for data persistence:

```yaml
volumes:
  db_data:
    driver: local
  logs:
    driver: local
```

## Docker Compose Commands

### Start Services

```bash
# Start services defined in docker-compose.yml
docker-compose up

# Start in detached mode (background)
docker-compose up -d

# Start specific services
docker-compose up web db

# Build and start
docker-compose up --build
```

### Stop Services

```bash
# Stop services
docker-compose down

# Stop and remove volumes
docker-compose down -v

# Stop specific services
docker-compose stop web
```

### Monitor and Debug

```bash
# View logs
docker-compose logs

# View logs for specific service
docker-compose logs web

# Follow logs in real-time
docker-compose logs -f web

# Execute commands in running containers
docker-compose exec web bash

# Execute commands in running containers (create new shelled process)
docker-compose exec web ls -la /app
```

### Manage Services

```bash
# List running services
docker-compose ps

# Build images
docker-compose build

# Build specific service
docker-compose build web

# Rebuild and restart
docker-compose up --build --force-recreate

# Scale services (only for services without ports)
docker-compose up -d --scale web=3
```

### Cleanup

```bash
# Remove stopped containers
docker-compose rm

# Remove images
docker-compose rm --rmi all

# Remove volumes
docker-compose down -v
```

## Service Configuration

### Building Images

```yaml
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile.dev
      args:
        NODE_ENV: development
```

### Environment Variables

```yaml
services:
  web:
    environment:
      - DEBUG=1
      - API_URL=https://api.example.com
    env_file:
      - .env
      - secrets.env
```

### Port Mapping

```yaml
services:
  web:
    ports:
      - "3000:3000" # host:container
      - "8080:80" # Multiple ports possible
  api:
    ports:
      - "5000:5000"
```

### Volume Mounts

```yaml
services:
  web:
    volumes:
      - .:/app # Bind mount (current dir to /app)
      - /app/node_modules # Anonymous volume for node_modules
      - logs:/app/logs # Named volume
      - ./config:/app/config:ro # Read-only bind mount
```

### Dependencies

```yaml
services:
  web:
    depends_on:
      - db
      - redis
    # Web waits for db and redis to be healthy before starting
  worker:
    depends_on:
      web:
        condition: service_healthy
      db:
        condition: service_healthy
```

### Health Checks

```yaml
services:
  web:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    depends_on:
      web:
        condition: service_healthy
```

### Resource Limits

```yaml
services:
  web:
    deploy:
      resources:
        limits:
          cpus: "0.50"
          memory: 512M
        reservations:
          cpus: "0.25"
          memory: 256M
```

## Advanced Features

### Multiple Compose Files

Use different configurations for different environments:

```bash
# Use multiple compose files
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

# Override development settings
docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d
```

### Environment-Specific Overrides

```yaml
# docker-compose.override.yml (development defaults)
services:
  web:
    build:
      target: development
    volumes:
      - .:/app
    environment:
      - DEBUG=1
```

### Extending Services

Reuse service configurations:

```yaml
# docker-compose.yml
services:
  base: &base
    image: node:16-alpine
    working_dir: /app
    volumes:
      - .:/app

  web:
    <<: *base
    command: npm start
    ports:
      - "3000:3000"

  worker:
    <<: *base
    command: npm run worker
```

## Common Patterns

### Full-Stack Web Application

```yaml
version: "3.8"
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules

  backend:
    build: ./backend
    ports:
      - "4000:4000"
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/myapp
    depends_on:
      - db

  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=myapp
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

### Microservices Architecture

```yaml
version: "3.8"
services:
  api-gateway:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - user-service
      - product-service

  user-service:
    build: ./user-service
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis

  product-service:
    build: ./product-service
    environment:
      - DB_URL=postgres://db:5432/products
    depends_on:
      - db

  redis:
    image: redis:alpine

  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=password

networks:
  default:
    driver: bridge
```

## Deployment Strategies

### Development Environment

```yaml
version: "3.8"
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    volumes:
      - .:/app
      - /app/node_modules
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
```

### Testing Environment

```yaml
version: "3.8"
services:
  app:
    image: myapp:latest
    environment:
      - NODE_ENV=test
    depends_on:
      test-db:
        condition: service_healthy

  test-db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=password
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### Production Environment

```yaml
version: "3.8"
services:
  app:
    image: myapp:v1.2.3
    environment:
      - NODE_ENV=production
    ports:
      - "80:3000"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## Best Practices

### 1. Version Pinning

```yaml
# Use specific versions instead of latest
services:
  db:
    image: postgres:13.4-alpine # Specific version
    # Not: image: postgres:latest
```

### 2. Environment Separation

Use different compose files for different environments:

```
docker-compose.yml          # Base configuration
docker-compose.dev.yml      # Development overrides
docker-compose.test.yml     # Testing overrides
docker-compose.prod.yml     # Production overrides
```

### 3. Health Checks

Implement health checks for dependent services:

```yaml
services:
  db:
    image: postgres:13
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  app:
    depends_on:
      db:
        condition: service_healthy
```

### 4. Resource Management

Set resource limits for production:

```yaml
services:
  web:
    deploy:
      resources:
        limits:
          cpus: "0.50"
          memory: 512M
```

### 5. Security

- Use environment files for secrets
- Run containers as non-root users
- Regularly update base images

### 6. Volume Strategy

```yaml
services:
  db:
    volumes:
      - db_data:/var/lib/postgresql/data
  app:
    volumes:
      # Bind mount for logs
      - ./logs:/app/logs
      # Anonymous volume for temp data
      - /tmp
      # Named volume for persistent cache
      - cache_data:/app/cache

volumes:
  db_data:
  cache_data:
```

## Troubleshooting Docker Compose

### Service Won't Start

```bash
# Check service logs
docker-compose logs web

# Check service status
docker-compose ps

# Restart specific service
docker-compose restart web
```

### Dependency Issues

```bash
# Force recreate and rebuild
docker-compose up --build --force-recreate

# Check if dependent services are healthy
docker-compose ps
```

### Network Problems

```bash
# Recreate networks
docker-compose down
docker-compose up -d

# Check network connectivity
docker-compose exec web ping db
```

## Version Compatibility

### Compose File Versions

- **Version 3.8** (recommended for Docker Engine 19.03+)
- **Version 3.7** (Docker Engine 18.06+)
- **Version 3.4** (Docker Engine 17.09.1+)
- **Version 2.x** (deprecated)

### Keys by Version

Different versions support different keys:

- `deploy` (version 3.4+)
- `healthcheck` (version 2.1+)
- Service conditions in `depends_on` (version 2.1+)

## Integration with CI/CD

### GitHub Actions Example

```yaml
name: Deploy
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Docker Compose Build
        run: docker-compose build
      - name: Docker Compose Up
        run: docker-compose up -d
      - name: Run Tests
        run: docker-compose exec -T web npm test
```

### Jenkins Pipeline

```groovy
pipeline {
  agent any
  stages {
    stage('Build') {
      steps {
        sh 'docker-compose build'
      }
    }
    stage('Test') {
      steps {
        sh 'docker-compose up -d'
        sh 'docker-compose exec -T web npm test'
      }
    }
    stage('Deploy') {
      steps {
        sh 'docker-compose up -d --scale web=3'
      }
    }
  }
  post {
    always {
      sh 'docker-compose down -v'
    }
  }
}
```

## Summary

Docker Compose simplifies the management of multi-container applications by:

- **Defining application stacks** in a single YAML file
- **Managing service dependencies** and startup order
- **Configuring networks and volumes** declaratively
- **Scaling services** with simple commands
- **Supporting multiple environments** with different configurations

Key benefits include:

- **Simplified orchestration** of complex applications
- **Environment consistency** across development and production
- **Easy scaling and management** of containerized services
- **Integration with CI/CD pipelines** for automated deployment

Docker Compose is essential for developing, testing, and deploying containerized applications that consist of multiple interconnected services.
