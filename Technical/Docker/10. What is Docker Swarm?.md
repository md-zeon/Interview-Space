# What is Docker Swarm?

## Introduction to Docker Swarm

Docker Swarm is Docker's native clustering and container orchestration solution. It transforms a pool of Docker hosts into a single, virtual Docker host, allowing you to deploy, manage, and scale containerized applications across multiple machines.

## Why Docker Swarm?

### Before Swarm: Single Host Limitations

```bash
# Single Docker host problems
- No high availability
- Manual load balancing
- Difficult scaling
- Single point of failure
```

### With Swarm: Cluster Orchestration

```bash
# Swarm provides
- Load balancing across nodes
- Automatic failover
- Service discovery
- Rolling updates
- Secret management
```

## Swarm Architecture

### Swarm Components

#### Manager Nodes

- Handle cluster management and orchestration decisions
- Maintain cluster state and schedule tasks
- Process API requests (docker swarm init, docker service create)
- Can have 1, 3, or more managers for high availability

#### Worker Nodes

- Execute tasks assigned by manager nodes
- Run container workloads
- Report status back to managers
- Can be promoted to manager role if needed

#### Swarm Cluster

- Group of nodes running in Swarm mode
- Single entrance point through any manager node
- Distributed state stored via Raft consensus algorithm

```
Swarm Cluster
├── Manager Nodes (odd number: 1,3,5,7...)
│   ├── Leader (1 active)
│   └── Followers (passive, become leader if leader fails)
├── Worker Nodes (many possible)
│   ├── Run containers
│   └── Report to managers
└── Load Balancer
    └── Routes traffic to services
```

## Getting Started with Docker Swarm

### Initialize Swarm

```bash
# Initialize swarm on first node (becomes manager)
docker swarm init --advertise-addr <manager-ip>

# Join worker nodes to swarm
docker swarm join --token <worker-token> <manager-ip>:<manager-port>

# Join manager nodes to swarm (for HA)
docker swarm join --token <manager-token> <manager-ip>:<manager-port>
```

### Check Swarm Status

```bash
# View cluster info
docker node ls

# View current node info
docker info | grep -A 10 Swarm

# Check swarm status
docker swarm ca  # Certificate Authority info
```

## Services in Docker Swarm

### Service Concepts

Swarm services are the primary unit of work in a Swarm cluster. A service defines:

- **Image**: Which Docker image to run
- **Replicas**: How many container instances to run
- **Networks**: Which networks to attach to
- **Ports**: How to expose the service
- **Environment**: Configuration via environment variables

### Creating a Service

```bash
# Create a simple service
docker service create --name web --replicas 3 -p 80:80 nginx

# Create service with environment variables
docker service create \
  --name api \
  --replicas 5 \
  --env POSTGRES_HOST=db \
  --env REDIS_URL=redis://redis:6379 \
  my-api:latest

# Create service with secrets and configs
docker service create \
  --name secure-app \
  --secret db-password \
  --config app-config \
  my-app:secure
```

### Service Scaling

```bash
# Scale service up
docker service scale web=10

# Scale service down
docker service scale web=3

# Update service configuration
docker service update --replicas 5 web
```

### Service Inspection

```bash
# List all services
docker service ls

# Inspect service details
docker service inspect web

# View service logs
docker service logs web

# List tasks (containers) for a service
docker service ps web
```

## Load Balancing and Routing

### Internal Load Balancing

```bash
# Services automatically load balance between replicas
# All replicas of a service share the same DNS name and VIP
docker service create --name api --replicas 3 my-api

# Other services connect using service name
docker service create --name web --env API_URL=http://api web-app
```

### Ingress Load Balancing

```bash
# Published ports are load balanced across all nodes
docker service create --name web --replicas 3 -p 80:80 nginx

# Traffic to any swarm node on port 80 is routed to web service
curl http://node1:80
curl http://node2:80  # Same service, different node
```

### Routing Mesh

Swarm provides ingress routing mesh - any node can receive requests for any service:

```
Internet
    │
Any Node in Swarm ──┬── Node 1 (Manager)
                    ├── Node 2 (Worker)
                    └── Node 3 (Worker)
All nodes route traffic to services running on any node
```

## Rolling Updates

### Performing Rolling Updates

```bash
# Update service image
docker service update --image nginx:1.21 web

# Rolling update with specific parameters
docker service update \
  --image myapp:v2.0 \
  --update-parallelism 2 \
  --update-delay 10s \
  --update-failure-action rollback \
  web
```

### Update Strategies

```bash
# Parallel update (default)
--update-parallelism 2  # Update 2 tasks at a time

# Rolling update delay
--update-delay 30s      # Wait 30 seconds between updates

# Failure handling
--update-failure-action continue   # Continue on failure
--update-failure-action pause      # Pause on failure
--update-failure-action rollback   # Rollback on failure
```

### Monitoring Updates

```bash
# Watch service updates
docker service ps web

# Check update status
docker service inspect web | jq .UpdateStatus
```

## Networking in Swarm

### Overlay Networks

```bash
# Create overlay network (multi-host networking)
docker network create --driver overlay myapp-net

# Use overlay network in services
docker service create --name web --network myapp-net nginx
docker service create --name db --network myapp-net postgres
```

### Service Discovery

Services automatically discover each other through DNS:

```bash
# DNS resolution works across nodes
web service: ping db  # Resolves to db service VIP
db service: ping web  # Resolves to web service VIP

# Multiple replicas share same name
curl http://api  # Load balanced across all api replicas
```

## Secrets and Configs

### Managing Secrets

```bash
# Create secret
echo "mypassword" | docker secret create db-password -

# Create service with secret
docker service create \
  --name db \
  --secret db-password \
  postgres

# Use secret in container
# Accessible at /run/secrets/db-password
```

### Managing Configs

```bash
# Create config
docker config create app-config config.json

# Use config in service
docker service create \
  --name web \
  --config app-config \
  nginx
```

### Rotating Secrets/Configs

```bash
# Update secret (no service downtime)
echo "newpassword" | docker secret create db-password-v2 -
docker service update --secret-rm db-password --secret-add db-password-v2 db
```

## Node Management

### Node Operations

```bash
# List nodes
docker node ls

# Promote worker to manager
docker node promote node2

# Demote manager to worker
docker node demote node1

# Drain node (remove workloads before maintenance)
docker node update --availability drain node3

# Activate node after maintenance
docker node update --availability active node3

# Remove node from swarm
docker node rm node4
```

### Node Labels and Constraints

```bash
# Add labels to nodes
docker node update --label-add zone=frontend node1
docker node update --label-add zone=backend node2

# Use constraints in services
docker service create \
  --name frontend \
  --constraint node.labels.zone==frontend \
  nginx

docker service create \
  --name backend \
  --constraint node.labels.zone==backend \
  postgres
```

## High Availability

### Manager HA

```bash
# Use odd number of managers
docker swarm init --advertise-addr 192.168.1.10  # Manager 1

# Join second manager
docker swarm join-token manager
# Use token to join Manager 2
# Use token to join Manager 3

# Benefit: Leader election if primary fails
```

### Service HA

```bash
# Replicas distribute across nodes
docker service create --name web --replicas 3 -p 80:80 nginx

# If node fails, replicas restart on available nodes
# Automatic failover maintains service availability
```

## Stack Deployments

### Docker Stack

Stacks deploy multi-service applications using compose files:

```yaml
# docker-compose.yml
version: "3.8"
services:
  web:
    image: wordpress
    ports:
      - "80:80"
    depends_on:
      - db

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: password
    volumes:
      - db-data:/var/lib/mysql

volumes:
  db-data:
```

```bash
# Deploy stack
docker stack deploy -c docker-compose.yml myapp

# List stacks
docker stack ls

# List services in stack
docker stack services myapp

# Remove stack
docker stack rm myapp
```

## Monitoring and Logging

### Service Monitoring

```bash
# Check service health
docker service ls

# View service events
docker service logs web

# Monitor node resources
docker node ps

# Check cluster status
docker node ls
```

### Prometheus Integration

Swarm integrates with monitoring tools:

```yaml
# Monitoring stack
version: "3.8"
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
```

## Backup and Recovery

### Swarm Backup

```bash
# Backup swarm state (on manager)
docker node ls -q > nodes.txt
docker config ls -q > configs.txt
docker secret ls -q > secrets.txt

# Backup volumes/data separately
```

### Recovery Strategies

```bash
# Recover swarm
docker swarm init --force-new-cluster  # Initialize new swarm
# Rejoin nodes with tokens
# Recreate services from compose files
```

## Best Practices

### Swarm Management

1. **Use odd number of managers** for consensus
2. **Separate managers and workers** for performance
3. **Use constraints** to control service placement
4. **Monitor node resources** to avoid overloading

### Service Design

1. **Use rolling updates** for zero-downtime deployments
2. **Implement health checks** in your images
3. **Use secrets and configs** for sensitive data
4. **Design for horizontal scaling**

### Network Security

1. **Use overlay networks** for multi-service communication
2. **Limit exposed ports** to necessary services
3. **Encrypt swarm control plane** (enabled by default)
4. **Rotate certificates** regularly

### Backup Strategy

1. **Backup service definitions** (compose files)
2. **Backup persistent data** (volumes)
3. **Backup secrets and configs**
4. **Test recovery procedures**

## Limitations of Docker Swarm

### Compared to Kubernetes

- **Simple orchestration** vs Kubernetes complexity
- **Limited extensibility** vs Kubernetes ecosystem
- **Fewer features** for advanced scheduling
- **Smaller community** vs Kubernetes dominance

### When to Choose Swarm

- Small to medium deployments
- Simple container orchestration needs
- Existing Docker ecosystem
- Quick setup requirements

## Real-World Examples

### Web Application Stack

```yaml
version: "3.8"
services:
  nginx:
    image: nginx:latest
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - web

  web:
    image: myapp:latest
    environment:
      - DB_URL=jdbc:postgresql://db:5432/myapp
    depends_on:
      - db
      - cache

  db:
    image: postgres:13
    environment:
      - POSTGRES_PASSWORD=secret
    volumes:
      - db-data:/var/lib/postgresql/data

  cache:
    image: redis:alpine

volumes:
  db-data:
```

### Microservices Architecture

```yaml
version: "3.8"
services:
  api-gateway:
    image: nginx:latest
    ports:
      - "80:80"
    configs:
      - source: nginx-config
        target: /etc/nginx/nginx.conf

  user-service:
    image: user-service:v1.2
    environment:
      - REDIS_URL=redis://cache:6379
    secrets:
      - db-password

  product-service:
    image: product-service:v1.1
    secrets:
      - db-password

  cache:
    image: redis:alpine

  database:
    image: postgres:13
    secrets:
      - db-password

secrets:
  db-password:
    external: true

configs:
  nginx-config:
    file: ./nginx.conf
```

## Conclusion

Docker Swarm provides a simple yet powerful way to orchestrate containerized applications across multiple hosts. Key features include:

- **Clustering**: Pool multiple Docker hosts into one virtual host
- **Service Management**: Deploy and scale services with simple commands
- **Load Balancing**: Automatic distribution of traffic across service replicas
- **Rolling Updates**: Zero-downtime application updates
- **Built-in Security**: Certificate-based authentication and secrets management

While Kubernetes offers more advanced features and flexibility, Docker Swarm excels in simplicity and ease of use, making it an excellent choice for teams looking for straightforward container orchestration that integrates seamlessly with the Docker ecosystem.

The choice between Swarm and other orchestration platforms depends on your team's needs, existing infrastructure, and long-term goals. Swarm works particularly well for development environments, small to medium production deployments, and organizations already invested in the Docker platform.
