# What is CSS Specificity?

CSS specificity is the algorithm that determines which CSS rule applies to an element when multiple rules target the same element. It's the mechanism browsers use to resolve conflicts when different selectors style the same element differently. Understanding specificity is crucial for writing predictable, maintainable CSS.

## How Specificity Works

### The Specificity Algorithm

Every CSS selector has a specificity value calculated using a four-part system:

```
Specificity = (inline-styles, ids, classes/attributes/pseudo-classes, elements/pseudo-elements)
```

**Format:** `a, b, c, d`

Where:
- `a` = inline styles (`style=""` attribute)
- `b` = ID selectors
- `c` = class selectors, attribute selectors, and pseudo-classes
- `d` = element selectors and pseudo-elements

### Specificity Hierarchy

```
Inline styles (highest specificity)
    ↓
ID selectors (#header)
    ↓
Class selectors (.menu), attribute selectors ([type="text"]), pseudo-classes (:hover)
    ↓
Element selectors (div, p), pseudo-elements (::before)
    ↓
Universal selector (*), combinators (+, >, ~, space), negation pseudo-class (:not())
    ↓
Inherited styles (lowest specificity)
```

## Calculating Specificity

### Examples with Calculations

```css
/* Specificity: 0,0,0,0 (universal) */
* { color: black; }

/* Specificity: 0,0,0,1 (element) */
div { color: blue; }

/* Specificity: 0,0,1,0 (class) */
.highlight { color: green; }

/* Specificity: 0,1,0,0 (ID) */
#nav { color: red; }

/* Specificity: 1,0,0,0 (inline style) */
<div style="color: purple;"></div>
```

### Complex Selector Calculations

```css
/* #header .nav li.active a:hover */
#nav               /* 0,1,0,0 (ID: #nav) */
.nav               /* 0,0,1,0 (class: .nav) */
li                 /* 0,0,0,1 (element: li) */
.active            /* 0,0,1,0 (class: .active) */
a                  /* 0,0,0,1 (element: a) */
:hover             /* 0,0,1,0 (pseudo-class: :hover) */
/* Total: 0,1,3,2 */
```

### Combinator Specificity

```css
/* nav ul li a (descendant) */
/* Specificity: 0,0,0,4 */
nav ul li a { ... }

/* nav > ul > li > a (child) */
/* Specificity: 0,0,0,4 (same as descendant) */
nav > ul > li > a { ... }

/* h1 + p (adjacent sibling) */
/* Specificity: 0,0,0,2 */
h1 + p { ... }
```

**Note:** Combinators themselves don't add specificity - only the selectors they connect matter.

### Pseudo-Element Specificity

```css
/* div::before */
/* Specificity: 0,0,0,2 (div + ::before) */
div::before { ... }

/* .content::after */
/* Specificity: 0,0,1,1 (.content + ::after) */
.content::after { ... }
```

## Specificity Conflicts and Resolution

### How Browsers Resolve Conflicts

1. **Calculate specificity** for each selector targeting the element
2. **Higher specificity wins**
3. **Same specificity**: Last declaration wins (source order)
4. **Same selector, same specificity**: Later rule overrides earlier one

### Example Resolution

```html
<p id="main" class="text highlight">Hello World</p>
```

```css
/* Specificity: 0,0,0,1 */
p { color: black; }

/* Specificity: 0,0,1,0 */
.text { color: blue; }

/* Specificity: 0,0,1,0 */
.highlight { color: green; }

/* Specificity: 0,0,2,0 (.text + .highlight) */
.text.highlight { color: red; }

/* Specificity: 0,1,0,0 */
#main { color: purple; }

/* Specificity: 1,0,0,0 (highest) */
<p style="color: orange;">
```

**Final color:** orange (inline style wins)

### Source Order with Equal Specificity

```css
/* Both have specificity 0,0,1,0 */
/* Last one wins */
.button { background: blue; }    /* Loses */
.button { background: red; }     /* Wins */

.component .button { background: green; }  /* Higher specificity wins */
```

## The !important Declaration

### How !important Works

`!important` overrides specificity entirely and should be used sparingly.

```css
.normal-rule { color: blue; }           /* Specificity: 0,0,1,0 */
.important-rule { color: red !important; } /* Forces override */
```

### !important Specificity

When `!important` is used:
1. All `!important` rules are evaluated together
2. Higher specificity `!important` beats lower specificity
3. Among equal specificity, source order wins

```css
p { color: blue !important; }           /* Specificity: 0,0,0,1 */
.text { color: green; }                  /* Specificity: 0,0,1,0 */
.text { color: red !important; }         /* Wins: !important with higher specificity */
```

### When to Use !important

**Acceptable Uses:**
```css
/* Overriding third-party styles */
.third-party-widget { margin: 0 !important; }

/* Utility classes */
.text-center { text-align: center !important; }

/* Breakpoint overrides */
@media (max-width: 768px) {
  .desktop-only { display: none !important; }
}
```

**Avoid Using:**
```css
/* Specificity battles */
.text { color: red !important; }
.something .text { color: blue !important; }
```

## Practical Examples

### Component Styling

```html
<header class="site-header">
  <h1 id="site-title" class="heading main-heading">My Website</h1>
  <nav class="main-nav">
    <ul>
      <li class="nav-item"><a href="#" class="nav-link active">Home</a></li>
      <li class="nav-item"><a href="#" class="nav-link">About</a></li>
    </ul>
  </nav>
</header>
```

```css
/* Specificity: 0,0,1,1 (.heading + h1) */
.heading { font-size: 24px; color: #333; }

/* Specificity: 0,1,0,1 (#site-title + h1) - Wins */
#site-title { font-size: 32px; color: blue; }

/* Specificity: 0,0,1,0 (.main-heading) - Loses */
.main-heading { font-size: 28px; }

/* Specificity: 0,0,2,1 (.nav-link + a) */
.nav-link { color: #666; text-decoration: none; }

/* Specificity: 0,0,3,1 (.nav-link.active + a) - Wins */
.nav-link.active { color: #007bff; font-weight: bold; }

/* Specificity: 1,0,0,0 */
<h1 style="color: red !important;">Red Color</h1>
```

### CSS Architecture

#### BEM Methodology promotes predictable specificity:

```css
/* Block - Low specificity */
.card { ... }

/* Element - Medium specificity */
.card__title { ... }
.card__content { ... }

/* Modifier - Same specificity as block */
.card--featured { ... }
.card__title--large { ... }

/* All these have the same specificity: 0,0,1,0 */
/* No accidental specificity wars */
```

### Utility Classes

```css
/* Bootstrap-style utilities - High specificity to override */
/* Specificity: 0,0,3,0 */
.mt-3.mb-2.text-center { margin-top: 1rem; margin-bottom: 0.5rem; text-align: center; }

/* Component styles - Lower specificity */
/* Specificity: 0,0,1,1 */
.article .lead { font-size: 1.25rem; color: #333; }
```

### CSS-in-JS Libraries

```javascript
// Styled Components (React example)
const Button = styled.button`
  background: blue;      /* Automatic scoping */
  color: white;

  &:hover {
    background: darkblue;
  }
`;

// No specificity conflicts - each component is isolated
```

## Common Specificity Issues

### 1. Over-Specificity

**Problem:**
```css
/* Too specific - hard to override */
html body div.main-content article.post div.post-header h2.post-title {
  font-size: 24px;
}

/* Trying to override later */
.post-title { font-size: 20px; } /* Loses */
```

**Solution:**
```css
/* Keep selectors simple */
.post-title { font-size: 24px; }
.post-title-alt { font-size: 20px; }
```

### 2. ID Selector Overuse

**Problem:**
```css
#sidebar { background: #f5f5f5; } /* Specificity: 0,1,0,0 */
.sidebar-content { padding: 20px; } /* Specificity: 0,0,1,0 */
```

**Cannot override sidebar styles without higher specificity.**

**Solution:**
```css
.sidebar { background: #f5f5f5; } /* Specificity: 0,0,1,0 */
.sidebar-content { padding: 20px; }  /* Same level, can override */
```

### 3. !important Addiction

**Problem:**
```css
/* Style wars */
.button { background: blue !important; }
.special-button { background: red !important; }
.urgent-button { background: green !important; }
```

**Solution:**
```css
/* Better specificity management */
.component .button { background: blue; }   /* 0,0,2,0 */
.component .special-button { background: red; } /* 0,0,2,0 */
.component .urgent-button { background: green; } /* 0,0,2,0 */
```

### 4. Third-Party CSS Conflicts

**Problem:** Bootstrap or other frameworks use specific selectors.

```css
/* Bootstrap button - High specificity */
.btn { padding: 6px 12px; }
.btn-primary { background-color: #007bff; }
```

**Solution:**
```css
/* Use higher specificity or !important for overrides */
.custom-btn.btn-primary { background-color: #dc3545; }
```

## Calculating Specificity Precisely

### Step-by-Step Process

Take this complex selector: `#nav ul.list > li.active a:not(.external):hover`

```
#nav                    // ID selector              → 0,1,0,0
ul                     // Element selector          → 0,0,0,1
.list                  // Class selector            → 0,0,1,0
>                      // Child combinator          → ignored (0 specificity)
li                     // Element selector          → 0,0,0,1
.active                // Class selector            → 0,0,1,0
a                      // Element selector          → 0,0,0,1
:not(.external)        // Negation pseudo-class    → 0,0,1,0
:hover                 // Pseudo-class              → 0,0,1,0
```

**Total Specificity:** `0,1,4,4`

### Quick Reference Chart

| Selector Type | Example | Specificity | Notes |
|---------------|---------|-------------|-------|
| Universal | `*` | 0,0,0,0 | Never adds specificity |
| Element | `div` | 0,0,0,1 | HTML tag |
| Pseudo-element | `::before` | 0,0,0,1 | Like elements |
| Class / Pseudo-class | `.class`, `:hover` | 0,0,1,0 | Including :not() |
| Attribute | `[href]` | 0,0,1,0 | Same as class |
| ID | `#id` | 0,1,0,0 | Very specific |
| Inline style | `style=""` | 1,0,0,0 | Highest natural specificity |
| !important | anything !important | Overrides all | Emergency use only |

### Specificity Comparison Tool

```javascript
// Simple specificity calculator (concept)
function calculateSpecificity(selector) {
  // Split and count each type
  const ids = (selector.match(/#/g) || []).length;
  const classes = (selector.match(/\.[^\s#.]+|:\w+|::\w+|\[[^\]]+\]/g) || []).length;
  const elements = (selector.match(/[^\s#.:\[\]]+/g) || []).filter(s => 
    !['*', '+', '~', '>', ' '].includes(s) && 
    !/^:/.test(s) && !/^::/.test(s)
  ).length;
  
  return `${ids},${classes},${elements}`;
}

// Examples:
calculateSpecificity('#nav .menu li a:hover');       // "1,2,3"
calculateSpecificity('article p:first-child');        // "0,1,2"
calculateSpecificity('*');                            // "0,0,0"
```

## Advanced Specificity Techniques

### CSS @layer (Modern CSS)

```css
/* Define layers (lower layers = lower specificity) */
@layer reset, layout, components, utilities;

/* Reset layer (lowest precedence) */
@layer reset {
  * { box-sizing: border-box; }
}

/* Layout layer */
@layer layout {
  .grid { display: grid; }
}

/* Components layer */
@layer components {
  .button { padding: 10px; }
}

/* Utilities layer (highest precedence) */
@layer utilities {
  .text-center { text-align: center; }
}
```

### Cascade Layers vs Specificity

Layers provide an additional level to the cascade:
1. **Transition declarations**
2. **Important user agent styles**
3. **Important user styles**
4. **Important author styles**
5. **Animation styles**
6. **Author styles** → Layer order, then specificity, then source order
7. **User styles**
8. **User agent styles**

### :is() and :where() Specificity

```css
/* :is() takes specificity of most specific selector inside */
:is(header, main, footer) h1 { color: blue; } /* 0,0,0,2 (h1+footer) */

/* :where() always has specificity of 0 */
:where(header, main, footer) h1 { color: green; } /* 0,0,0,1 (only h1) */
```

### Specificity Reset Techniques

```css
/* All-rules-is - Reset specificity for component isolation */
.component :is(*) {
  all: revert; /* Resets styles for component scope */
}

/* Using :where() for base styles */
:where(.btn, .link, .input) {
  /* Specificity: 0,0,0,0 - Can be easily overridden */
}
```

## Browser DevTools Specificity Inspection

### Chrome DevTools

1. **Right-click element → Inspect**
2. **Elements tab → Styles panel**
3. **Hover over property** - See crossed out rules (overridden)
4. **Computed tab** - See final applied styles
5. **Check "Show all"** to see all applicable rules

### Firefox DevTools

1. **Inspector → Rules panel**
2. **Click toggle** to show specificity value
3. **Expansion indicator** shows overridden styles

### Safari Web Inspector

- Similar to Chrome's workflow
- Additional specificity calculation tool

## Best Practices for Managing Specificity

### 1. Follow ITCSS (Inverted Triangle CSS)

```scss
// Settings (no specificity)
@import "settings";

// Tools (no specificity)
@import "functions";

// Generic (very low specificity)
@import "reset";
@import "base";

// Elements (element selectors)
@import "elements";

// Objects (component patterns)
@import "objects";

// Components (specific UI components)
@import "components";

// Utilities (highest specificity)
@import "utilities";
```

### 2. Use Classes Over IDs

**Prefer:**
```css
.button { ... }
.button-primary { ... }
```

**Avoid:**
```css
#submit-button { ... }
```

### 3. Avoid !important

**Instead of:**
```css
.button { color: blue !important; }
```

**Use higher specificity:**
```css
.component .button { color: blue; }
```

### 4. Plan Component Architecture

```scss
// Component with predictable specificity
.c-card {                           // Block: 0,0,1,0
  // Base styles
}

.c-card__header {                  // Element: 0,0,1,0
}

.c-card--featured {                // Modifier: 0,0,1,0
  // Same specificity, overrides .c-card
}
```

### 5. Use CSS Custom Properties for Theming

```css
:root {
  --color-primary: #007bff;
  --font-size-base: 16px;
}

.button {
  background: var(--color-primary);
  font-size: var(--font-size-base);
}

/* Easy theme overrides */
.theme-dark {
  --color-primary: #343a40;
}
```

### 6. Limit Nesting Depth

```scss
// Good: Shallow nesting
.header { ... }
.header .nav { ... }
.header .nav .link { ... }

// Avoid: Deep nesting
.header {
  .container {
    .nav {
      .menu {
        .item {
          .link {
            /* Specificity: 0,0,6,0 - Hard to override */
          }
        }
      }
    }
  }
}
```

## Summary

**CSS Specificity determines which rules apply when multiple selectors target the same element.**

**Key Points:**
- **Calculation:** Inline (1) > IDs (0,1) > Classes (0,0,1) > Elements (0,0,0,1)
- **Resolution:** Higher specificity beats lower; same specificity uses source order
- **!important:** Forces override but breaks natural specificity flow
- **Best practice:** Use low, predictable specificity with classes over IDs

Proper specificity management prevents CSS conflicts and makes stylesheets more maintainable. Start with low specificity and use classes for component styling rather than relying on complex selectors or !important declarations.
